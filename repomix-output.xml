<repomix><file_summary>This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in xml style.<purpose>This file contains a packed representation of a subset of the repository&apos;s contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/app/**/*.tsx, src/app/**/*.ts, src/services/**/*.ts, src/store/**/*.ts, src/types/**/*.ts, src/utils/**/*.ts, src/components/**/*.tsx, src/middleware.ts, package.json, tsconfig.json, next.config.js, tailwind.config.js, README.md, src/app/**/*.tsx, src/app/**/*.ts, src/services/**/*.ts, src/store/**/*.ts, src/types/**/*.ts, src/utils/**/*.ts, src/components/**/*.tsx, src/middleware.ts, package.json, tsconfig.json, next.config.js, tailwind.config.js, README.md
- Files matching these patterns are excluded: *.test.js, test-*.js, debug-*.js, fix-*.js, create-*.js, direct-*.js, model-*.js, terminal-*.js, update-*.js, force-*.js, *.log, .next/**, node_modules/**, .git/**, coverage/**, dist/**, build/**, .kilocode/**, tsconfig.tsbuildinfo, *.env*, .DS_Store, *.test.js, test-*.js, debug-*.js, fix-*.js, create-*.js, direct-*.js, model-*.js, terminal-*.js, update-*.js, force-*.js, *.log, .next/**, node_modules/**, .git/**, coverage/**, dist/**, build/**, .kilocode/**, tsconfig.tsbuildinfo, *.env*, .DS_Store
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style
- Files are sorted by Git change count (files with more changes are at the bottom)</notes></file_summary><user_provided_header>RAG Web Application - Main App Logic Files</user_provided_header><directory_structure>src/
  app/
    _not-found/
      page.tsx
    auth/
      auth-code-error/
        page.tsx
      callback/
        route.ts
    login/
      page.tsx
    onboarding/
      page.tsx
    session/
      [id]/
        page.tsx
    settings/
      page.tsx
    AppInitializer.tsx
    layout.tsx
    page.tsx
  components/
    chat/
      ChatList.tsx
      CitationPanel.tsx
      MessageBubble.tsx
      MessageInput.tsx
      PhrasePills.tsx
    common/
      ConfirmDialog.tsx
      EmptyState.tsx
      ErrorBoundary.tsx
      InstallPrompt.tsx
      RouteErrorBoundary.tsx
    document/
      DocumentCard.tsx
      DocumentLibrary.tsx
      DocumentList.tsx
      DocumentProgress.tsx
      DocumentUpload.tsx
      JsonUpload.tsx
    layout/
      Header.tsx
      Sidebar.tsx
      TabBar.tsx
    session/
      CreateSessionDialog.tsx
      RenameSessionDialog.tsx
      SessionCard.tsx
      SessionList.tsx
    ui/
      Button.tsx
      Card.tsx
      DropdownMenu.tsx
      Input.tsx
      Loading.tsx
      Modal.tsx
      ReadingSourcesLoader.tsx
      ResponseProgressBar.tsx
      Switch.tsx
      TestModal.tsx
    SubscriptionModal.tsx
  services/
    gemini/
      chatService.ts
      embeddingService.ts
      geminiService.ts
      index.ts
    indexedDB/
      db.ts
      documentService.ts
      embeddingService.ts
      index.ts
      messageService.ts
      sessionService.ts
      settingsService.ts
    rag/
      chatPipeline.ts
      citationService.ts
      documentProcessor.ts
      errorHandler.ts
      index.ts
      metadataExtractor.ts
      packageValidator.ts
      progressTracker.ts
      responseFormatter.ts
      vectorSearch.ts
    index.ts
    libraryService.ts
  store/
    chatStore.ts
    documentStore.ts
    index.ts
    sessionStore.ts
    settingsStore.ts
    types.ts
  types/
    citation.ts
    document.ts
    embedding.ts
    index.ts
    library.ts
    message.ts
    preprocessed.ts
    session.ts
    settings.ts
  utils/
    supabase/
      client.ts
      server.ts
    constants.ts
    date.ts
    file.ts
    indentationAnalyzer.ts
    index.ts
    userIdDebugLogger.ts
    vector.ts
    vectorUtils.ts
  middleware.ts
next.config.js
package.json
README.md
tailwind.config.js
tsconfig.json</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="src/app/_not-found/page.tsx">import Link from &apos;next/link&apos;;
import { Button } from &apos;@/components/ui&apos;;

export default function NotFound() {
  return (
    &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col items-center justify-center px-4&quot;&gt;
      &lt;div className=&quot;text-center&quot;&gt;
        &lt;h1 className=&quot;text-6xl font-bold text-gray-900 dark:text-white mb-4&quot;&gt;404&lt;/h1&gt;
        &lt;h2 className=&quot;text-2xl font-semibold text-gray-700 dark:text-gray-300 mb-4&quot;&gt;
          Page Not Found
        &lt;/h2&gt;
        &lt;p className=&quot;text-gray-600 dark:text-gray-400 mb-8 max-w-md mx-auto&quot;&gt;
          The page you&apos;re looking for doesn&apos;t exist or has been moved.
        &lt;/p&gt;
        &lt;Link href=&quot;/&quot;&gt;
          &lt;Button size=&quot;lg&quot;&gt;
            Go Home
          &lt;/Button&gt;
        &lt;/Link&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="src/app/auth/auth-code-error/page.tsx">&apos;use client&apos;;

import Link from &apos;next/link&apos;;
import { useSearchParams } from &apos;next/navigation&apos;;
import { Suspense } from &apos;react&apos;;

function AuthCodeErrorContent() {
    const searchParams = useSearchParams();
    const error = searchParams.get(&apos;error&apos;);
    const errorDescription = searchParams.get(&apos;error_description&apos;);
    const errorMessage = error || &apos;Unknown error&apos;;
    const errorDesc = errorDescription || &apos;An error occurred during authentication.&apos;;

    return (
        &lt;div className=&quot;flex min-h-screen flex-col items-center justify-center bg-gray-900 px-6 py-12 lg:px-8&quot;&gt;
            &lt;div className=&quot;sm:mx-auto sm:w-full sm:max-w-sm text-center&quot;&gt;
                &lt;h2 className=&quot;mt-10 text-center text-2xl font-bold leading-9 tracking-tight text-white&quot;&gt;
                    Authentication Error
                &lt;/h2&gt;
                &lt;p className=&quot;mt-4 text-gray-400&quot;&gt;
                    There was an error verifying your email.
                &lt;/p&gt;
                &lt;div className=&quot;mt-4 rounded-md bg-red-900/50 p-4 text-red-200&quot;&gt;
                    &lt;p className=&quot;font-semibold&quot;&gt;{errorMessage}&lt;/p&gt;
                    {errorDesc &amp;&amp; &lt;p className=&quot;mt-2 text-sm&quot;&gt;{errorDesc}&lt;/p&gt;}
                &lt;/div&gt;
                &lt;div className=&quot;mt-10&quot;&gt;
                    &lt;Link
                        href=&quot;/login&quot;
                        className=&quot;font-semibold leading-6 text-indigo-400 hover:text-indigo-300&quot;
                    &gt;
                        Back to Login
                    &lt;/Link&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

export default function AuthCodeError() {
    return (
        &lt;Suspense fallback={
            &lt;div className=&quot;flex min-h-screen flex-col items-center justify-center bg-gray-900&quot;&gt;
                &lt;div className=&quot;text-white&quot;&gt;Loading...&lt;/div&gt;
            &lt;/div&gt;
        }&gt;
            &lt;AuthCodeErrorContent /&gt;
        &lt;/Suspense&gt;
    );
}</file><file path="src/app/auth/callback/route.ts">import { createClient } from &apos;@/utils/supabase/server&apos;
import { NextResponse } from &apos;next/server&apos;

export async function GET(request: Request) {
    const { searchParams, origin } = new URL(request.url)
    const code = searchParams.get(&apos;code&apos;)
    const next = searchParams.get(&apos;next&apos;) ?? &apos;/&apos;

    if (code) {
        const supabase = createClient()
        const { error } = await supabase.auth.exchangeCodeForSession(code)
        if (!error) {
            return NextResponse.redirect(`${origin}${next}`)
        } else {
            console.error(&apos;Auth Callback Error:&apos;, error)
            return NextResponse.redirect(`${origin}/auth/auth-code-error?error=${encodeURIComponent(error.message)}`)
        }
    }

    // return the user to an error page with instructions
    return NextResponse.redirect(`${origin}/auth/auth-code-error?error=No+code+provided`)
}</file><file path="src/app/onboarding/page.tsx">&apos;use client&apos;;

import React, { useState } from &apos;react&apos;;
import { useRouter } from &apos;next/navigation&apos;;
import { useSettingsStore } from &apos;../../store&apos;;
import { Button } from &apos;../../components/ui/Button&apos;;
import { Card } from &apos;../../components/ui/Card&apos;;
import { Input } from &apos;../../components/ui/Input&apos;;
import { Header } from &apos;../../components/layout/Header&apos;;
import clsx from &apos;clsx&apos;;

export default function OnboardingPage() {
  const router = useRouter();
  const { updateSettings, validateApiKey } = useSettingsStore();
  
  const [step, setStep] = useState(1);
  const [apiKey, setApiKey] = useState(&apos;&apos;);
  const [model, setModel] = useState(&apos;gemini-1.5-flash&apos;);
  const [isValidating, setIsValidating] = useState(false);
  const [validationError, setValidationError] = useState(&apos;&apos;);
  const [isLoading, setIsLoading] = useState(false);

  const totalSteps = 3;

  const handleNext = async () =&gt; {
    if (step === 2) {
      // Validate API key before proceeding
      if (!apiKey.trim()) {
        setValidationError(&apos;Please enter an API key&apos;);
        return;
      }

      setIsValidating(true);
      setValidationError(&apos;&apos;);

      try {
        const error = await validateApiKey(apiKey);
        if (error) {
          setValidationError(error);
          return;
        }
        setStep(step + 1);
      } catch (error) {
        setValidationError(&apos;Failed to validate API key. Please check your connection and try again.&apos;);
      } finally {
        setIsValidating(false);
      }
    } else {
      setStep(step + 1);
    }
  };

  const handleBack = () =&gt; {
    setStep(step - 1);
  };

  const handleComplete = async () =&gt; {
    setIsLoading(true);
    try {
      await updateSettings({
        geminiApiKey: apiKey,
        model: model,
      });
      router.push(&apos;/&apos;);
    } catch (error) {
      console.error(&apos;Failed to save settings:&apos;, error);
    } finally {
      setIsLoading(false);
    }
  };

  const renderStep = () =&gt; {
    switch (step) {
      case 1:
        return (
          &lt;div className=&quot;text-center space-y-6&quot;&gt;
            &lt;div className=&quot;mx-auto w-16 h-16 bg-blue-100 dark:bg-blue-900 rounded-full flex items-center justify-center&quot;&gt;
              &lt;svg className=&quot;w-8 h-8 text-blue-600 dark:text-blue-400&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M13 10V3L4 14h7v7l9-11h-7z&quot; /&gt;
              &lt;/svg&gt;
            &lt;/div&gt;
            
            &lt;div&gt;
              &lt;h2 className=&quot;text-2xl font-bold text-gray-900 dark:text-white mb-4&quot;&gt;
                Welcome to Meddy
              &lt;/h2&gt;
              &lt;p className=&quot;text-gray-600 dark:text-gray-300 max-w-md mx-auto&quot;&gt;
                Your private RAG (Retrieval-Augmented Generation) chat application for documents. 
                Chat with your documents using AI-powered search and context retrieval.
              &lt;/p&gt;
            &lt;/div&gt;

            &lt;div className=&quot;grid grid-cols-1 md:grid-cols-3 gap-4 max-w-2xl mx-auto&quot;&gt;
              &lt;Card className=&quot;p-4 text-center&quot;&gt;
                &lt;div className=&quot;w-12 h-12 bg-green-100 dark:bg-green-900 rounded-full flex items-center justify-center mx-auto mb-3&quot;&gt;
                  &lt;svg className=&quot;w-6 h-6 text-green-600 dark:text-green-400&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                    &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z&quot; /&gt;
                  &lt;/svg&gt;
                &lt;/div&gt;
                &lt;h3 className=&quot;font-semibold text-gray-900 dark:text-white mb-2&quot;&gt;Upload Documents&lt;/h3&gt;
                &lt;p className=&quot;text-sm text-gray-600 dark:text-gray-300&quot;&gt;Import PDF, DOC, TXT files for AI analysis&lt;/p&gt;
              &lt;/Card&gt;

              &lt;Card className=&quot;p-4 text-center&quot;&gt;
                &lt;div className=&quot;w-12 h-12 bg-blue-100 dark:bg-blue-900 rounded-full flex items-center justify-center mx-auto mb-3&quot;&gt;
                  &lt;svg className=&quot;w-6 h-6 text-blue-600 dark:text-blue-400&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                    &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z&quot; /&gt;
                  &lt;/svg&gt;
                &lt;/div&gt;
                &lt;h3 className=&quot;font-semibold text-gray-900 dark:text-white mb-2&quot;&gt;Chat &amp; Query&lt;/h3&gt;
                &lt;p className=&quot;text-sm text-gray-600 dark:text-gray-300&quot;&gt;Ask questions and get AI-powered responses&lt;/p&gt;
              &lt;/Card&gt;

              &lt;Card className=&quot;p-4 text-center&quot;&gt;
                &lt;div className=&quot;w-12 h-12 bg-purple-100 dark:bg-purple-900 rounded-full flex items-center justify-center mx-auto mb-3&quot;&gt;
                  &lt;svg className=&quot;w-6 h-6 text-purple-600 dark:text-purple-400&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                    &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253&quot; /&gt;
                  &lt;/svg&gt;
                &lt;/div&gt;
                &lt;h3 className=&quot;font-semibold text-gray-900 dark:text-white mb-2&quot;&gt;Get Citations&lt;/h3&gt;
                &lt;p className=&quot;text-sm text-gray-600 dark:text-gray-300&quot;&gt;See source documents for every response&lt;/p&gt;
              &lt;/Card&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        );

      case 2:
        return (
          &lt;div className=&quot;space-y-6&quot;&gt;
            &lt;div className=&quot;text-center&quot;&gt;
              &lt;h2 className=&quot;text-2xl font-bold text-gray-900 dark:text-white mb-4&quot;&gt;
                Set Up API Key
              &lt;/h2&gt;
              &lt;p className=&quot;text-gray-600 dark:text-gray-300&quot;&gt;
                Get your free Gemini API key from Google AI Studio to enable AI chat functionality
              &lt;/p&gt;
            &lt;/div&gt;

            &lt;div className=&quot;space-y-4&quot;&gt;
              &lt;div&gt;
                &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;
                  Gemini API Key
                &lt;/label&gt;
                &lt;Input
                  type=&quot;password&quot;
                  value={apiKey}
                  onChange={(e) =&gt; {
                    setApiKey(e.target.value);
                    setValidationError(&apos;&apos;);
                  }}
                  placeholder=&quot;AIza...&quot;
                  className={clsx(
                    validationError &amp;&amp; &apos;border-red-300 focus:border-red-500 focus:ring-red-500&apos;
                  )}
                /&gt;
                {validationError &amp;&amp; (
                  &lt;p className=&quot;text-sm text-red-600 dark:text-red-400 mt-1&quot;&gt;{validationError}&lt;/p&gt;
                )}
              &lt;/div&gt;

              &lt;div&gt;
                &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;
                  Model
                &lt;/label&gt;
                &lt;select
                  value={model}
                  onChange={(e) =&gt; setModel(e.target.value)}
                  className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white&quot;
                &gt;
                  &lt;option value=&quot;gemini-1.5-flash&quot;&gt;Gemini 1.5 Flash (Fast, Cost-effective)&lt;/option&gt;
                  &lt;option value=&quot;gemini-1.5-pro&quot;&gt;Gemini 1.5 Pro (Advanced)&lt;/option&gt;
                  &lt;option value=&quot;gemini-pro&quot;&gt;Gemini Pro (Legacy)&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;

              &lt;Card className=&quot;p-4 bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800&quot;&gt;
                &lt;h3 className=&quot;font-semibold text-blue-900 dark:text-blue-100 mb-2&quot;&gt;
                  How to get your API key:
                &lt;/h3&gt;
                &lt;ol className=&quot;text-sm text-blue-800 dark:text-blue-200 space-y-1 list-decimal list-inside&quot;&gt;
                  &lt;li&gt;Visit &lt;a href=&quot;https://makersuite.google.com/app/apikey&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; className=&quot;underline hover:no-underline&quot;&gt;Google AI Studio&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;Sign in with your Google account&lt;/li&gt;
                  &lt;li&gt;Click &quot;Create API Key&quot;&lt;/li&gt;
                  &lt;li&gt;Copy your API key and paste it above&lt;/li&gt;
                &lt;/ol&gt;
              &lt;/Card&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        );

      case 3:
        return (
          &lt;div className=&quot;text-center space-y-6&quot;&gt;
            &lt;div className=&quot;mx-auto w-16 h-16 bg-green-100 dark:bg-green-900 rounded-full flex items-center justify-center&quot;&gt;
              &lt;svg className=&quot;w-8 h-8 text-green-600 dark:text-green-400&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M5 13l4 4L19 7&quot; /&gt;
              &lt;/svg&gt;
            &lt;/div&gt;
            
            &lt;div&gt;
              &lt;h2 className=&quot;text-2xl font-bold text-gray-900 dark:text-white mb-4&quot;&gt;
                You&apos;re All Set!
              &lt;/h2&gt;
              &lt;p className=&quot;text-gray-600 dark:text-gray-300 max-w-md mx-auto&quot;&gt;
                Your Meddy account is configured and ready to use. Start by creating your first chat session and uploading some documents.
              &lt;/p&gt;
            &lt;/div&gt;

            &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-4 max-w-lg mx-auto&quot;&gt;
              &lt;Card className=&quot;p-4&quot;&gt;
                &lt;h3 className=&quot;font-semibold text-gray-900 dark:text-white mb-2&quot;&gt;Quick Start Tips&lt;/h3&gt;
                &lt;ul className=&quot;text-sm text-gray-600 dark:text-gray-300 text-left space-y-1&quot;&gt;
                  &lt;li&gt;‚Ä¢ Create a session for each topic&lt;/li&gt;
                  &lt;li&gt;‚Ä¢ Upload relevant documents&lt;/li&gt;
                  &lt;li&gt;‚Ä¢ Ask specific questions&lt;/li&gt;
                  &lt;li&gt;‚Ä¢ Check citations for sources&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/Card&gt;

              &lt;Card className=&quot;p-4&quot;&gt;
                &lt;h3 className=&quot;font-semibold text-gray-900 dark:text-white mb-2&quot;&gt;Privacy First&lt;/h3&gt;
                &lt;ul className=&quot;text-sm text-gray-600 dark:text-gray-300 text-left space-y-1&quot;&gt;
                  &lt;li&gt;‚Ä¢ All data stored locally&lt;/li&gt;
                  &lt;li&gt;‚Ä¢ No cloud dependencies&lt;/li&gt;
                  &lt;li&gt;‚Ä¢ Your documents stay private&lt;/li&gt;
                  &lt;li&gt;‚Ä¢ Works offline after setup&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/Card&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        );

      default:
        return null;
    }
  };

  return (
    &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col&quot;&gt;
      &lt;Header /&gt;
      
      &lt;main className=&quot;flex-1 container mx-auto px-4 py-8 max-w-4xl overflow-y-auto&quot;&gt;
        {/* Progress Bar */}
        &lt;div className=&quot;mb-8&quot;&gt;
          &lt;div className=&quot;flex items-center justify-between mb-2&quot;&gt;
            &lt;span className=&quot;text-sm font-medium text-gray-600 dark:text-gray-300&quot;&gt;
              Step {step} of {totalSteps}
            &lt;/span&gt;
            &lt;span className=&quot;text-sm font-medium text-gray-600 dark:text-gray-300&quot;&gt;
              {Math.round((step / totalSteps) * 100)}% Complete
            &lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2&quot;&gt;
            &lt;div
              className=&quot;bg-blue-500 h-2 rounded-full transition-all duration-300&quot;
              style={{ width: `${(step / totalSteps) * 100}%` }}
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Content */}
        &lt;Card className=&quot;p-8&quot;&gt;
          {renderStep()}
        &lt;/Card&gt;

        {/* Navigation */}
        &lt;div className=&quot;flex justify-between items-center mt-8&quot;&gt;
          &lt;Button
            variant=&quot;outline&quot;
            onClick={step === 1 ? () =&gt; router.push(&apos;/&apos;) : handleBack}
            disabled={isLoading}
          &gt;
            {step === 1 ? &apos;Skip&apos; : &apos;Back&apos;}
          &lt;/Button&gt;

          {step &lt; totalSteps ? (
            &lt;Button
              onClick={handleNext}
              disabled={isValidating || (step === 2 &amp;&amp; !apiKey.trim())}
              loading={isValidating}
            &gt;
              {step === 2 ? &apos;Validate &amp; Continue&apos; : &apos;Next&apos;}
            &lt;/Button&gt;
          ) : (
            &lt;Button
              onClick={handleComplete}
              disabled={isLoading}
              loading={isLoading}
            &gt;
              Get Started
            &lt;/Button&gt;
          )}
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/chat/CitationPanel.tsx">import React from &apos;react&apos;;
import { Citation } from &apos;../../types&apos;;
import { Button } from &apos;../ui/Button&apos;;

interface CitationPanelProps {
  citations: Citation[];
  maxVisible?: number;
  className?: string;
}

// Extended citation type with index for Vancouver style references
type ExtendedCitation = Citation &amp; { citationIndex: number };

// Group citations by page number
const groupCitationsByPage = (citations: Citation[]): Map&lt;string, ExtendedCitation[]&gt; =&gt; {
  const grouped = new Map&lt;string, ExtendedCitation[]&gt;();
  
  citations.forEach((citation, index) =&gt; {
    // Use page number as key, fallback to index if no page
    const pageKey = citation.page ? `Page ${citation.page}` : `Source ${index + 1}`;
    
    if (!grouped.has(pageKey)) {
      grouped.set(pageKey, []);
    }
    
    // Add citation index for Vancouver style reference
    grouped.get(pageKey)!.push({
      ...citation,
      // Store the original index for Vancouver style numbering
      citationIndex: index + 1
    });
  });
  
  return grouped;
};

export const CitationPanel: React.FC&lt;CitationPanelProps&gt; = ({
  citations,
  maxVisible,
  className,
}) =&gt; {
  const [isExpanded, setIsExpanded] = React.useState(false);
  
  // Group citations by page
  const groupedCitations = groupCitationsByPage(citations);
  const pageGroups = Array.from(groupedCitations.entries());
  
  // Always show only one reference initially, regardless of maxVisible prop
  const visibleGroups = isExpanded
    ? pageGroups
    : pageGroups.slice(0, 1);

  if (citations.length === 0) {
    return null;
  }

  return (
    &lt;div className={`space-y-3 ${className}`}&gt;
      &lt;div className=&quot;flex items-center gap-2 text-xs text-gray-600 dark:text-gray-400&quot;&gt;
        &lt;svg
          className=&quot;w-4 h-4&quot;
          fill=&quot;none&quot;
          viewBox=&quot;0 0 24 24&quot;
          stroke=&quot;currentColor&quot;
        &gt;
          &lt;path
            strokeLinecap=&quot;round&quot;
            strokeLinejoin=&quot;round&quot;
            strokeWidth={2}
            d=&quot;M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z&quot;
          /&gt;
        &lt;/svg&gt;
        &lt;span&gt;Vancouver Style References ({pageGroups.length} page{pageGroups.length !== 1 ? &apos;s&apos; : &apos;&apos;})&lt;/span&gt;
      &lt;/div&gt;

      &lt;div className=&quot;space-y-3&quot;&gt;
        {visibleGroups.map(([pageTitle, pageCitations], index) =&gt; (
          &lt;React.Fragment key={pageTitle}&gt;
            &lt;PageCitationGroup
              pageTitle={pageTitle}
              citations={pageCitations}
            /&gt;
            {/* Show &quot;View all references&quot; button after the first reference */}
            {index === 0 &amp;&amp; pageGroups.length &gt; 1 &amp;&amp; !isExpanded &amp;&amp; (
              &lt;div className=&quot;flex justify-center&quot;&gt;
                &lt;Button
                  variant=&quot;ghost&quot;
                  size=&quot;sm&quot;
                  onClick={() =&gt; setIsExpanded(!isExpanded)}
                  className=&quot;h-auto p-0 text-xs font-medium text-blue-600 dark:text-blue-400 hover:underline&quot;
                &gt;
                  View all references
                &lt;/Button&gt;
              &lt;/div&gt;
            )}
          &lt;/React.Fragment&gt;
        ))}
        {/* Show &quot;Show less&quot; button when expanded */}
        {isExpanded &amp;&amp; pageGroups.length &gt; 1 &amp;&amp; (
          &lt;div className=&quot;flex justify-center&quot;&gt;
            &lt;Button
              variant=&quot;ghost&quot;
              size=&quot;sm&quot;
              onClick={() =&gt; setIsExpanded(!isExpanded)}
              className=&quot;h-auto p-0 text-xs font-medium text-blue-600 dark:text-blue-400 hover:underline&quot;
            &gt;
              Show less
            &lt;/Button&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

// Component to display a group of citations from the same page
interface PageCitationGroupProps {
  pageTitle: string;
  citations: ExtendedCitation[];
}

const PageCitationGroup: React.FC&lt;PageCitationGroupProps&gt; = ({ pageTitle, citations }) =&gt; {
  const [isExpanded, setIsExpanded] = React.useState(false);
  
  // Combine all content from citations on this page
  const combinedContent = citations
    .map(c =&gt; c.excerpt || &apos;&apos;)
    .filter(content =&gt; content.trim() !== &apos;&apos;)
    .join(&apos;\n\n---\n\n&apos;);
  
  // Get all citation indices for Vancouver style references
  const citationIndices = citations.map(c =&gt; c.citationIndex);
  const citationRefs = citationIndices.map(index =&gt; `[${index}]`).join(&apos;, &apos;);
  
  // Get document name from first citation
  const documentName = citations[0]?.document || &apos;Unknown Document&apos;;
  
  const previewLength = 300;
  const needsExpansion = combinedContent.length &gt; previewLength;

  return (
    &lt;div className=&quot;page-citation-group&quot;&gt;
      {/* Page Header */}
      &lt;div className=&quot;page-citation-header&quot;&gt;
        &lt;div className=&quot;flex items-center gap-3&quot;&gt;
          &lt;span className=&quot;text-sm font-bold text-blue-600 dark:text-blue-400&quot;&gt;
            {citationRefs}
          &lt;/span&gt;
          &lt;h3 className=&quot;page-citation-title text-xs&quot;&gt;
            {pageTitle}
          &lt;/h3&gt;
          &lt;span className=&quot;text-xs text-gray-600 dark:text-gray-400&quot;&gt;
            {documentName}
          &lt;/span&gt;
        &lt;/div&gt;
        
        {citations.length &gt; 1 &amp;&amp; (
          &lt;span className=&quot;text-xs bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300 px-2 py-1 rounded-full&quot;&gt;
            {citations.length} citation{citations.length &gt; 1 ? &apos;s&apos; : &apos;&apos;}
          &lt;/span&gt;
        )}
      &lt;/div&gt;
      
      {/* Combined Content */}
      {combinedContent &amp;&amp; (
        &lt;div className=&quot;page-citation-content&quot;&gt;
          &lt;div className={`
            ${isExpanded ? &apos;&apos; : &apos;line-clamp-4&apos;}
            transition-all duration-200
          `}&gt;
            {isExpanded ? combinedContent : combinedContent.substring(0, previewLength) + (needsExpansion ? &apos;...&apos; : &apos;&apos;)}
          &lt;/div&gt;
          
          {needsExpansion &amp;&amp; (
            &lt;button
              onClick={() =&gt; setIsExpanded(!isExpanded)}
              className=&quot;text-xs text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-300 mt-2 font-medium&quot;
            &gt;
              {isExpanded ? &apos;Show less&apos; : &apos;Show full text&apos;}
            &lt;/button&gt;
          )}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};</file><file path="src/components/chat/MessageInput.tsx">import React, { useState, useRef, useEffect } from &apos;react&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { useChat } from &apos;../../store&apos;;

interface MessageInputProps {
  sessionId: string;
  onSendMessage?: (message: string) =&gt; void;
  disabled?: boolean;
  placeholder?: string;
  className?: string;
  value?: string;
  onChange?: (value: string) =&gt; void;
  inputRef?: React.RefObject&lt;HTMLTextAreaElement&gt;;
}

export const MessageInput: React.FC&lt;MessageInputProps&gt; = ({
  sessionId,
  onSendMessage,
  disabled = false,
  placeholder = &apos;Type your message...&apos;,
  className,
  value,
  onChange,
  inputRef,
}) =&gt; {
  const [internalMessage, setInternalMessage] = useState(&apos;&apos;);
  const [isComposing, setIsComposing] = useState(false);
  const internalTextareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);
  const { sendMessage, isStreaming } = useChat();
  
  // Use external value if provided, otherwise use internal state
  const message = value !== undefined ? value : internalMessage;
  const textareaRef = inputRef || internalTextareaRef;
  
  // Handle message changes
  const handleMessageChange = (newValue: string) =&gt; {
    if (onChange) {
      onChange(newValue);
    } else {
      setInternalMessage(newValue);
    }
  };

  // Auto-resize textarea
  useEffect(() =&gt; {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = &apos;auto&apos;;
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
    }
  }, [message]);

  // Focus on mount
  useEffect(() =&gt; {
    if (textareaRef.current &amp;&amp; !disabled) {
      textareaRef.current.focus();
    }
  }, [disabled]);

  const handleSend = async () =&gt; {
    const trimmedMessage = message.trim();
    if (!trimmedMessage || disabled || isStreaming || isComposing) {
      return;
    }

    // Clear the message immediately to provide instant feedback
    if (onChange) {
      onChange(&apos;&apos;);
    } else {
      setInternalMessage(&apos;&apos;);
    }

    try {
      if (onSendMessage) {
        onSendMessage(trimmedMessage);
      } else {
        await sendMessage(sessionId, trimmedMessage);
      }
    } catch (error) {
      console.error(&apos;Failed to send message:&apos;, error);
      // Restore the message if sending failed
      if (onChange) {
        onChange(trimmedMessage);
      } else {
        setInternalMessage(trimmedMessage);
      }
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; {
    if (e.key === &apos;Enter&apos; &amp;&amp; !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const handlePaste = (e: React.ClipboardEvent) =&gt; {
    // Handle paste events, especially for images or files in the future
    const items = e.clipboardData?.items;
    if (items) {
      for (let i = 0; i &lt; items.length; i++) {
        if (items[i].type.indexOf(&apos;image&apos;) !== -1) {
          e.preventDefault();
          // Future: Handle image paste
          console.log(&apos;Image paste detected - feature not yet implemented&apos;);
          return;
        }
      }
    }
  };

  const isDisabled = disabled || isStreaming || !message.trim();

  return (
    &lt;div className={`border-t border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 p-3 sm:p-4 ${className}`}&gt;
      &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
        &lt;div className=&quot;flex gap-2 sm:gap-3&quot;&gt;
          {/* Textarea */}
          &lt;div className=&quot;flex-1 relative&quot;&gt;
            &lt;textarea
              ref={textareaRef}
              value={message}
              onChange={(e) =&gt; handleMessageChange(e.target.value)}
              onKeyDown={handleKeyDown}
              onPaste={handlePaste}
              onCompositionStart={() =&gt; setIsComposing(true)}
              onCompositionEnd={() =&gt; setIsComposing(false)}
              placeholder={placeholder}
              disabled={disabled || isStreaming}
              rows={1}
              className={`
                w-full px-3 py-2 sm:px-4 sm:py-3 pr-10 sm:pr-12
                border border-gray-300 dark:border-gray-600 rounded-lg
                bg-white dark:bg-gray-800
                text-gray-900 dark:text-gray-100
                placeholder-gray-500 dark:placeholder-gray-400
                resize-none overflow-hidden
                focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent
                disabled:opacity-50 disabled:cursor-not-allowed
                transition-colors duration-200
                text-base sm:text-sm
                touch-manipulation
              `}
            /&gt;
            
            {/* Character count for long messages */}
            {message.length &gt; 500 &amp;&amp; (
              &lt;div className=&quot;absolute bottom-1 sm:bottom-2 right-1 sm:right-2 text-xs text-gray-400 dark:text-gray-500&quot;&gt;
                {message.length}/10000
              &lt;/div&gt;
            )}
          &lt;/div&gt;

          {/* Send Button */}
          &lt;Button
            onClick={handleSend}
            disabled={isDisabled}
            loading={isStreaming}
            className=&quot;self-end px-3 sm:px-4&quot;
          &gt;
            &lt;svg
              className=&quot;w-4 h-4&quot;
              fill=&quot;none&quot;
              viewBox=&quot;0 0 24 24&quot;
              stroke=&quot;currentColor&quot;
            &gt;
              &lt;path
                strokeLinecap=&quot;round&quot;
                strokeLinejoin=&quot;round&quot;
                strokeWidth={2}
                d=&quot;M12 19l9 2-9-18-9 18 9-2zm0 0v-8&quot;
              /&gt;
            &lt;/svg&gt;
            &lt;span className=&quot;ml-1 sm:ml-2 hidden sm:inline&quot;&gt;Send&lt;/span&gt;
          &lt;/Button&gt;
        &lt;/div&gt;

        {/* Helper text */}
        &lt;div className=&quot;mt-1 sm:mt-2 text-xs text-gray-500 dark:text-gray-400 hidden sm:block&quot;&gt;
          Press &lt;kbd className=&quot;px-1 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs&quot;&gt;Enter&lt;/kbd&gt; to send,
          &lt;kbd className=&quot;px-1 py-1 bg-gray-100 dark:bg-gray-700 rounded ml-1 text-xs&quot;&gt;Shift + Enter&lt;/kbd&gt; for new line
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

// Voice input button component (placeholder for future implementation)
export const VoiceInputButton: React.FC&lt;{
  onTranscript: (transcript: string) =&gt; void;
  disabled?: boolean;
  className?: string;
}&gt; = ({ onTranscript, disabled = false, className }) =&gt; {
  const [isListening, setIsListening] = useState(false);

  const handleToggleListening = () =&gt; {
    if (isListening) {
      // Stop listening
      setIsListening(false);
      // Future: Implement speech recognition stop
    } else {
      // Start listening
      setIsListening(true);
      // Future: Implement speech recognition start
      console.log(&apos;Voice input not yet implemented&apos;);
    }
  };

  return (
    &lt;Button
      variant=&quot;ghost&quot;
      size=&quot;sm&quot;
      onClick={handleToggleListening}
      disabled={disabled}
      className={className}
    &gt;
      &lt;svg
        className={`
          w-5 h-5
          ${isListening ? &apos;text-red-500 animate-pulse&apos; : &apos;text-gray-500&apos;}
        `}
        fill=&quot;none&quot;
        viewBox=&quot;0 0 24 24&quot;
        stroke=&quot;currentColor&quot;
      &gt;
        &lt;path
          strokeLinecap=&quot;round&quot;
          strokeLinejoin=&quot;round&quot;
          strokeWidth={2}
          d=&quot;M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3 3v4h6V6a3 3 0 00-3-3z&quot;
        /&gt;
      &lt;/svg&gt;
    &lt;/Button&gt;
  );
};</file><file path="src/components/common/ConfirmDialog.tsx">import React from &apos;react&apos;;
import { Modal } from &apos;../ui/Modal&apos;;
import { Button } from &apos;../ui/Button&apos;;

interface ConfirmDialogProps {
  isOpen: boolean;
  onClose: () =&gt; void;
  onConfirm: () =&gt; void;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  variant?: &apos;danger&apos; | &apos;warning&apos; | &apos;info&apos;;
  isLoading?: boolean;
}

export const ConfirmDialog: React.FC&lt;ConfirmDialogProps&gt; = ({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = &apos;Confirm&apos;,
  cancelText = &apos;Cancel&apos;,
  variant = &apos;info&apos;,
  isLoading = false,
}) =&gt; {
  const handleConfirm = () =&gt; {
    console.log(&apos;üîç ConfirmDialog: handleConfirm called&apos;, {
      isLoading,
      hasOnConfirm: typeof onConfirm === &apos;function&apos;,
      title,
      timestamp: new Date().toISOString()
    });
    // Don&apos;t call onClose here - let the useConfirmDialog hook handle it
    // This prevents premature closing before async operations complete
    console.log(&apos;üîç ConfirmDialog: About to call onConfirm callback&apos;);
    try {
      const result = onConfirm();
      console.log(&apos;üîç ConfirmDialog: onConfirm callback returned&apos;, {
        result,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error(&apos;‚ùå ConfirmDialog: Error calling onConfirm callback&apos;, {
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
        timestamp: new Date().toISOString()
      });
    }
    console.log(&apos;‚úÖ ConfirmDialog: handleConfirm completed&apos;);
  };

  const getVariantClasses = () =&gt; {
    switch (variant) {
      case &apos;danger&apos;:
        return {
          icon: &apos;text-red-500&apos;,
          button: &apos;danger&apos;,
        };
      case &apos;warning&apos;:
        return {
          icon: &apos;text-yellow-500&apos;,
          button: &apos;warning&apos;,
        };
      default:
        return {
          icon: &apos;text-blue-500&apos;,
          button: &apos;primary&apos;,
        };
    }
  };

  const variantClasses = getVariantClasses();

  const getIcon = () =&gt; {
    switch (variant) {
      case &apos;danger&apos;:
        return (
          &lt;svg
            className=&quot;h-6 w-6 text-red-500&quot;
            fill=&quot;none&quot;
            viewBox=&quot;0 0 24 24&quot;
            stroke=&quot;currentColor&quot;
          &gt;
            &lt;path
              strokeLinecap=&quot;round&quot;
              strokeLinejoin=&quot;round&quot;
              strokeWidth={2}
              d=&quot;M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z&quot;
            /&gt;
          &lt;/svg&gt;
        );
      case &apos;warning&apos;:
        return (
          &lt;svg
            className=&quot;h-6 w-6 text-yellow-500&quot;
            fill=&quot;none&quot;
            viewBox=&quot;0 0 24 24&quot;
            stroke=&quot;currentColor&quot;
          &gt;
            &lt;path
              strokeLinecap=&quot;round&quot;
              strokeLinejoin=&quot;round&quot;
              strokeWidth={2}
              d=&quot;M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z&quot;
            /&gt;
          &lt;/svg&gt;
        );
      default:
        return (
          &lt;svg
            className=&quot;h-6 w-6 text-blue-500&quot;
            fill=&quot;none&quot;
            viewBox=&quot;0 0 24 24&quot;
            stroke=&quot;currentColor&quot;
          &gt;
            &lt;path
              strokeLinecap=&quot;round&quot;
              strokeLinejoin=&quot;round&quot;
              strokeWidth={2}
              d=&quot;M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z&quot;
            /&gt;
          &lt;/svg&gt;
        );
    }
  };

  console.log(&apos;üîç ConfirmDialog: About to render Modal&apos;, {
    isOpen,
    title,
    message,
    variant,
    isLoading
  });

  return (
    &lt;Modal
      isOpen={isOpen}
      onClose={onClose}
      size=&quot;sm&quot;
    &gt;
      &lt;div className=&quot;text-center&quot;&gt;
        &lt;div className=&quot;mx-auto mb-4&quot;&gt;
          {getIcon()}
        &lt;/div&gt;
        
        &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white mb-2&quot;&gt;
          {title}
        &lt;/h3&gt;
        
        &lt;p className=&quot;text-gray-600 dark:text-gray-300 mb-6&quot;&gt;
          {message}
        &lt;/p&gt;
        
        &lt;div className=&quot;flex gap-3 justify-center&quot;&gt;
          &lt;Button
            variant=&quot;outline&quot;
            onClick={onClose}
            disabled={isLoading}
          &gt;
            {cancelText}
          &lt;/Button&gt;
          
          &lt;Button
            variant={variantClasses.button as any}
            onClick={() =&gt; {
              console.log(&apos;üîç ConfirmDialog: Confirm button clicked&apos;, {
                isLoading,
                title,
                confirmText
              });
              handleConfirm();
            }}
            disabled={isLoading}
            loading={isLoading}
          &gt;
            {confirmText}
          &lt;/Button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/Modal&gt;
  );
};

// Hook for showing confirmation dialogs
export const useConfirmDialog = () =&gt; {
  const [dialog, setDialog] = React.useState&lt;{
    isOpen: boolean;
    title: string;
    message: string;
    onConfirm: () =&gt; void;
    resolve?: (value: boolean) =&gt; void;
    variant?: &apos;danger&apos; | &apos;warning&apos; | &apos;info&apos;;
    confirmText?: string;
    cancelText?: string;
  }&gt;({
    isOpen: false,
    title: &apos;&apos;,
    message: &apos;&apos;,
    onConfirm: () =&gt; {},
  });

  const [isLoading, setIsLoading] = React.useState(false);

  const confirm = (options: {
    title: string;
    message: string;
    onConfirm: () =&gt; void | Promise&lt;void&gt; | Promise&lt;boolean&gt;;
    variant?: &apos;danger&apos; | &apos;warning&apos; | &apos;info&apos;;
    confirmText?: string;
    cancelText?: string;
  }): Promise&lt;boolean&gt; =&gt; {
    console.log(&apos;üîç useConfirmDialog: confirm called with options:&apos;, {
      title: options.title,
      variant: options.variant,
      hasOnConfirm: typeof options.onConfirm === &apos;function&apos;
    });
    
    return new Promise&lt;boolean&gt;((resolve) =&gt; {
      console.log(&apos;üîç useConfirmDialog: Creating new Promise for confirmation&apos;);
      setDialog({
        isOpen: true,
        ...options,
        resolve,
      });
      console.log(&apos;‚úÖ useConfirmDialog: Dialog state set to open with resolve function&apos;);
    });
  };

  const handleClose = () =&gt; {
    console.log(&apos;üîç useConfirmDialog: handleClose called, resolving with false and closing dialog&apos;);
    if (dialog.resolve) {
      dialog.resolve(false);
    }
    setDialog(prev =&gt; ({ ...prev, isOpen: false }));
    console.log(&apos;‚úÖ useConfirmDialog: Dialog state set to closed&apos;);
  };

  const handleConfirm = async () =&gt; {
    console.log(&apos;üîç useConfirmDialog: handleConfirm started&apos;, {
      dialogTitle: dialog.title,
      hasOnConfirm: typeof dialog.onConfirm === &apos;function&apos;,
      isOpen: dialog.isOpen,
      hasResolve: typeof dialog.resolve === &apos;function&apos;,
      timestamp: new Date().toISOString()
    });
    setIsLoading(true);
    try {
      console.log(&apos;üîç useConfirmDialog: About to call dialog.onConfirm&apos;);
      const startTime = Date.now();
      const result = await dialog.onConfirm();
      const endTime = Date.now();
      console.log(&apos;‚úÖ useConfirmDialog: dialog.onConfirm completed successfully&apos;, {
        result,
        duration: endTime - startTime,
        timestamp: new Date().toISOString()
      });
      
      // Resolve with true after successful confirmation
      if (dialog.resolve) {
        console.log(&apos;üîç useConfirmDialog: Resolving Promise with true (confirmed)&apos;, {
          timestamp: new Date().toISOString()
        });
        dialog.resolve(true);
      } else {
        console.error(&apos;‚ùå useConfirmDialog: No resolve function available!&apos;);
      }
    } catch (error) {
      console.error(&apos;‚ùå useConfirmDialog: Error in dialog.onConfirm:&apos;, {
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
        timestamp: new Date().toISOString()
      });
      
      // Still resolve with false on error to close the dialog
      if (dialog.resolve) {
        console.log(&apos;üîç useConfirmDialog: Resolving Promise with false (error occurred)&apos;, {
          timestamp: new Date().toISOString()
        });
        dialog.resolve(false);
      } else {
        console.error(&apos;‚ùå useConfirmDialog: No resolve function available during error handling!&apos;);
      }
    } finally {
      console.log(&apos;üîç useConfirmDialog: Cleaning up - setting isLoading to false and closing dialog&apos;, {
        timestamp: new Date().toISOString()
      });
      setIsLoading(false);
      setDialog(prev =&gt; ({ ...prev, isOpen: false }));
    }
  };

  const ConfirmDialogComponent = () =&gt; (
    &lt;ConfirmDialog
      isOpen={dialog.isOpen}
      onClose={handleClose}
      onConfirm={handleConfirm}
      title={dialog.title}
      message={dialog.message}
      variant={dialog.variant}
      confirmText={dialog.confirmText}
      cancelText={dialog.cancelText}
      isLoading={isLoading}
    /&gt;
  );

  return {
    confirm,
    ConfirmDialog: ConfirmDialogComponent,
  };
};</file><file path="src/components/common/EmptyState.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

interface EmptyStateProps {
  icon?: React.ReactNode;
  title: string;
  description?: string;
  action?: React.ReactNode;
  className?: string;
  size?: &apos;sm&apos; | &apos;md&apos; | &apos;lg&apos;;
}

export const EmptyState: React.FC&lt;EmptyStateProps&gt; = ({
  icon,
  title,
  description,
  action,
  className,
  size = &apos;md&apos;,
}) =&gt; {
  const sizeClasses = {
    sm: &apos;p-4&apos;,
    md: &apos;p-8&apos;,
    lg: &apos;p-12&apos;,
  };

  const iconSizes = {
    sm: &apos;h-8 w-8&apos;,
    md: &apos;h-12 w-12&apos;,
    lg: &apos;h-16 w-16&apos;,
  };

  return (
    &lt;div className={clsx(&apos;text-center&apos;, sizeClasses[size], className)}&gt;
      {icon &amp;&amp; (
        &lt;div className={clsx(&apos;mx-auto mb-4 text-gray-400&apos;, iconSizes[size])}&gt;
          {icon}
        &lt;/div&gt;
      )}
      
      &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white mb-2&quot;&gt;
        {title}
      &lt;/h3&gt;
      
      {description &amp;&amp; (
        &lt;p className=&quot;text-gray-600 dark:text-gray-300 mb-6 max-w-sm mx-auto&quot;&gt;
          {description}
        &lt;/p&gt;
      )}
      
      {action &amp;&amp; (
        &lt;div className=&quot;flex justify-center&quot;&gt;
          {action}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

// Default empty states for common scenarios
export const EmptyStates = {
  NoSessions: () =&gt; (
    &lt;EmptyState
      icon={
        &lt;svg
          fill=&quot;none&quot;
          viewBox=&quot;0 0 24 24&quot;
          stroke=&quot;currentColor&quot;
        &gt;
          &lt;path
            strokeLinecap=&quot;round&quot;
            strokeLinejoin=&quot;round&quot;
            strokeWidth={2}
            d=&quot;M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z&quot;
          /&gt;
        &lt;/svg&gt;
      }
      title=&quot;No conversations yet&quot;
      description=&quot;Start your first conversation to begin chatting with your documents&quot;
    /&gt;
  ),
  
  NoDocuments: () =&gt; (
    &lt;EmptyState
      icon={
        &lt;svg
          fill=&quot;none&quot;
          viewBox=&quot;0 0 24 24&quot;
          stroke=&quot;currentColor&quot;
        &gt;
          &lt;path
            strokeLinecap=&quot;round&quot;
            strokeLinejoin=&quot;round&quot;
            strokeWidth={2}
            d=&quot;M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z&quot;
          /&gt;
        &lt;/svg&gt;
      }
      title=&quot;No documents uploaded&quot;
      description=&quot;Upload documents to start asking questions about their content&quot;
    /&gt;
  ),
  
  NoMessages: () =&gt; (
    &lt;EmptyState
      icon={
        &lt;svg
          fill=&quot;none&quot;
          viewBox=&quot;0 0 24 24&quot;
          stroke=&quot;currentColor&quot;
        &gt;
          &lt;path
            strokeLinecap=&quot;round&quot;
            strokeLinejoin=&quot;round&quot;
            strokeWidth={2}
            d=&quot;M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z&quot;
          /&gt;
        &lt;/svg&gt;
      }
      title=&quot;No messages yet&quot;
      description=&quot;Send a message to start the conversation&quot;
    /&gt;
  ),
  
  NoSearchResults: () =&gt; (
    &lt;EmptyState
      icon={
        &lt;svg
          fill=&quot;none&quot;
          viewBox=&quot;0 0 24 24&quot;
          stroke=&quot;currentColor&quot;
        &gt;
          &lt;path
            strokeLinecap=&quot;round&quot;
            strokeLinejoin=&quot;round&quot;
            strokeWidth={2}
            d=&quot;M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z&quot;
          /&gt;
        &lt;/svg&gt;
      }
      title=&quot;No results found&quot;
      description=&quot;Try adjusting your search terms or filters&quot;
    /&gt;
  ),
  
  Error: ({ message }: { message?: string }) =&gt; (
    &lt;EmptyState
      icon={
        &lt;svg
          fill=&quot;none&quot;
          viewBox=&quot;0 0 24 24&quot;
          stroke=&quot;currentColor&quot;
        &gt;
          &lt;path
            strokeLinecap=&quot;round&quot;
            strokeLinejoin=&quot;round&quot;
            strokeWidth={2}
            d=&quot;M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z&quot;
          /&gt;
        &lt;/svg&gt;
      }
      title=&quot;Something went wrong&quot;
      description={message || &apos;An error occurred while loading this content&apos;}
    /&gt;
  ),
};</file><file path="src/components/common/ErrorBoundary.tsx">import React, { Component, ErrorInfo, ReactNode } from &apos;react&apos;;
import { Button } from &apos;../ui&apos;;

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) =&gt; void;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component&lt;Props, State&gt; {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error(&apos;ErrorBoundary caught an error:&apos;, error, errorInfo);
    
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  handleReset = () =&gt; {
    this.setState({ hasError: false, error: undefined });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return &lt;&gt;{this.props.fallback}&lt;/&gt;;
      }

      return (
        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900&quot;&gt;
          &lt;div className=&quot;max-w-md w-full bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 text-center&quot;&gt;
            &lt;div className=&quot;mb-4&quot;&gt;
              &lt;svg
                className=&quot;mx-auto h-12 w-12 text-red-500&quot;
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 18.5c-.77.833.192 2.5 1.732 2.5z&quot;
                /&gt;
              &lt;/svg&gt;
            &lt;/div&gt;
            
            &lt;h1 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-2&quot;&gt;
              Something went wrong
            &lt;/h1&gt;
            
            &lt;p className=&quot;text-gray-600 dark:text-gray-300 mb-6&quot;&gt;
              {this.state.error?.message || &apos;An unexpected error occurred&apos;}
            &lt;/p&gt;
            
            &lt;div className=&quot;space-y-3&quot;&gt;
              &lt;Button
                onClick={this.handleReset}
                variant=&quot;primary&quot;
                className=&quot;w-full&quot;
              &gt;
                Try Again
              &lt;/Button&gt;
              
              &lt;Button
                onClick={() =&gt; window.location.reload()}
                variant=&quot;outline&quot;
                className=&quot;w-full&quot;
              &gt;
                Reload Page
              &lt;/Button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      );
    }

    return this.props.children;
  }
}</file><file path="src/components/common/InstallPrompt.tsx">&apos;use client&apos;;

import React, { useEffect, useState } from &apos;react&apos;;
import { Button } from &apos;../ui/Button&apos;;

export const InstallPrompt = () =&gt; {
    const [deferredPrompt, setDeferredPrompt] = useState&lt;any&gt;(null);
    const [showPrompt, setShowPrompt] = useState(false);

    useEffect(() =&gt; {
        const handler = (e: any) =&gt; {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later.
            setDeferredPrompt(e);
            // Update UI notify the user they can install the PWA
            setShowPrompt(true);
        };

        window.addEventListener(&apos;beforeinstallprompt&apos;, handler);

        return () =&gt; {
            window.removeEventListener(&apos;beforeinstallprompt&apos;, handler);
        };
    }, []);

    const handleInstallClick = async () =&gt; {
        if (!deferredPrompt) return;

        // Show the install prompt
        deferredPrompt.prompt();

        // Wait for the user to respond to the prompt
        const { outcome } = await deferredPrompt.userChoice;
        console.log(`User response to the install prompt: ${outcome}`);

        // We&apos;ve used the prompt, and can&apos;t use it again, throw it away
        setDeferredPrompt(null);
        setShowPrompt(false);
    };

    if (!showPrompt) return null;

    return (
        &lt;div className=&quot;fixed bottom-4 left-4 right-4 z-50 md:left-auto md:right-4 md:w-96&quot;&gt;
            &lt;div className=&quot;bg-white dark:bg-gray-800 p-4 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 flex flex-col gap-3&quot;&gt;
                &lt;div className=&quot;flex items-start justify-between&quot;&gt;
                    &lt;div&gt;
                        &lt;h3 className=&quot;font-semibold text-gray-900 dark:text-white&quot;&gt;Install MEDDY&lt;/h3&gt;
                        &lt;p className=&quot;text-sm text-gray-600 dark:text-gray-300 mt-1&quot;&gt;
                            Install our app for a better experience with offline access and faster loading.
                        &lt;/p&gt;
                    &lt;/div&gt;
                    &lt;button
                        onClick={() =&gt; setShowPrompt(false)}
                        className=&quot;text-gray-400 hover:text-gray-500 dark:hover:text-gray-300&quot;
                    &gt;
                        &lt;svg className=&quot;w-5 h-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M6 18L18 6M6 6l12 12&quot; /&gt;
                        &lt;/svg&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
                &lt;div className=&quot;flex justify-end gap-2&quot;&gt;
                    &lt;Button variant=&quot;ghost&quot; size=&quot;sm&quot; onClick={() =&gt; setShowPrompt(false)}&gt;
                        Not now
                    &lt;/Button&gt;
                    &lt;Button variant=&quot;primary&quot; size=&quot;sm&quot; onClick={handleInstallClick}&gt;
                        Install
                    &lt;/Button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};</file><file path="src/components/common/RouteErrorBoundary.tsx">&apos;use client&apos;;

import React from &apos;react&apos;;
import { useEffect } from &apos;react&apos;;
import { useRouter } from &apos;next/navigation&apos;;

interface RouteErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: React.ErrorInfo;
}

export class RouteErrorBoundary extends React.Component&lt;
  React.PropsWithChildren&lt;{}&gt;,
  RouteErrorBoundaryState
&gt; {
  constructor(props: React.PropsWithChildren&lt;{}&gt;) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): RouteErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error(&apos;üö® [ROUTE_ERROR_BOUNDARY] Caught routing error:&apos;, {
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      currentUrl: window.location.href
    });

    this.setState({ error, errorInfo });
  }

  render() {
    if (this.state.hasError) {
      return &lt;ErrorFallback error={this.state.error} errorInfo={this.state.errorInfo} /&gt;;
    }

    return this.props.children;
  }
}

function ErrorFallback({ error, errorInfo }: { error?: Error; errorInfo?: React.ErrorInfo }) {
  const router = useRouter();

  useEffect(() =&gt; {
    // Log detailed error information for debugging
    console.log(&apos;üîç [ROUTE_ERROR_FALLBACK] Error details:&apos;, {
      errorMessage: error?.message,
      errorStack: error?.stack,
      componentStack: errorInfo?.componentStack,
      currentPath: window.location.pathname,
      referrer: document.referrer,
      timestamp: new Date().toISOString()
    });
  }, [error, errorInfo]);

  const handleReload = () =&gt; {
    window.location.reload();
  };

  const handleGoHome = () =&gt; {
    router.push(&apos;/&apos;);
  };

  return (
    &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col items-center justify-center px-4&quot;&gt;
      &lt;div className=&quot;max-w-md w-full text-center&quot;&gt;
        &lt;div className=&quot;mb-6&quot;&gt;
          &lt;div className=&quot;mx-auto w-16 h-16 bg-red-100 dark:bg-red-900 rounded-full flex items-center justify-center mb-4&quot;&gt;
            &lt;svg
              className=&quot;w-8 h-8 text-red-600 dark:text-red-400&quot;
              fill=&quot;none&quot;
              viewBox=&quot;0 0 24 24&quot;
              stroke=&quot;currentColor&quot;
            &gt;
              &lt;path
                strokeLinecap=&quot;round&quot;
                strokeLinejoin=&quot;round&quot;
                strokeWidth={2}
                d=&quot;M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z&quot;
              /&gt;
            &lt;/svg&gt;
          &lt;/div&gt;
          
          &lt;h1 className=&quot;text-2xl font-bold text-gray-900 dark:text-white mb-2&quot;&gt;
            Navigation Error
          &lt;/h1&gt;
          
          &lt;p className=&quot;text-gray-600 dark:text-gray-300 mb-6&quot;&gt;
            Something went wrong while loading this page. This might be a routing issue.
          &lt;/p&gt;

          {process.env.NODE_ENV === &apos;development&apos; &amp;&amp; error &amp;&amp; (
            &lt;div className=&quot;mb-6 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md text-left&quot;&gt;
              &lt;p className=&quot;text-sm font-medium text-red-800 dark:text-red-200 mb-2&quot;&gt;
                Error Details (Development Mode):
              &lt;/p&gt;
              &lt;p className=&quot;text-xs text-red-600 dark:text-red-400 font-mono break-all&quot;&gt;
                {error.message}
              &lt;/p&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;

        &lt;div className=&quot;space-y-3&quot;&gt;
          &lt;button
            onClick={handleReload}
            className=&quot;w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors&quot;
          &gt;
            Reload Page
          &lt;/button&gt;
          
          &lt;button
            onClick={handleGoHome}
            className=&quot;w-full px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors&quot;
          &gt;
            Go to Home
          &lt;/button&gt;
        &lt;/div&gt;

        &lt;div className=&quot;mt-6 text-xs text-gray-500 dark:text-gray-400&quot;&gt;
          Error ID: {Date.now()}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Hook for functional components to catch errors
export function useRouteErrorHandler() {
  const router = useRouter();

  const handleRouteError = (error: Error, context?: string) =&gt; {
    console.error(&apos;üö® [ROUTE_ERROR_HANDLER] Route error:&apos;, {
      error: error.message,
      stack: error.stack,
      context,
      currentPath: window.location.pathname,
      timestamp: new Date().toISOString()
    });

    // In production, you might want to send this to an error reporting service
    if (process.env.NODE_ENV === &apos;production&apos;) {
      // Example: sendToErrorReporting(error, context);
    }
  };

  const safeNavigate = (path: string, context?: string) =&gt; {
    try {
      console.log(&apos;üîç [SAFE_NAVIGATE] Navigating to:&apos;, path, { context });
      router.push(path);
    } catch (error) {
      handleRouteError(error as Error, `navigation to ${path}`);
      // Fallback navigation
      window.location.href = path;
    }
  };

  return { handleRouteError, safeNavigate };
}</file><file path="src/components/document/DocumentCard.tsx">import React, { useState } from &apos;react&apos;;
import { Document } from &apos;../../types&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { Card } from &apos;../ui/Card&apos;;
import { Switch } from &apos;../ui/Switch&apos;;
import { useConfirmDialog } from &apos;../common/ConfirmDialog&apos;;
import { useTestModal } from &apos;../ui/TestModal&apos;;
import { useDocumentStore } from &apos;../../store&apos;;
import { formatFileSize } from &apos;../../utils&apos;;
import clsx from &apos;clsx&apos;;

interface DocumentCardProps {
  document: Document;
  onToggle?: (document: Document) =&gt; void;
  className?: string;
}

export const DocumentCard: React.FC&lt;DocumentCardProps&gt; = ({
  document,
  onToggle,
  className,
}) =&gt; {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [deleteError, setDeleteError] = useState&lt;string | null&gt;(null);
  const { deleteDocument, toggleDocumentEnabled } = useDocumentStore();
  const { confirm, ConfirmDialog } = useConfirmDialog();
  const { openModal: openTestModal, closeModal: closeTestModal, TestModal, isOpen: isTestModalOpen } = useTestModal();

  const handleToggle = async (enabled: boolean) =&gt; {
    try {
      await toggleDocumentEnabled(document.id);
      if (onToggle) {
        onToggle({ ...document, enabled });
      }
    } catch (error) {
      console.error(&apos;Failed to toggle document:&apos;, error);
    }
  };

  const handleDelete = async () =&gt; {
    const startTime = Date.now();
    console.log(&apos;üóëÔ∏è DocumentCard: Starting delete process for document:&apos;, {
      id: document.id,
      filename: document.filename,
      status: document.status,
      enabled: document.enabled,
      timestamp: new Date().toISOString()
    });
    
    setDeleteError(null);
    
    console.log(&apos;üîç DocumentCard: About to open delete confirmation dialog&apos;, {
      timestamp: new Date().toISOString()
    });
    
    try {
      console.log(&apos;üîç DocumentCard: Calling confirm with options&apos;, {
        title: &apos;Delete Document&apos;,
        message: `Are you sure you want to delete &quot;${document.filename}&quot;? This action cannot be undone.`,
        timestamp: new Date().toISOString()
      });
      
      const confirmStartTime = Date.now();
      const confirmResult = await confirm({
        title: &apos;Delete Document&apos;,
        message: `Are you sure you want to delete &quot;${document.filename}&quot;? This action cannot be undone.`,
        onConfirm: async () =&gt; {
          console.log(&apos;‚úÖ DocumentCard: User confirmed deletion, starting delete operation&apos;, {
            documentId: document.id,
            timestamp: new Date().toISOString()
          });
          
          try {
            const deleteStartTime = Date.now();
            console.log(&apos;üóëÔ∏è DocumentCard: Calling deleteDocument with ID:&apos;, {
              id: document.id,
              timestamp: new Date().toISOString()
            });
            
            const result = await deleteDocument(document.id);
            const deleteEndTime = Date.now();
            
            console.log(&apos;‚úÖ DocumentCard: deleteDocument completed&apos;, {
              result,
              duration: deleteEndTime - deleteStartTime,
              documentId: document.id,
              filename: document.filename,
              timestamp: new Date().toISOString()
            });
            
            // Return true to indicate successful deletion
            return true;
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : &apos;Failed to delete document&apos;;
            console.error(&apos;‚ùå DocumentCard: Failed to delete document:&apos;, {
              id: document.id,
              filename: document.filename,
              error: error instanceof Error ? error.message : error,
              stack: error instanceof Error ? error.stack : undefined,
              timestamp: new Date().toISOString()
            });
            
            setDeleteError(errorMessage);
            console.error(&apos;Failed to delete document:&apos;, error);
            
            // Return false to indicate failed deletion
            return false;
            // Don&apos;t re-throw the error to allow the dialog to close properly
            // The error state is already set and will be displayed to the user
          }
        },
        confirmText: &apos;Delete&apos;,
        cancelText: &apos;Cancel&apos;,
        variant: &apos;danger&apos;,
      });
      
      const confirmEndTime = Date.now();
      const totalDuration = confirmEndTime - startTime;
      
      console.log(&apos;‚úÖ DocumentCard: Confirmation dialog completed&apos;, {
        confirmResult,
        confirmDuration: confirmEndTime - confirmStartTime,
        totalDuration,
        documentId: document.id,
        timestamp: new Date().toISOString()
      });
      
      // Check if the user confirmed and the deletion was successful
      if (confirmResult) {
        console.log(&apos;‚úÖ DocumentCard: User confirmed and deletion was successful&apos;, {
          documentId: document.id,
          filename: document.filename,
          totalDuration,
          timestamp: new Date().toISOString()
        });
        // Optional: You could add success notification here
      } else {
        console.log(&apos;üîç DocumentCard: User cancelled or deletion failed&apos;, {
          documentId: document.id,
          filename: document.filename,
          totalDuration,
          timestamp: new Date().toISOString()
        });
        // Optional: You could handle the cancellation/failure case here
      }
    } catch (error) {
      const totalDuration = Date.now() - startTime;
      console.error(&apos;‚ùå DocumentCard: Error during confirmation dialog:&apos;, {
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
        documentId: document.id,
        filename: document.filename,
        totalDuration,
        timestamp: new Date().toISOString()
      });
      
      setDeleteError(error instanceof Error ? error.message : &apos;Failed to show confirmation dialog&apos;);
    }
  };

  const handleTestModal = () =&gt; {
    console.log(&apos;üîç DocumentCard: Opening test modal for debugging&apos;);
    openTestModal();
  };

  const getStatusIcon = () =&gt; {
    switch (document.status) {
      case &apos;processing&apos;:
        return (
          &lt;svg className=&quot;w-4 h-4 text-blue-500 animate-spin&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15&quot; /&gt;
          &lt;/svg&gt;
        );
      case &apos;failed&apos;:
        return (
          &lt;svg className=&quot;w-4 h-4 text-red-500&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z&quot; /&gt;
          &lt;/svg&gt;
        );
      default:
        return null; // No icon for completed/pending documents
    }
  };

  const getStatusText = () =&gt; {
    switch (document.status) {
      case &apos;completed&apos;:
        return &apos;Ready&apos;;
      case &apos;processing&apos;:
        return &apos;Processing...&apos;;
      case &apos;failed&apos;:
        return &apos;Failed&apos;;
      default:
        return &apos;Pending&apos;;
    }
  };

  const getStatusColor = () =&gt; {
    switch (document.status) {
      case &apos;completed&apos;:
        return &apos;text-green-600 dark:text-green-400&apos;;
      case &apos;processing&apos;:
        return &apos;text-blue-600 dark:text-blue-400&apos;;
      case &apos;failed&apos;:
        return &apos;text-red-600 dark:text-red-400&apos;;
      default:
        return &apos;text-gray-600 dark:text-gray-400&apos;;
    }
  };

  return (
    &lt;&gt;
      &lt;Card
        className={clsx(
          &apos;transition-all duration-200 hover:shadow-md&apos;,
          !document.enabled &amp;&amp; &apos;opacity-60&apos;,
          className
        )}
      &gt;
        &lt;div className=&quot;p-3 sm:p-4&quot;&gt;
          &lt;div className=&quot;flex items-start justify-between&quot;&gt;
            {/* Document Info */}
            &lt;div className=&quot;flex-1 min-w-0 pr-2 sm:pr-3&quot;&gt;
              &lt;div className=&quot;flex items-center gap-2 mb-2&quot;&gt;
                &lt;h3 className=&quot;font-medium text-sm sm:text-base text-gray-900 dark:text-white break-words&quot;&gt;
                  {document.filename}
                &lt;/h3&gt;
                {getStatusIcon()}
              &lt;/div&gt;
              
              &lt;div className=&quot;flex items-center gap-2 sm:gap-4 text-xs sm:text-sm text-gray-500 dark:text-gray-400&quot;&gt;
                &lt;span&gt;{formatFileSize(document.fileSize)}&lt;/span&gt;
                {document.pageCount &amp;&amp; (
                  &lt;span&gt;{document.pageCount} pages&lt;/span&gt;
                )}
              &lt;/div&gt;
              
              &lt;div className=&quot;flex items-center gap-2 mt-1 text-xs sm:text-sm text-gray-500 dark:text-gray-400&quot;&gt;
                &lt;span className={getStatusColor()}&gt;
                  {getStatusText()}
                &lt;/span&gt;
              &lt;/div&gt;
              
              {document.ingestError &amp;&amp; (
                &lt;div className=&quot;mt-2 p-2 bg-red-50 dark:bg-red-900 border border-red-200 dark:border-red-800 rounded text-xs text-red-600 dark:text-red-400&quot;&gt;
                  {document.ingestError}
                &lt;/div&gt;
              )}
              
              {deleteError &amp;&amp; (
                &lt;div className=&quot;mt-2 p-2 bg-red-50 dark:bg-red-900 border border-red-200 dark:border-red-800 rounded text-xs text-red-600 dark:text-red-400&quot;&gt;
                  Error: {deleteError}
                &lt;/div&gt;
              )}
            &lt;/div&gt;

            {/* Controls */}
            &lt;div className=&quot;flex items-center gap-1 sm:gap-2 flex-shrink-0&quot;&gt;
              {/* Enable/Disable Switch */}
              &lt;Switch
                checked={document.enabled}
                onCheckedChange={handleToggle}
                size=&quot;sm&quot;
              /&gt;
              
              {/* Delete Button */}
              &lt;Button
                variant=&quot;ghost&quot;
                size=&quot;sm&quot;
                onClick={handleDelete}
                className=&quot;p-1 text-red-600 hover:text-red-700 hover:bg-red-50 dark:hover:bg-red-900&quot;
              &gt;
                &lt;svg
                  className=&quot;w-3 h-3 sm:w-4 sm:h-4&quot;
                  fill=&quot;none&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  stroke=&quot;currentColor&quot;
                &gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16&quot;
                  /&gt;
                &lt;/svg&gt;
              &lt;/Button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/Card&gt;

      {(() =&gt; {
        console.log(&apos;üîç DocumentCard: About to render ConfirmDialog&apos;, {
          hasConfirmDialog: !!ConfirmDialog,
          dialogType: typeof ConfirmDialog
        });
        return &lt;ConfirmDialog /&gt;;
      })()}
      
      {/* Test Modal for debugging */}
      {(() =&gt; {
        console.log(&apos;üîç DocumentCard: About to render TestModal&apos;, {
          hasTestModal: !!TestModal,
          isTestModalOpen
        });
        return &lt;TestModal /&gt;;
      })()}
    &lt;/&gt;
  );
};

// Compact version for sidebar
export const DocumentCardCompact: React.FC&lt;{
  document: Document;
  onToggle?: (document: Document) =&gt; void;
  className?: string;
}&gt; = ({ document, onToggle, className }) =&gt; {
  const { toggleDocumentEnabled } = useDocumentStore();

  const handleToggle = async (enabled: boolean) =&gt; {
    try {
      await toggleDocumentEnabled(document.id);
      if (onToggle) {
        onToggle({ ...document, enabled });
      }
    } catch (error) {
      console.error(&apos;Failed to toggle document:&apos;, error);
    }
  };

  const getStatusColor = () =&gt; {
    switch (document.status) {
      case &apos;completed&apos;:
        return &apos;text-green-500&apos;;
      case &apos;processing&apos;:
        return &apos;text-blue-500&apos;;
      case &apos;failed&apos;:
        return &apos;text-red-500&apos;;
      default:
        return &apos;text-gray-500&apos;;
    }
  };

  return (
    &lt;div
      className={clsx(
        &apos;p-2 rounded-lg border border-gray-200 dark:border-gray-700&apos;,
        &apos;hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors duration-200&apos;,
        !document.enabled &amp;&amp; &apos;opacity-60&apos;,
        className
      )}
    &gt;
      &lt;div className=&quot;flex items-center justify-between&quot;&gt;
        &lt;div className=&quot;flex-1 min-w-0 pr-2&quot;&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;div className={clsx(&apos;w-2 h-2 rounded-full&apos;, getStatusColor())} /&gt;
            &lt;h4 className=&quot;font-medium text-xs sm:text-sm text-gray-900 dark:text-white break-words&quot;&gt;
              {document.filename}
            &lt;/h4&gt;
          &lt;/div&gt;
          &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400 mt-1&quot;&gt;
            {formatFileSize(document.fileSize)}
          &lt;/p&gt;
        &lt;/div&gt;
        
        &lt;Switch
          checked={document.enabled}
          onCheckedChange={handleToggle}
          size=&quot;sm&quot;
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/document/DocumentList.tsx">import React, { useState, useMemo } from &apos;react&apos;;
import { Document } from &apos;../../types&apos;;
import { DocumentCard, DocumentCardCompact } from &apos;./DocumentCard&apos;;
import { EmptyState } from &apos;../common/EmptyState&apos;;
import { Input } from &apos;../ui/Input&apos;;
import { Button } from &apos;../ui/Button&apos;;
import clsx from &apos;clsx&apos;;

interface DocumentListProps {
  documents: Document[];
  loading?: boolean;
  onDocumentToggle?: (document: Document) =&gt; void;
  variant?: &apos;grid&apos; | &apos;list&apos; | &apos;compact&apos;;
  showSearch?: boolean;
  className?: string;
}

export const DocumentList: React.FC&lt;DocumentListProps&gt; = ({
  documents,
  loading = false,
  onDocumentToggle,
  variant = &apos;grid&apos;,
  showSearch = true,
  className,
}) =&gt; {
  const [searchQuery, setSearchQuery] = useState(&apos;&apos;);

  // Filter documents
  const filteredDocuments = useMemo(() =&gt; {
    if (searchQuery) {
      return documents.filter(doc =&gt;
        doc.filename.toLowerCase().includes(searchQuery.toLowerCase()) ||
        doc.title?.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }
    return documents;
  }, [documents, searchQuery]);

  if (loading) {
    return (
      &lt;div className={clsx(&apos;space-y-4&apos;, className)}&gt;
        {Array.from({ length: 3 }).map((_, index) =&gt; (
          &lt;div key={index} className=&quot;animate-pulse&quot;&gt;
            &lt;div className=&quot;bg-gray-200 dark:bg-gray-700 rounded-lg h-24&quot; /&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    );
  }

  if (documents.length === 0) {
    return (
      &lt;EmptyState
        title=&quot;No documents uploaded&quot;
        description=&quot;Upload documents to start asking questions about their content&quot;
        icon={
          &lt;svg
            fill=&quot;none&quot;
            viewBox=&quot;0 0 24 24&quot;
            stroke=&quot;currentColor&quot;
          &gt;
            &lt;path
              strokeLinecap=&quot;round&quot;
              strokeLinejoin=&quot;round&quot;
              strokeWidth={2}
              d=&quot;M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z&quot;
            /&gt;
          &lt;/svg&gt;
        }
        className={className}
      /&gt;
    );
  }

  if (filteredDocuments.length === 0) {
    return (
      &lt;EmptyState
        title=&quot;No documents found&quot;
        description=&quot;Try adjusting your search or filter criteria&quot;
        icon={
          &lt;svg
            className=&quot;w-12 h-12 text-gray-400&quot;
            fill=&quot;none&quot;
            viewBox=&quot;0 0 24 24&quot;
            stroke=&quot;currentColor&quot;
          &gt;
            &lt;path
              strokeLinecap=&quot;round&quot;
              strokeLinejoin=&quot;round&quot;
              strokeWidth={2}
              d=&quot;M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z&quot;
            /&gt;
          &lt;/svg&gt;
        }
        className={className}
      /&gt;
    );
  }

  // Compact variant for sidebar
  if (variant === &apos;compact&apos;) {
    return (
      &lt;div className={clsx(&apos;space-y-1 sm:space-y-2&apos;, className)}&gt;
        {filteredDocuments.map((document) =&gt; (
          &lt;DocumentCardCompact
            key={document.id}
            document={document}
            onToggle={onDocumentToggle}
          /&gt;
        ))}
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className={clsx(&apos;space-y-3 sm:space-y-4&apos;, className)}&gt;
      {/* Search */}
      {showSearch &amp;&amp; (
        &lt;div className=&quot;w-full&quot;&gt;
          &lt;Input
            type=&quot;text&quot;
            placeholder=&quot;Search documents...&quot;
            value={searchQuery}
            onChange={(e) =&gt; setSearchQuery(e.target.value)}
            leftIcon={
              &lt;svg
                className=&quot;w-4 h-4&quot;
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z&quot;
                /&gt;
              &lt;/svg&gt;
            }
          /&gt;
        &lt;/div&gt;
      )}

      {/* Document Count */}
      &lt;div className=&quot;text-xs sm:text-sm text-gray-500 dark:text-gray-400&quot;&gt;
        {filteredDocuments.length} document{filteredDocuments.length !== 1 ? &apos;s&apos; : &apos;&apos;}
        {searchQuery &amp;&amp; ` found for &quot;${searchQuery}&quot;`}
      &lt;/div&gt;

      {/* Document Grid/List */}
      {variant === &apos;grid&apos; ? (
        &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4&quot;&gt;
          {filteredDocuments.map((document) =&gt; (
            &lt;DocumentCard
              key={document.id}
              document={document}
              onToggle={onDocumentToggle}
            /&gt;
          ))}
        &lt;/div&gt;
      ) : (
        &lt;div className=&quot;space-y-3 sm:space-y-4&quot;&gt;
          {filteredDocuments.map((document) =&gt; (
            &lt;DocumentCard
              key={document.id}
              document={document}
              onToggle={onDocumentToggle}
            /&gt;
          ))}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

// Sidebar version with minimal controls
export const DocumentListSidebar: React.FC&lt;{
  documents: Document[];
  onDocumentToggle?: (document: Document) =&gt; void;
  className?: string;
}&gt; = ({ documents, onDocumentToggle, className }) =&gt; {
  return (
    &lt;DocumentList
      documents={documents}
      variant=&quot;compact&quot;
      showSearch={false}
      onDocumentToggle={onDocumentToggle}
      className={className}
    /&gt;
  );
};</file><file path="src/components/document/DocumentProgress.tsx">import React from &apos;react&apos;;
import { DocumentProgress as DocumentProgressType } from &apos;../../types&apos;;
import { Card } from &apos;../ui/Card&apos;;
import { Loading } from &apos;../ui/Loading&apos;;
import clsx from &apos;clsx&apos;;

interface DocumentProgressProps {
  progress: DocumentProgressType;
  filename: string;
  fileSize?: number;
  className?: string;
}

export const DocumentProgress: React.FC&lt;DocumentProgressProps&gt; = ({
  progress,
  filename,
  fileSize,
  className,
}) =&gt; {
  const getStatusIcon = () =&gt; {
    switch (progress.status) {
      case &apos;pending&apos;:
        return (
          &lt;svg className=&quot;w-5 h-5 text-gray-400&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z&quot; /&gt;
          &lt;/svg&gt;
        );
      case &apos;processing&apos;:
        return &lt;Loading size=&quot;sm&quot; /&gt;;
      case &apos;completed&apos;:
        return (
          &lt;svg className=&quot;w-5 h-5 text-green-500&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z&quot; /&gt;
          &lt;/svg&gt;
        );
      case &apos;failed&apos;:
        return (
          &lt;svg className=&quot;w-5 h-5 text-red-500&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z&quot; /&gt;
          &lt;/svg&gt;
        );
      default:
        return null;
    }
  };

  const getStatusText = () =&gt; {
    switch (progress.status) {
      case &apos;pending&apos;:
        return &apos;Waiting to process...&apos;;
      case &apos;processing&apos;:
        return &apos;Processing...&apos;;
      case &apos;completed&apos;:
        return &apos;Completed&apos;;
      case &apos;failed&apos;:
        return &apos;Failed&apos;;
      default:
        return &apos;Unknown&apos;;
    }
  };

  const getStatusColor = () =&gt; {
    switch (progress.status) {
      case &apos;pending&apos;:
        return &apos;text-gray-600 dark:text-gray-400&apos;;
      case &apos;processing&apos;:
        return &apos;text-blue-600 dark:text-blue-400&apos;;
      case &apos;completed&apos;:
        return &apos;text-green-600 dark:text-green-400&apos;;
      case &apos;failed&apos;:
        return &apos;text-red-600 dark:text-red-400&apos;;
      default:
        return &apos;text-gray-600 dark:text-gray-400&apos;;
    }
  };

  const getProgressColor = () =&gt; {
    switch (progress.status) {
      case &apos;processing&apos;:
        return &apos;bg-blue-500&apos;;
      case &apos;completed&apos;:
        return &apos;bg-green-500&apos;;
      case &apos;failed&apos;:
        return &apos;bg-red-500&apos;;
      default:
        return &apos;bg-gray-300 dark:bg-gray-600&apos;;
    }
  };

  return (
    &lt;Card className={clsx(&apos;p-4&apos;, className)}&gt;
      &lt;div className=&quot;flex items-start gap-3&quot;&gt;
        {/* Status Icon */}
        &lt;div className=&quot;flex-shrink-0 mt-1&quot;&gt;
          {getStatusIcon()}
        &lt;/div&gt;

        {/* Content */}
        &lt;div className=&quot;flex-1 min-w-0&quot;&gt;
          {/* Filename */}
          &lt;h4 className=&quot;font-medium text-gray-900 dark:text-white truncate&quot;&gt;
            {filename}
          &lt;/h4&gt;

          {/* File size */}
          {fileSize &amp;&amp; (
            &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;
              {formatFileSize(fileSize)}
            &lt;/p&gt;
          )}

          {/* Status and Progress */}
          &lt;div className=&quot;mt-2 space-y-2&quot;&gt;
            {/* Status Text */}
            &lt;p className={clsx(&apos;text-sm font-medium&apos;, getStatusColor())}&gt;
              {getStatusText()}
            &lt;/p&gt;

            {/* Progress Bar */}
            {(progress.status === &apos;processing&apos; || progress.status === &apos;completed&apos;) &amp;&amp; (
              &lt;div className=&quot;w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2&quot;&gt;
                &lt;div
                  className={clsx(&apos;h-2 rounded-full transition-all duration-300&apos;, getProgressColor())}
                  style={{ width: `${progress.progress}%` }}
                /&gt;
              &lt;/div&gt;
            )}

            {/* Progress Percentage */}
            {(progress.status === &apos;processing&apos; || progress.status === &apos;completed&apos;) &amp;&amp; (
              &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&gt;
                {Math.round(progress.progress)}% complete
              &lt;/p&gt;
            )}

            {/* Error Message */}
            {progress.status === &apos;failed&apos; &amp;&amp; progress.error &amp;&amp; (
              &lt;div className=&quot;mt-2 p-2 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded text-xs text-red-600 dark:text-red-400&quot;&gt;
                {progress.error}
              &lt;/div&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/Card&gt;
  );
};

// Helper function to format file size (imported from utils)
const formatFileSize = (bytes: number): string =&gt; {
  if (bytes === 0) return &apos;0 Bytes&apos;;

  const k = 1024;
  const sizes = [&apos;Bytes&apos;, &apos;KB&apos;, &apos;MB&apos;, &apos;GB&apos;, &apos;TB&apos;];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &apos; &apos; + sizes[i];
};

// Compact version for inline display
export const DocumentProgressCompact: React.FC&lt;{
  progress: DocumentProgressType;
  filename: string;
  className?: string;
}&gt; = ({ progress, filename, className }) =&gt; {
  const getStatusColor = () =&gt; {
    switch (progress.status) {
      case &apos;pending&apos;:
        return &apos;text-gray-500&apos;;
      case &apos;processing&apos;:
        return &apos;text-blue-500&apos;;
      case &apos;completed&apos;:
        return &apos;text-green-500&apos;;
      case &apos;failed&apos;:
        return &apos;text-red-500&apos;;
      default:
        return &apos;text-gray-500&apos;;
    }
  };

  const getProgressColor = () =&gt; {
    switch (progress.status) {
      case &apos;processing&apos;:
        return &apos;bg-blue-500&apos;;
      case &apos;completed&apos;:
        return &apos;bg-green-500&apos;;
      case &apos;failed&apos;:
        return &apos;bg-red-500&apos;;
      default:
        return &apos;bg-gray-300 dark:bg-gray-600&apos;;
    }
  };

  return (
    &lt;div className={clsx(&apos;flex items-center gap-2 p-2&apos;, className)}&gt;
      {/* Status Indicator */}
      &lt;div className={clsx(&apos;w-2 h-2 rounded-full&apos;, getStatusColor())} /&gt;

      {/* Filename */}
      &lt;div className=&quot;flex-1 min-w-0&quot;&gt;
        &lt;p className=&quot;text-sm font-medium text-gray-900 dark:text-white truncate&quot;&gt;
          {filename}
        &lt;/p&gt;
        
        {/* Progress Bar for processing/completed */}
        {(progress.status === &apos;processing&apos; || progress.status === &apos;completed&apos;) &amp;&amp; (
          &lt;div className=&quot;mt-1 w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1&quot;&gt;
            &lt;div
              className={clsx(&apos;h-1 rounded-full transition-all duration-300&apos;, getProgressColor())}
              style={{ width: `${progress.progress}%` }}
            /&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      {/* Progress Percentage */}
      {(progress.status === &apos;processing&apos; || progress.status === &apos;completed&apos;) &amp;&amp; (
        &lt;span className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&gt;
          {Math.round(progress.progress)}%
        &lt;/span&gt;
      )}
    &lt;/div&gt;
  );
};</file><file path="src/components/document/DocumentUpload.tsx">import React, { useState, useRef, useCallback } from &apos;react&apos;;
import { useDocumentStore } from &apos;../../store&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { Card } from &apos;../ui/Card&apos;;
import { isSupportedDocumentType, isFileSizeValid, formatFileSize } from &apos;../../utils&apos;;
import clsx from &apos;clsx&apos;;

interface DocumentUploadProps {
  sessionId: string;
  onUploadStart?: (files: File[]) =&gt; void;
  onUploadComplete?: (documents: any[]) =&gt; void;
  onUploadError?: (error: Error) =&gt; void;
  className?: string;
  maxFiles?: number;
  maxSizeMB?: number;
  trigger?: React.ReactNode;
}

export const DocumentUpload: React.FC&lt;DocumentUploadProps&gt; = ({
  sessionId,
  onUploadStart,
  onUploadComplete,
  onUploadError,
  className,
  maxFiles = 10,
  maxSizeMB = 50,
  trigger,
}) =&gt; {
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState&lt;Record&lt;string, number&gt;&gt;({});
  const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);
  const { uploadDocuments } = useDocumentStore();

  const handleFiles = useCallback(async (files: FileList) =&gt; {
    if (files.length === 0) return;

    // Validate files
    const validFiles = Array.from(files).filter(file =&gt; {
      if (!isSupportedDocumentType(file.name)) {
        alert(`File &quot;${file.name}&quot; is not a supported document type. Supported types: PDF, TXT, DOC, DOCX, RTF`);
        return false;
      }

      if (!isFileSizeValid(file.size, maxSizeMB)) {
        alert(`File &quot;${file.name}&quot; exceeds the maximum size limit of ${maxSizeMB}MB`);
        return false;
      }

      return true;
    });

    if (validFiles.length === 0) return;

    if (validFiles.length &gt; maxFiles) {
      alert(`You can only upload ${maxFiles} files at a time`);
      return;
    }

    setIsUploading(true);
    setUploadProgress({});
    
    try {
      onUploadStart?.(validFiles);

      const uploadPromises = validFiles.map(async (file) =&gt; {
        try {
          // Initialize progress
          setUploadProgress(prev =&gt; ({ ...prev, [file.name]: 0 }));

          // Upload document
          // Progress tracking will be handled by the store
          await uploadDocuments(sessionId, [file]);

          // Complete progress
          setUploadProgress(prev =&gt; ({ ...prev, [file.name]: 100 }));
        } catch (error) {
          console.error(`Failed to upload ${file.name}:`, error);
          throw error;
        }
      });

      await Promise.allSettled(uploadPromises);
      
      // Reload documents to get updated list
      onUploadComplete?.([]);
    } catch (error) {
      console.error(&apos;Upload failed:&apos;, error);
      onUploadError?.(error as Error);
    } finally {
      setIsUploading(false);
      setUploadProgress({});
    }
  }, [sessionId, maxFiles, maxSizeMB, uploadDocuments, onUploadStart, onUploadComplete, onUploadError]);

  const handleDragOver = useCallback((e: React.DragEvent) =&gt; {
    e.preventDefault();
    setIsDragging(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) =&gt; {
    e.preventDefault();
    setIsDragging(false);
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) =&gt; {
    e.preventDefault();
    setIsDragging(false);
    handleFiles(e.dataTransfer.files);
  }, [handleFiles]);

  const handleFileSelect = useCallback((e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    if (e.target.files) {
      handleFiles(e.target.files);
    }
  }, [handleFiles]);

  const openFileDialog = useCallback(() =&gt; {
    fileInputRef.current?.click();
  }, []);

  const overallProgress = Object.values(uploadProgress).length &gt; 0
    ? Object.values(uploadProgress).reduce((sum, progress) =&gt; sum + progress, 0) / Object.values(uploadProgress).length
    : 0;

  return (
    &lt;Card className={clsx(&apos;border-2 border-dashed&apos;, className)}&gt;
      &lt;div
        className={clsx(
          &apos;p-4 sm:p-6 lg:p-8 text-center transition-colors duration-200 touch-manipulation&apos;,
          isDragging ? &apos;bg-blue-50 dark:bg-blue-900/20 border-blue-400&apos; : &apos;border-gray-300 dark:border-gray-600&apos;
        )}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
      &gt;
        &lt;input
          ref={fileInputRef}
          type=&quot;file&quot;
          multiple
          accept=&quot;.pdf,.txt,.doc,.docx,.rtf&quot;
          onChange={handleFileSelect}
          className=&quot;hidden&quot;
          disabled={isUploading}
        /&gt;

        {!isUploading ? (
          &lt;&gt;
            &lt;div className=&quot;mx-auto w-10 h-10 sm:w-12 sm:h-12 text-gray-400 mb-3 sm:mb-4&quot;&gt;
              &lt;svg
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12&quot;
                /&gt;
              &lt;/svg&gt;
            &lt;/div&gt;
            
            &lt;h3 className=&quot;text-base sm:text-lg font-medium text-gray-900 dark:text-white mb-2&quot;&gt;
              Upload Documents
            &lt;/h3&gt;
            
            &lt;p className=&quot;text-sm sm:text-base text-gray-600 dark:text-gray-300 mb-3 sm:mb-4&quot;&gt;
              Drag and drop files here, or click to select files
            &lt;/p&gt;
            
            &lt;div className=&quot;text-xs sm:text-sm text-gray-500 dark:text-gray-400 mb-3 sm:mb-4&quot;&gt;
              &lt;p&gt;Supported formats: PDF, TXT, DOC, DOCX, RTF&lt;/p&gt;
              &lt;p&gt;Maximum file size: {maxSizeMB}MB&lt;/p&gt;
              &lt;p&gt;Maximum files: {maxFiles}&lt;/p&gt;
            &lt;/div&gt;
            
            {trigger || (
              &lt;Button onClick={openFileDialog} disabled={isUploading} className=&quot;w-full sm:w-auto&quot;&gt;
                Select Files
              &lt;/Button&gt;
            )}
          &lt;/&gt;
        ) : (
          &lt;div className=&quot;space-y-3 sm:space-y-4&quot;&gt;
            &lt;div className=&quot;mx-auto w-10 h-10 sm:w-12 sm:h-12 text-blue-500 animate-spin&quot;&gt;
              &lt;svg
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15&quot;
                /&gt;
              &lt;/svg&gt;
            &lt;/div&gt;
            
            &lt;h3 className=&quot;text-base sm:text-lg font-medium text-gray-900 dark:text-white&quot;&gt;
              Uploading Documents...
            &lt;/h3&gt;
            
            {/* Overall Progress */}
            &lt;div className=&quot;w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2&quot;&gt;
              &lt;div
                className=&quot;bg-blue-500 h-2 rounded-full transition-all duration-300&quot;
                style={{ width: `${overallProgress}%` }}
              /&gt;
            &lt;/div&gt;
            
            &lt;p className=&quot;text-xs sm:text-sm text-gray-600 dark:text-gray-300&quot;&gt;
              {Math.round(overallProgress)}% complete
            &lt;/p&gt;
            
            {/* Individual File Progress */}
            {Object.entries(uploadProgress).map(([filename, progress]) =&gt; (
              &lt;div key={filename} className=&quot;text-left space-y-1&quot;&gt;
                &lt;div className=&quot;flex justify-between text-xs sm:text-sm&quot;&gt;
                  &lt;span className=&quot;text-gray-600 dark:text-gray-300 truncate&quot;&gt;
                    {filename}
                  &lt;/span&gt;
                  &lt;span className=&quot;text-gray-500 dark:text-gray-400&quot;&gt;
                    {Math.round(progress)}%
                  &lt;/span&gt;
                &lt;/div&gt;
                &lt;div className=&quot;w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1&quot;&gt;
                  &lt;div
                    className=&quot;bg-blue-500 h-1 rounded-full transition-all duration-300&quot;
                    style={{ width: `${progress}%` }}
                  /&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    &lt;/Card&gt;
  );
};

// Compact version for inline use
export const DocumentUploadCompact: React.FC&lt;{
  sessionId: string;
  onUploadComplete?: (documents: any[]) =&gt; void;
  className?: string;
}&gt; = ({ sessionId, onUploadComplete, className }) =&gt; {
  const [isUploading, setIsUploading] = useState(false);
  const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);
  const { uploadDocuments } = useDocumentStore();

  const handleFileSelect = async (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    if (!e.target.files || e.target.files.length === 0) return;

    setIsUploading(true);
    
    try {
      const file = e.target.files[0];
      await uploadDocuments(sessionId, [file]);
      onUploadComplete?.([]);
    } catch (error) {
      console.error(&apos;Upload failed:&apos;, error);
    } finally {
      setIsUploading(false);
    }
  };

  return (
    &lt;div className={clsx(&apos;flex items-center gap-2&apos;, className)}&gt;
      &lt;input
        ref={fileInputRef}
        type=&quot;file&quot;
        accept=&quot;.pdf,.txt,.doc,.docx,.rtf&quot;
        onChange={handleFileSelect}
        className=&quot;hidden&quot;
        disabled={isUploading}
      /&gt;
      
      &lt;Button
        variant=&quot;outline&quot;
        size=&quot;sm&quot;
        onClick={() =&gt; fileInputRef.current?.click()}
        disabled={isUploading}
        loading={isUploading}
        className=&quot;flex-1 sm:flex-none&quot;
      &gt;
        {isUploading ? &apos;Uploading...&apos; : &apos;Add Document&apos;}
      &lt;/Button&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/document/JsonUpload.tsx">import React, { useState, useRef, useCallback } from &apos;react&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { Card } from &apos;../ui/Card&apos;;
import { documentProcessor } from &apos;../../services/rag&apos;;
import { useDocumentStore } from &apos;../../store&apos;;
import type { PreprocessedPackage } from &apos;../../types/preprocessed&apos;;
import clsx from &apos;clsx&apos;;

interface JsonUploadProps {
  sessionId: string;
  onUploadStart?: () =&gt; void;
  onUploadComplete?: (result: { documentCount: number; chunkCount: number }) =&gt; void;
  onUploadError?: (error: Error) =&gt; void;
  className?: string;
}

export const JsonUpload: React.FC&lt;JsonUploadProps&gt; = ({
  sessionId,
  onUploadStart,
  onUploadComplete,
  onUploadError,
  className,
}) =&gt; {
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);

  const validateJsonStructure = (data: any): data is PreprocessedPackage =&gt; {
    try {
      // Check required fields
      if (!data.format_version || !data.export_metadata || !data.document_metadata || !data.chunks) {
        return false;
      }

      // Check chunks structure
      if (!Array.isArray(data.chunks)) {
        return false;
      }

      // Validate each chunk
      for (const chunk of data.chunks) {
        if (!chunk.id || !chunk.text || !Array.isArray(chunk.embedding)) {
          return false;
        }
      }

      return true;
    } catch (error) {
      return false;
    }
  };

  const handleFile = useCallback(async (file: File) =&gt; {
    console.log(&apos;üöÄ JSON Upload: Starting file upload process&apos;);
    console.log(&apos;üìÅ File details:&apos;, {
      name: file.name,
      size: file.size,
      type: file.type,
      lastModified: new Date(file.lastModified)
    });

    if (!file.name.endsWith(&apos;.json&apos;)) {
      const errorMsg = &apos;Please upload a JSON file with preprocessed document data&apos;;
      console.error(&apos;‚ùå JSON Upload: Invalid file type - not a JSON file&apos;);
      alert(errorMsg);
      return;
    }

    setIsUploading(true);
    setUploadProgress(0);
    
    try {
      console.log(&apos;‚úÖ JSON Upload: File validation passed, starting upload&apos;);
      onUploadStart?.();

      // Read and parse JSON file
      console.log(&apos;üìñ JSON Upload: Reading file content...&apos;);
      setUploadProgress(20);
      const fileContent = await file.text();
      console.log(&apos;üìä JSON Upload: File content length:&apos;, fileContent.length, &apos;characters&apos;);
      
      console.log(&apos;üîÑ JSON Upload: Parsing JSON...&apos;);
      let jsonData: PreprocessedPackage;
      try {
        jsonData = JSON.parse(fileContent);
        console.log(&apos;‚úÖ JSON Upload: JSON parsed successfully&apos;);
        console.log(&apos;üìã JSON Upload: Structure check:&apos;, {
          hasFormatVersion: !!jsonData.format_version,
          hasExportMetadata: !!jsonData.export_metadata,
          hasDocumentMetadata: !!jsonData.document_metadata,
          hasChunks: !!jsonData.chunks,
          chunksCount: jsonData.chunks?.length || 0
        });
      } catch (parseError) {
        console.error(&apos;‚ùå JSON Upload: JSON parse failed:&apos;, parseError);
        throw new Error(`Invalid JSON format: ${parseError instanceof Error ? parseError.message : &apos;Unknown parse error&apos;}`);
      }

      // Validate structure
      console.log(&apos;üîç JSON Upload: Validating JSON structure...&apos;);
      setUploadProgress(40);
      if (!validateJsonStructure(jsonData)) {
        console.error(&apos;‚ùå JSON Upload: Structure validation failed&apos;);
        console.log(&apos;üîç JSON Upload: Actual structure received:&apos;, jsonData);
        throw new Error(&apos;Invalid JSON structure. Please ensure the file follows the preprocessed document format with format_version, export_metadata, document_metadata, and chunks array.&apos;);
      }
      console.log(&apos;‚úÖ JSON Upload: Structure validation passed&apos;);

      // Process the package
      console.log(&apos;‚öôÔ∏è JSON Upload: Starting document processing...&apos;);
      setUploadProgress(60);
      
      // Get userId from documentStore
      const { userId } = useDocumentStore.getState();
      if (!userId) {
        throw new Error(&apos;User ID not found. Please log in again.&apos;);
      }
      console.log(&apos;üîç JSON Upload: Retrieved userId from documentStore:&apos;, userId);
      
      await documentProcessor.processPreprocessedPackage(
        sessionId,
        jsonData,
        userId,
        (progress) =&gt; {
          const percentage = (progress.processedChunks / progress.totalChunks) * 40;
          setUploadProgress(60 + percentage);
          console.log(`üìà JSON Upload: Processing progress: ${progress.processedChunks}/${progress.totalChunks} chunks (${Math.round(60 + percentage)}%)`);
        }
      );

      console.log(&apos;‚úÖ JSON Upload: Document processing completed&apos;);
      setUploadProgress(100);
      
      // Refresh the document store to show the newly processed document
      console.log(&apos;üîÑ JSON Upload: Refreshing document store...&apos;);
      console.log(&apos;üîç RACE CONDITION DEBUG: About to call loadDocuments&apos;);
      
      const { loadDocuments } = useDocumentStore.getState();
      console.log(&apos;üîç RACE CONDITION DEBUG: loadDocuments function obtained&apos;);
      
      // Add a small delay to ensure all database operations have committed
      await new Promise(resolve =&gt; setTimeout(resolve, 100));
      console.log(&apos;üîç RACE CONDITION DEBUG: Delay completed, calling loadDocuments&apos;);
      
      await loadDocuments(sessionId);
      console.log(&apos;üîç RACE CONDITION DEBUG: loadDocuments completed&apos;);
      
      // Check what documents are now in the store
      const currentDocuments = useDocumentStore.getState().documents;
      console.log(&apos;üîç RACE CONDITION DEBUG: Documents in store after refresh:&apos;, {
        count: currentDocuments.length,
        documents: currentDocuments.map(doc =&gt; ({
          id: doc.id,
          filename: doc.filename,
          status: doc.status,
          enabled: doc.enabled
        }))
      });
      
      console.log(&apos;‚úÖ JSON Upload: Document store refreshed&apos;);
      
      onUploadComplete?.({
        documentCount: 1,
        chunkCount: jsonData.chunks.length,
      });
      console.log(&apos;üéâ JSON Upload: Upload process completed successfully&apos;);
    } catch (error) {
      console.error(&apos;üí• JSON Upload: Upload failed with error:&apos;, error);
      console.error(&apos;üí• JSON Upload: Error details:&apos;, {
        name: error instanceof Error ? error.name : &apos;Unknown&apos;,
        message: error instanceof Error ? error.message : &apos;Unknown error&apos;,
        stack: error instanceof Error ? error.stack : &apos;No stack trace&apos;
      });
      onUploadError?.(error as Error);
    } finally {
      console.log(&apos;üèÅ JSON Upload: Cleaning up upload state&apos;);
      setIsUploading(false);
      setUploadProgress(0);
    }
  }, [sessionId, onUploadStart, onUploadComplete, onUploadError]);

  const handleDrop = useCallback((e: React.DragEvent) =&gt; {
    e.preventDefault();
    setIsDragging(false);
    
    const files = Array.from(e.dataTransfer.files);
    if (files.length &gt; 0) {
      handleFile(files[0]);
    }
  }, [handleFile]);

  const handleDragOver = useCallback((e: React.DragEvent) =&gt; {
    e.preventDefault();
    setIsDragging(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) =&gt; {
    e.preventDefault();
    setIsDragging(false);
  }, []);

  const handleFileSelect = useCallback((e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    if (e.target.files &amp;&amp; e.target.files.length &gt; 0) {
      handleFile(e.target.files[0]);
    }
  }, [handleFile]);

  const openFileDialog = useCallback(() =&gt; {
    fileInputRef.current?.click();
  }, []);

  return (
    &lt;Card className={clsx(&apos;border-2 border-dashed&apos;, className)}&gt;
      &lt;div
        className={clsx(
          &apos;p-8 text-center transition-colors duration-200&apos;,
          isDragging ? &apos;bg-blue-50 dark:bg-blue-900/20 border-blue-400&apos; : &apos;border-gray-300 dark:border-gray-600&apos;
        )}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
      &gt;
        &lt;input
          ref={fileInputRef}
          type=&quot;file&quot;
          accept=&quot;.json&quot;
          onChange={handleFileSelect}
          className=&quot;hidden&quot;
          disabled={isUploading}
        /&gt;

        {!isUploading ? (
          &lt;&gt;
            &lt;div className=&quot;mx-auto w-12 h-12 text-gray-400 mb-4&quot;&gt;
              &lt;svg
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12&quot;
                /&gt;
              &lt;/svg&gt;
            &lt;/div&gt;
            
            &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white mb-2&quot;&gt;
              Upload Preprocessed Document
            &lt;/h3&gt;
            
            &lt;p className=&quot;text-gray-600 dark:text-gray-300 mb-4&quot;&gt;
              Drag and drop a JSON file here, or click to select a file
            &lt;/p&gt;
            
            &lt;div className=&quot;text-sm text-gray-500 dark:text-gray-400 mb-4&quot;&gt;
              &lt;p&gt;Format: Preprocessed JSON document&lt;/p&gt;
              &lt;p&gt;The app no longer processes PDFs directly&lt;/p&gt;
            &lt;/div&gt;
            
            &lt;Button onClick={openFileDialog} disabled={isUploading}&gt;
              Select JSON File
            &lt;/Button&gt;
          &lt;/&gt;
        ) : (
          &lt;div className=&quot;space-y-4&quot;&gt;
            &lt;div className=&quot;mx-auto w-12 h-12 text-blue-500 animate-spin&quot;&gt;
              &lt;svg
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15&quot;
                /&gt;
              &lt;/svg&gt;
            &lt;/div&gt;
            
            &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;
              Processing Document...
            &lt;/h3&gt;
            
            &lt;div className=&quot;w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2&quot;&gt;
              &lt;div
                className=&quot;bg-blue-500 h-2 rounded-full transition-all duration-300&quot;
                style={{ width: `${uploadProgress}%` }}
              /&gt;
            &lt;/div&gt;
            
            &lt;p className=&quot;text-sm text-gray-600 dark:text-gray-300&quot;&gt;
              {Math.round(uploadProgress)}% complete
            &lt;/p&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    &lt;/Card&gt;
  );
};

// Compact version for inline use
export const JsonUploadCompact: React.FC&lt;{
  sessionId: string;
  onUploadComplete?: (result: { documentCount: number; chunkCount: number }) =&gt; void;
  className?: string;
}&gt; = ({ sessionId, onUploadComplete, className }) =&gt; {
  const [isUploading, setIsUploading] = useState(false);
  const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);

  const handleFileSelect = async (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    console.log(&apos;üöÄ JsonUploadCompact: Starting file upload process&apos;);
    
    if (!e.target.files || e.target.files.length === 0) {
      console.log(&apos;‚ö†Ô∏è JsonUploadCompact: No files selected&apos;);
      return;
    }

    setIsUploading(true);
    
    try {
      const file = e.target.files[0];
      console.log(&apos;üìÅ JsonUploadCompact: File details:&apos;, {
        name: file.name,
        size: file.size,
        type: file.type
      });
      
      console.log(&apos;üìñ JsonUploadCompact: Reading file content...&apos;);
      const fileContent = await file.text();
      console.log(&apos;üìä JsonUploadCompact: File content length:&apos;, fileContent.length, &apos;characters&apos;);
      
      console.log(&apos;üîÑ JsonUploadCompact: Parsing JSON...&apos;);
      const jsonData: PreprocessedPackage = JSON.parse(fileContent);
      console.log(&apos;‚úÖ JsonUploadCompact: JSON parsed successfully&apos;);
      
      console.log(&apos;‚öôÔ∏è JsonUploadCompact: Processing document...&apos;);
      
      // Get userId from documentStore
      const { userId } = useDocumentStore.getState();
      if (!userId) {
        throw new Error(&apos;User ID not found. Please log in again.&apos;);
      }
      console.log(&apos;üîç JsonUploadCompact: Retrieved userId from documentStore:&apos;, userId);
      
      await documentProcessor.processPreprocessedPackage(sessionId, jsonData, userId);
      console.log(&apos;‚úÖ JsonUploadCompact: Document processing completed&apos;);
      
      // Refresh the document store to show the newly processed document
      console.log(&apos;üîÑ JsonUploadCompact: Refreshing document store...&apos;);
      const { loadDocuments } = useDocumentStore.getState();
      await loadDocuments(sessionId);
      console.log(&apos;‚úÖ JsonUploadCompact: Document store refreshed&apos;);
      
      onUploadComplete?.({
        documentCount: 1,
        chunkCount: jsonData.chunks.length,
      });
      console.log(&apos;üéâ JsonUploadCompact: Upload completed successfully&apos;);
    } catch (error) {
      console.error(&apos;üí• JsonUploadCompact: Upload failed:&apos;, error);
      console.error(&apos;üí• JsonUploadCompact: Error details:&apos;, {
        name: error instanceof Error ? error.name : &apos;Unknown&apos;,
        message: error instanceof Error ? error.message : &apos;Unknown error&apos;,
        stack: error instanceof Error ? error.stack : &apos;No stack trace&apos;
      });
      alert(`Failed to process JSON file: ${error instanceof Error ? error.message : &apos;Unknown error&apos;}. Please check the file format.`);
    } finally {
      console.log(&apos;üèÅ JsonUploadCompact: Cleaning up upload state&apos;);
      setIsUploading(false);
    }
  };

  return (
    &lt;div className={clsx(&apos;flex items-center gap-2&apos;, className)}&gt;
      &lt;input
        ref={fileInputRef}
        type=&quot;file&quot;
        accept=&quot;.json&quot;
        onChange={handleFileSelect}
        className=&quot;hidden&quot;
        disabled={isUploading}
      /&gt;
      
      &lt;Button
        variant=&quot;outline&quot;
        size=&quot;sm&quot;
        onClick={() =&gt; fileInputRef.current?.click()}
        disabled={isUploading}
      &gt;
        {isUploading ? &apos;Processing...&apos; : &apos;Add JSON Document&apos;}
      &lt;/Button&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/layout/Sidebar.tsx">import React from &apos;react&apos;;
import Link from &apos;next/link&apos;;
import { useRouter } from &apos;next/router&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { useSessions } from &apos;../../store&apos;;
import { getRelativeTime } from &apos;../../utils/date&apos;;

interface SidebarProps {
  isOpen: boolean;
  onClose: () =&gt; void;
  currentSessionId?: string;
}

export const Sidebar: React.FC&lt;SidebarProps&gt; = ({
  isOpen,
  onClose,
  currentSessionId,
}) =&gt; {
  const router = useRouter();
  const { sessions, loadSessions, createSession, deleteSession, userId } = useSessions();

  React.useEffect(() =&gt; {
    if (isOpen &amp;&amp; userId) {
      loadSessions(userId);
    }
  }, [isOpen, loadSessions, userId]);

  const handleCreateSession = async () =&gt; {
    const sessionName = `Chat ${sessions.length + 1}`;
    const newSession = await createSession({
      name: sessionName,
      description: &apos;New chat session&apos;,
    });

    if (newSession) {
      router.push(`/session/${newSession.id}`);
      onClose();
    }
  };

  const handleDeleteSession = async (sessionId: string, event: React.MouseEvent) =&gt; {
    event.preventDefault();
    event.stopPropagation();

    if (confirm(&apos;Are you sure you want to delete this session?&apos;)) {
      await deleteSession(sessionId);

      if (currentSessionId === sessionId) {
        router.push(&apos;/&apos;);
      }
    }
  };


  return (
    &lt;&gt;
      {/* Backdrop */}
      {isOpen &amp;&amp; (
        &lt;div
          className=&quot;fixed inset-0 bg-black bg-opacity-50 z-40 lg:hidden&quot;
          onClick={onClose}
        /&gt;
      )}

      {/* Sidebar */}
      &lt;div className={`
        fixed inset-y-0 left-0 z-50 w-64 sm:w-72 bg-white dark:bg-gray-900 border-r border-gray-200 dark:border-gray-700
        transform transition-transform duration-300 ease-in-out
        ${isOpen ? &apos;translate-x-0&apos; : &apos;-translate-x-full&apos;}
        lg:translate-x-0 lg:static lg:inset-0
      `}&gt;
        &lt;div className=&quot;flex flex-col h-full&quot;&gt;
          {/* Header */}
          &lt;div className=&quot;flex items-center justify-between p-3 sm:p-4 border-b border-gray-200 dark:border-gray-700&quot;&gt;
            &lt;h2 className=&quot;text-base sm:text-lg font-semibold text-gray-900 dark:text-white truncate&quot;&gt;
              Conversations
            &lt;/h2&gt;
            &lt;Button
              variant=&quot;ghost&quot;
              size=&quot;sm&quot;
              onClick={onClose}
              className=&quot;lg:hidden p-2&quot;
            &gt;
              &lt;svg
                className=&quot;h-4 w-4 sm:h-5 sm:w-5&quot;
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M6 18L18 6M6 6l12 12&quot;
                /&gt;
              &lt;/svg&gt;
            &lt;/Button&gt;
          &lt;/div&gt;

          {/* New Chat Button */}
          &lt;div className=&quot;p-3 sm:p-4&quot;&gt;
            &lt;Button
              onClick={handleCreateSession}
              className=&quot;w-full&quot;
              size=&quot;sm&quot;
            &gt;
              &lt;svg
                className=&quot;h-4 w-4 mr-2&quot;
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M12 4v16m8-8H4&quot;
                /&gt;
              &lt;/svg&gt;
              &lt;span className=&quot;text-sm&quot;&gt;New Chat&lt;/span&gt;
            &lt;/Button&gt;
          &lt;/div&gt;

          {/* Sessions List */}
          &lt;div className=&quot;flex-1 overflow-y-auto&quot;&gt;
            {sessions.length === 0 ? (
              &lt;div className=&quot;p-3 sm:p-4 text-center text-gray-500 dark:text-gray-400&quot;&gt;
                &lt;svg
                  className=&quot;h-10 w-10 sm:h-12 sm:w-12 mx-auto mb-2 text-gray-300 dark:text-gray-600&quot;
                  fill=&quot;none&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  stroke=&quot;currentColor&quot;
                &gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z&quot;
                  /&gt;
                &lt;/svg&gt;
                &lt;p className=&quot;text-sm&quot;&gt;No conversations yet&lt;/p&gt;
                &lt;p className=&quot;text-xs mt-1&quot;&gt;Start a new chat to begin&lt;/p&gt;
              &lt;/div&gt;
            ) : (
              &lt;nav className=&quot;space-y-1 p-2&quot;&gt;
                {sessions.map((session) =&gt; (
                  &lt;Link
                    key={session.id}
                    href={`/session/${session.id}`}
                    className={`
                      group flex items-center justify-between px-2 sm:px-3 py-2 sm:py-3 rounded-lg text-sm
                      transition-colors duration-200 touch-manipulation
                      ${currentSessionId === session.id
                        ? &apos;bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300 border-l-2 border-blue-500&apos;
                        : &apos;text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800&apos;
                      }
                    `}
                    onClick={onClose}
                  &gt;
                    &lt;div className=&quot;flex-1 min-w-0 pr-2&quot;&gt;
                      &lt;p className=&quot;font-medium text-sm truncate&quot;&gt;
                        {session.name}
                      &lt;/p&gt;
                      {session.description &amp;&amp; (
                        &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400 truncate hidden sm:block&quot;&gt;
                          {session.description}
                        &lt;/p&gt;
                      )}
                      &lt;p className=&quot;text-xs text-gray-400 dark:text-gray-500 mt-1&quot;&gt;
                        {getRelativeTime(session.updatedAt)}
                      &lt;/p&gt;
                    &lt;/div&gt;

                    &lt;Button
                      variant=&quot;ghost&quot;
                      size=&quot;sm&quot;
                      onClick={(e) =&gt; handleDeleteSession(session.id, e)}
                      className=&quot;opacity-0 group-hover:opacity-100 transition-opacity duration-200 p-1 sm:p-2 flex-shrink-0&quot;
                    &gt;
                      &lt;svg
                        className=&quot;h-3 w-3 sm:h-4 sm:w-4 text-red-500&quot;
                        fill=&quot;none&quot;
                        viewBox=&quot;0 0 24 24&quot;
                        stroke=&quot;currentColor&quot;
                      &gt;
                        &lt;path
                          strokeLinecap=&quot;round&quot;
                          strokeLinejoin=&quot;round&quot;
                          strokeWidth={2}
                          d=&quot;M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16&quot;
                        /&gt;
                      &lt;/svg&gt;
                    &lt;/Button&gt;
                  &lt;/Link&gt;
                ))}
              &lt;/nav&gt;
            )}
          &lt;/div&gt;

          {/* Footer */}
          &lt;div className=&quot;p-3 sm:p-4 border-t border-gray-200 dark:border-gray-700&quot;&gt;
            &lt;Link href=&quot;/settings&quot;&gt;
              &lt;Button
                variant=&quot;ghost&quot;
                className=&quot;w-full justify-start&quot;
                size=&quot;sm&quot;
              &gt;
                &lt;svg
                  className=&quot;h-4 w-4 mr-2&quot;
                  fill=&quot;none&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  stroke=&quot;currentColor&quot;
                &gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z&quot;
                  /&gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M15 12a3 3 0 11-6 0 3 3 0 016 0z&quot;
                  /&gt;
                &lt;/svg&gt;
                &lt;span className=&quot;text-sm&quot;&gt;Settings&lt;/span&gt;
              &lt;/Button&gt;
            &lt;/Link&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
};</file><file path="src/components/layout/TabBar.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

export interface TabItem {
  id: string;
  label: string;
  icon?: React.ReactNode;
  badge?: string | number;
  disabled?: boolean;
}

interface TabBarProps {
  tabs: TabItem[];
  activeTab: string;
  onTabChange: (tabId: string) =&gt; void;
  variant?: &apos;default&apos; | &apos;pills&apos; | &apos;underline&apos;;
  size?: &apos;sm&apos; | &apos;md&apos; | &apos;lg&apos;;
  className?: string;
  actions?: React.ReactNode;
}

export const TabBar: React.FC&lt;TabBarProps&gt; = ({
  tabs,
  activeTab,
  onTabChange,
  variant = &apos;default&apos;,
  size = &apos;md&apos;,
  className,
  actions,
}) =&gt; {
  const sizeClasses = {
    sm: &apos;text-sm&apos;,
    md: &apos;text-base&apos;,
    lg: &apos;text-lg&apos;,
  };

  const getVariantClasses = () =&gt; {
    switch (variant) {
      case &apos;pills&apos;:
        return &apos;bg-gray-100 dark:bg-gray-800 p-1 rounded-lg gap-1&apos;;
      case &apos;underline&apos;:
        return &apos;border-b border-gray-200 dark:border-gray-700 gap-8&apos;;
      default:
        return &apos;border-b border-gray-200 dark:border-gray-700 gap-8&apos;;
    }
  };

  const getTabClasses = (tab: TabItem) =&gt; {
    const baseClasses = clsx(
      &apos;flex items-center gap-2 font-medium transition-colors duration-200&apos;,
      sizeClasses[size],
      tab.disabled &amp;&amp; &apos;opacity-50 cursor-not-allowed&apos;
    );

    switch (variant) {
      case &apos;pills&apos;:
        return clsx(
          baseClasses,
          &apos;px-3 py-2 rounded-md&apos;,
          activeTab === tab.id
            ? &apos;bg-white dark:bg-gray-900 text-blue-600 dark:text-blue-400 shadow-sm&apos;
            : &apos;text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200&apos;
        );
      case &apos;underline&apos;:
        return clsx(
          baseClasses,
          &apos;pb-3 border-b-2&apos;,
          activeTab === tab.id
            ? &apos;border-blue-500 text-blue-600 dark:text-blue-400&apos;
            : &apos;border-transparent text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200&apos;
        );
      default:
        return clsx(
          baseClasses,
          &apos;py-4 border-b-2&apos;,
          activeTab === tab.id
            ? &apos;border-blue-500 text-blue-600 dark:text-blue-400&apos;
            : &apos;border-transparent text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200&apos;
        );
    }
  };

  return (
    &lt;div className={clsx(&apos;flex justify-between items-center pt-2&apos;, getVariantClasses(), className)}&gt;
      &lt;div className=&quot;flex gap-8&quot;&gt;
        {tabs.map((tab) =&gt; (
          &lt;button
            key={tab.id}
            className={getTabClasses(tab)}
            onClick={() =&gt; !tab.disabled &amp;&amp; onTabChange(tab.id)}
            disabled={tab.disabled}
          &gt;
            {tab.icon &amp;&amp; (
              &lt;span className=&quot;flex-shrink-0&quot;&gt;
                {tab.icon}
              &lt;/span&gt;
            )}
            
            &lt;span className=&quot;truncate&quot;&gt;
              {tab.label}
            &lt;/span&gt;
            
            {tab.badge &amp;&amp; (
              &lt;span className={clsx(
                &apos;inline-flex items-center justify-center px-2 py-1 text-xs font-bold rounded-full&apos;,
                activeTab === tab.id
                  ? &apos;bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200&apos;
                  : &apos;bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200&apos;
              )}&gt;
                {tab.badge}
              &lt;/span&gt;
            )}
          &lt;/button&gt;
        ))}
      &lt;/div&gt;
      
      {actions &amp;&amp; (
        &lt;div className=&quot;ml-4&quot;&gt;
          {actions}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

// Preset tab configurations
export const ChatTabs = {
  ChatDocuments: [
    {
      id: &apos;chat&apos;,
      label: &apos;Chat&apos;,
      icon: (
        &lt;svg className=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z&quot; /&gt;
        &lt;/svg&gt;
      ),
    },
    {
      id: &apos;documents&apos;,
      label: &apos;Documents&apos;,
      icon: (
        &lt;svg className=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z&quot; /&gt;
        &lt;/svg&gt;
      ),
    },
  ] as TabItem[],
};

export const SettingsTabs = {
  General: [
    {
      id: &apos;general&apos;,
      label: &apos;General&apos;,
      icon: (
        &lt;svg className=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z&quot; /&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M15 12a3 3 0 11-6 0 3 3 0 016 0z&quot; /&gt;
        &lt;/svg&gt;
      ),
    },
    {
      id: &apos;api&apos;,
      label: &apos;API&apos;,
      icon: (
        &lt;svg className=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M13 10V3L4 14h7v7l9-11h-7z&quot; /&gt;
        &lt;/svg&gt;
      ),
    },
    {
      id: &apos;rag&apos;,
      label: &apos;RAG&apos;,
      icon: (
        &lt;svg className=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z&quot; /&gt;
        &lt;/svg&gt;
      ),
    },
    {
      id: &apos;privacy&apos;,
      label: &apos;Privacy&apos;,
      icon: (
        &lt;svg className=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z&quot; /&gt;
        &lt;/svg&gt;
      ),
    },
    {
      id: &apos;advanced&apos;,
      label: &apos;Advanced&apos;,
      icon: (
        &lt;svg className=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z&quot; /&gt;
          &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M15 12a3 3 0 11-6 0 3 3 0 016 0z&quot; /&gt;
        &lt;/svg&gt;
      ),
    },
  ] as TabItem[],
};</file><file path="src/components/session/RenameSessionDialog.tsx">import React, { useState, useEffect } from &apos;react&apos;;
import { Modal } from &apos;../ui/Modal&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { Input } from &apos;../ui/Input&apos;;
import { useSessionStore } from &apos;../../store&apos;;
import { Session } from &apos;../../types&apos;;

interface RenameSessionDialogProps {
  isOpen: boolean;
  onClose: () =&gt; void;
  session: Session | null;
  onRename?: (session: Session) =&gt; void;
}

export const RenameSessionDialog: React.FC&lt;RenameSessionDialogProps&gt; = ({
  isOpen,
  onClose,
  session,
  onRename,
}) =&gt; {
  const [name, setName] = useState(&apos;&apos;);
  const [description, setDescription] = useState(&apos;&apos;);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(&apos;&apos;);
  
  const { updateSession } = useSessionStore();

  // Reset form when session changes
  useEffect(() =&gt; {
    if (session) {
      setName(session.name);
      setDescription(session.description || &apos;&apos;);
      setError(&apos;&apos;);
    }
  }, [session]);

  const handleSubmit = async (e: React.FormEvent) =&gt; {
    e.preventDefault();
    
    if (!name.trim()) {
      setError(&apos;Session name is required&apos;);
      return;
    }

    if (!session) {
      setError(&apos;No session selected&apos;);
      return;
    }

    setIsLoading(true);
    setError(&apos;&apos;);

    try {
      await updateSession(session.id, {
        name: name.trim(),
        description: description.trim() || undefined,
      });

      if (onRename) {
        onRename(session);
      }

      onClose();
    } catch (error) {
      setError(error instanceof Error ? error.message : &apos;Failed to rename session&apos;);
    } finally {
      setIsLoading(false);
    }
  };

  const handleClose = () =&gt; {
    if (!isLoading) {
      setError(&apos;&apos;);
      onClose();
    }
  };

  return (
    &lt;Modal
      isOpen={isOpen}
      onClose={handleClose}
      size=&quot;md&quot;
    &gt;
      &lt;form onSubmit={handleSubmit} className=&quot;space-y-4&quot;&gt;
        &lt;div&gt;
          &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;
            Rename Session
          &lt;/h2&gt;
        &lt;/div&gt;

        {/* Session Name */}
        &lt;div&gt;
          &lt;Input
            label=&quot;Session Name&quot;
            placeholder=&quot;Enter a name for this session&quot;
            value={name}
            onChange={(e) =&gt; setName(e.target.value)}
            required
            disabled={isLoading}
            autoFocus
          /&gt;
        &lt;/div&gt;

        {/* Description */}
        &lt;div&gt;
          &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;
            Description (optional)
          &lt;/label&gt;
          &lt;textarea
            value={description}
            onChange={(e) =&gt; setDescription(e.target.value)}
            placeholder=&quot;Brief description of this session&apos;s purpose&quot;
            rows={3}
            disabled={isLoading}
            className={`
              w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg
              bg-white dark:bg-gray-800
              text-gray-900 dark:text-gray-100
              placeholder-gray-500 dark:placeholder-gray-400
              focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent
              disabled:opacity-50 disabled:cursor-not-allowed
              transition-colors duration-200
            `}
          /&gt;
        &lt;/div&gt;

        {/* Error Message */}
        {error &amp;&amp; (
          &lt;div className=&quot;p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg&quot;&gt;
            &lt;p className=&quot;text-sm text-red-600 dark:text-red-400&quot;&gt;{error}&lt;/p&gt;
          &lt;/div&gt;
        )}

        {/* Actions */}
        &lt;div className=&quot;flex gap-3 pt-4&quot;&gt;
          &lt;Button
            type=&quot;button&quot;
            variant=&quot;outline&quot;
            onClick={handleClose}
            disabled={isLoading}
            className=&quot;flex-1&quot;
          &gt;
            Cancel
          &lt;/Button&gt;
          
          &lt;Button
            type=&quot;submit&quot;
            loading={isLoading}
            disabled={!name.trim() || !session}
            className=&quot;flex-1&quot;
          &gt;
            Rename Session
          &lt;/Button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/Modal&gt;
  );
};

// Hook for managing rename session dialog
export const useRenameSessionDialog = () =&gt; {
  const [isOpen, setIsOpen] = useState(false);
  const [session, setSession] = useState&lt;Session | null&gt;(null);

  const openDialog = (sessionToRename: Session) =&gt; {
    setSession(sessionToRename);
    setIsOpen(true);
  };

  const closeDialog = () =&gt; {
    setIsOpen(false);
    setSession(null);
  };

  const RenameSessionDialogComponent = () =&gt; (
    &lt;RenameSessionDialog
      isOpen={isOpen}
      onClose={closeDialog}
      session={session}
    /&gt;
  );

  return {
    isOpen,
    session,
    openDialog,
    closeDialog,
    RenameSessionDialog: RenameSessionDialogComponent,
  };
};</file><file path="src/components/session/SessionCard.tsx">import React, { useState } from &apos;react&apos;;
import { Session } from &apos;../../types&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { Card } from &apos;../ui/Card&apos;;
import { useConfirmDialog } from &apos;../common/ConfirmDialog&apos;;
import { useSessionStore } from &apos;../../store&apos;;
import { getRelativeTime, formatTime } from &apos;../../utils/date&apos;;
import clsx from &apos;clsx&apos;;

interface SessionCardProps {
  session: Session;
  isActive?: boolean;
  onClick?: () =&gt; void;
  className?: string;
}

export const SessionCard: React.FC&lt;SessionCardProps&gt; = ({
  session,
  isActive = false,
  onClick,
  className,
}) =&gt; {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const { deleteSession, updateSession } = useSessionStore();
  const { confirm, ConfirmDialog } = useConfirmDialog();

  const handleDelete = async () =&gt; {
    await confirm({
      title: &apos;Delete Session&apos;,
      message: `Are you sure you want to delete &quot;${session.name}&quot;? This action cannot be undone.`,
      onConfirm: async () =&gt; {
        try {
          await deleteSession(session.id);
        } catch (error) {
          console.error(&apos;Failed to delete session:&apos;, error);
        }
      },
      confirmText: &apos;Delete&apos;,
      cancelText: &apos;Cancel&apos;,
      variant: &apos;danger&apos;,
    });
  };

  const handleRename = async () =&gt; {
    const newName = prompt(&apos;Enter new name:&apos;, session.name);
    if (newName &amp;&amp; newName.trim() &amp;&amp; newName !== session.name) {
      try {
        await updateSession(session.id, { name: newName.trim() });
      } catch (error) {
        console.error(&apos;Failed to rename session:&apos;, error);
      }
    }
  };


  return (
    &lt;&gt;
      &lt;div
        className={clsx(
          &apos;bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700&apos;,
          &apos;cursor-pointer transition-all duration-200 hover:shadow-md&apos;,
          isActive &amp;&amp; &apos;ring-2 ring-blue-500 bg-blue-50 dark:bg-blue-900/20&apos;,
          className
        )}
        onClick={onClick}
      &gt;
        &lt;div className=&quot;p-3 sm:p-4&quot;&gt;
          &lt;div className=&quot;flex items-start justify-between&quot;&gt;
            {/* Session Info */}
            &lt;div className=&quot;flex-1 min-w-0 pr-2&quot;&gt;
              &lt;h3 className=&quot;font-medium text-sm sm:text-base text-gray-900 dark:text-white truncate&quot;&gt;
                {session.name}
              &lt;/h3&gt;
              
              {session.description &amp;&amp; (
                &lt;p className=&quot;text-xs sm:text-sm text-gray-600 dark:text-gray-300 mt-1 line-clamp-2 hidden sm:block&quot;&gt;
                  {session.description}
                &lt;/p&gt;
              )}
              
              &lt;div className=&quot;flex items-center mt-2 text-xs text-gray-500 dark:text-gray-400 space-x-2 sm:space-x-3&quot;&gt;
                &lt;span&gt;{getRelativeTime(session.updatedAt)}&lt;/span&gt;
                {session.documentCount &gt; 0 &amp;&amp; (
                  &lt;span&gt;{session.documentCount} docs&lt;/span&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;

            {/* Menu Button */}
            &lt;div className=&quot;relative&quot;&gt;
              &lt;Button
                variant=&quot;ghost&quot;
                size=&quot;sm&quot;
                onClick={(e) =&gt; {
                  e.stopPropagation();
                  setIsMenuOpen(!isMenuOpen);
                }}
                className=&quot;p-1&quot;
              &gt;
                &lt;svg
                  className=&quot;w-4 h-4 text-white&quot;
                  fill=&quot;none&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  stroke=&quot;currentColor&quot;
                &gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z&quot;
                  /&gt;
                &lt;/svg&gt;
              &lt;/Button&gt;

              {/* Dropdown Menu */}
              {isMenuOpen &amp;&amp; (
                &lt;div className=&quot;absolute right-0 top-full mt-1 w-44 sm:w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 z-10&quot;&gt;
                  &lt;button
                    onClick={(e) =&gt; {
                      e.stopPropagation();
                      handleRename();
                      setIsMenuOpen(false);
                    }}
                    className=&quot;w-full text-left px-3 sm:px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-t-lg touch-manipulation&quot;
                  &gt;
                    Rename
                  &lt;/button&gt;
                  &lt;button
                    onClick={(e) =&gt; {
                      e.stopPropagation();
                      handleDelete();
                      setIsMenuOpen(false);
                    }}
                    className=&quot;w-full text-left px-3 sm:px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-b-lg touch-manipulation&quot;
                  &gt;
                    Delete
                  &lt;/button&gt;
                &lt;/div&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Close menu when clicking outside */}
      {isMenuOpen &amp;&amp; (
        &lt;div
          className=&quot;fixed inset-0 z-0&quot;
          onClick={() =&gt; setIsMenuOpen(false)}
        /&gt;
      )}

      &lt;ConfirmDialog /&gt;
    &lt;/&gt;
  );
};

// Compact version for sidebar
export const SessionCardCompact: React.FC&lt;{
  session: Session;
  isActive?: boolean;
  onClick?: () =&gt; void;
  className?: string;
}&gt; = ({ session, isActive = false, onClick, className }) =&gt; {

  return (
    &lt;div
      className={clsx(
        &apos;p-2 sm:p-3 rounded-lg cursor-pointer transition-colors duration-200 touch-manipulation&apos;,
        &apos;hover:bg-gray-100 dark:hover:bg-gray-800&apos;,
        isActive &amp;&amp; &apos;bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300&apos;,
        className
      )}
      onClick={onClick}
    &gt;
      &lt;div className=&quot;flex items-center justify-between&quot;&gt;
        &lt;div className=&quot;flex-1 min-w-0 pr-2&quot;&gt;
          &lt;h4 className=&quot;font-medium text-xs sm:text-sm text-gray-900 dark:text-white truncate&quot;&gt;
            {session.name}
          &lt;/h4&gt;
          &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400 mt-1 hidden sm:block&quot;&gt;
            {formatTime(session.updatedAt)}
          &lt;/p&gt;
        &lt;/div&gt;
        
        {session.documentCount &gt; 0 &amp;&amp; (
          &lt;div className=&quot;ml-1 sm:ml-2 flex-shrink-0&quot;&gt;
            &lt;span className=&quot;inline-flex items-center px-1.5 sm:px-2 py-0.5 sm:py-1 rounded-full text-xs bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300&quot;&gt;
              {session.documentCount}
            &lt;/span&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/session/SessionList.tsx">import React, { useState, useEffect } from &apos;react&apos;;
import { Session } from &apos;../../types&apos;;
import { SessionCard, SessionCardCompact } from &apos;./SessionCard&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { Input } from &apos;../ui/Input&apos;;
import { Loading } from &apos;../ui/Loading&apos;;
import { EmptyStates } from &apos;../common/EmptyState&apos;;
import { useSessionStore } from &apos;../../store&apos;;
import { useRouter } from &apos;next/navigation&apos;;
import clsx from &apos;clsx&apos;;

interface SessionListProps {
  variant?: &apos;grid&apos; | &apos;list&apos; | &apos;compact&apos;;
  showCreateButton?: boolean;
  onSessionSelect?: (session: Session) =&gt; void;
  className?: string;
}

export const SessionList: React.FC&lt;SessionListProps&gt; = ({
  variant = &apos;grid&apos;,
  showCreateButton = true,
  onSessionSelect,
  className,
}) =&gt; {
  const [searchQuery, setSearchQuery] = useState(&apos;&apos;);
  const { sessions, isLoading, createSession } = useSessionStore();
  const router = useRouter();

  // Filter sessions based on search query
  const filteredSessions = sessions.filter(session =&gt;
    session.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    (session.description &amp;&amp; session.description.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  const handleSessionClick = (session: Session) =&gt; {
    if (onSessionSelect) {
      onSessionSelect(session);
    } else {
      router.push(`/session/${session.id}`);
    }
  };

  const handleCreateSession = async () =&gt; {
    const sessionName = prompt(&apos;Enter session name:&apos;, &apos;New Chat&apos;);
    if (sessionName &amp;&amp; sessionName.trim()) {
      try {
        const newSession = await createSession({
          name: sessionName.trim(),
          description: &apos;&apos;,
        });
        router.push(`/session/${newSession.id}`);
      } catch (error) {
        console.error(&apos;Failed to create session:&apos;, error);
      }
    }
  };

  if (isLoading &amp;&amp; sessions.length === 0) {
    return (
      &lt;div className={clsx(&apos;flex justify-center items-center h-64&apos;, className)}&gt;
        &lt;Loading size=&quot;lg&quot; text=&quot;Loading sessions...&quot; /&gt;
      &lt;/div&gt;
    );
  }

  if (sessions.length === 0) {
    return (
      &lt;div className={clsx(&apos;text-center py-12&apos;, className)}&gt;
        &lt;EmptyStates.NoSessions /&gt;
        {showCreateButton &amp;&amp; (
          &lt;div className=&quot;mt-6&quot;&gt;
            &lt;Button onClick={handleCreateSession}&gt;
              &lt;svg
                className=&quot;w-4 h-4 mr-2&quot;
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M12 4v16m8-8H4&quot;
                /&gt;
              &lt;/svg&gt;
              Create First Session
            &lt;/Button&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className={className}&gt;
      {/* Search Bar */}
      {sessions.length &gt; 5 &amp;&amp; (
        &lt;div className=&quot;mb-6&quot;&gt;
          &lt;Input
            type=&quot;search&quot;
            placeholder=&quot;Search sessions...&quot;
            value={searchQuery}
            onChange={(e) =&gt; setSearchQuery(e.target.value)}
            leftIcon={
              &lt;svg
                className=&quot;w-4 h-4&quot;
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z&quot;
                /&gt;
              &lt;/svg&gt;
            }
          /&gt;
        &lt;/div&gt;
      )}

      {/* Create Button */}
      {showCreateButton &amp;&amp; (
        &lt;div className=&quot;mb-6&quot;&gt;
          &lt;Button onClick={handleCreateSession} className=&quot;w-full sm:w-auto&quot;&gt;
            &lt;svg
              className=&quot;w-4 h-4 mr-2&quot;
              fill=&quot;none&quot;
              viewBox=&quot;0 0 24 24&quot;
              stroke=&quot;currentColor&quot;
            &gt;
              &lt;path
                strokeLinecap=&quot;round&quot;
                strokeLinejoin=&quot;round&quot;
                strokeWidth={2}
                d=&quot;M12 4v16m8-8H4&quot;
              /&gt;
            &lt;/svg&gt;
            New Session
          &lt;/Button&gt;
        &lt;/div&gt;
      )}

      {/* Sessions Display */}
      {filteredSessions.length === 0 ? (
        &lt;div className=&quot;text-center py-8&quot;&gt;
          &lt;p className=&quot;text-gray-500 dark:text-gray-400&quot;&gt;
            No sessions found matching &quot;{searchQuery}&quot;
          &lt;/p&gt;
        &lt;/div&gt;
      ) : (
        &lt;&gt;
          {variant === &apos;grid&apos; &amp;&amp; (
            &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4&quot;&gt;
              {filteredSessions.map((session) =&gt; (
                &lt;SessionCard
                  key={session.id}
                  session={session}
                  onClick={() =&gt; handleSessionClick(session)}
                /&gt;
              ))}
            &lt;/div&gt;
          )}

          {variant === &apos;list&apos; &amp;&amp; (
            &lt;div className=&quot;space-y-4&quot;&gt;
              {filteredSessions.map((session) =&gt; (
                &lt;SessionCard
                  key={session.id}
                  session={session}
                  onClick={() =&gt; handleSessionClick(session)}
                /&gt;
              ))}
            &lt;/div&gt;
          )}

          {variant === &apos;compact&apos; &amp;&amp; (
            &lt;div className=&quot;space-y-2&quot;&gt;
              {filteredSessions.map((session) =&gt; (
                &lt;SessionCardCompact
                  key={session.id}
                  session={session}
                  onClick={() =&gt; handleSessionClick(session)}
                /&gt;
              ))}
            &lt;/div&gt;
          )}
        &lt;/&gt;
      )}

      {/* Session Count */}
      {searchQuery &amp;&amp; (
        &lt;div className=&quot;mt-4 text-sm text-gray-500 dark:text-gray-400 text-center&quot;&gt;
          Showing {filteredSessions.length} of {sessions.length} sessions
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

// Sidebar version of session list
export const SessionListSidebar: React.FC&lt;{
  onSessionSelect?: (session: Session) =&gt; void;
  className?: string;
}&gt; = ({ onSessionSelect, className }) =&gt; {
  const { sessions, isLoading, createSession } = useSessionStore();
  const router = useRouter();

  const handleSessionClick = (session: Session) =&gt; {
    if (onSessionSelect) {
      onSessionSelect(session);
    } else {
      router.push(`/session/${session.id}`);
    }
  };

  const handleCreateSession = async () =&gt; {
    const sessionName = prompt(&apos;Enter session name:&apos;, &apos;New Chat&apos;);
    if (sessionName &amp;&amp; sessionName.trim()) {
      try {
        const newSession = await createSession({
          name: sessionName.trim(),
          description: &apos;&apos;,
        });
        router.push(`/session/${newSession.id}`);
      } catch (error) {
        console.error(&apos;Failed to create session:&apos;, error);
      }
    }
  };

  if (isLoading &amp;&amp; sessions.length === 0) {
    return (
      &lt;div className=&quot;p-4&quot;&gt;
        &lt;Loading size=&quot;sm&quot; text=&quot;Loading...&quot; /&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className={className}&gt;
      {/* Create Button */}
      &lt;div className=&quot;p-4 border-b border-gray-200 dark:border-gray-700&quot;&gt;
        &lt;Button
          size=&quot;sm&quot;
          onClick={handleCreateSession}
          className=&quot;w-full&quot;
        &gt;
          &lt;svg
            className=&quot;w-4 h-4 mr-2&quot;
            fill=&quot;none&quot;
            viewBox=&quot;0 0 24 24&quot;
            stroke=&quot;currentColor&quot;
          &gt;
            &lt;path
              strokeLinecap=&quot;round&quot;
              strokeLinejoin=&quot;round&quot;
              strokeWidth={2}
              d=&quot;M12 4v16m8-8H4&quot;
            /&gt;
          &lt;/svg&gt;
          New Chat
        &lt;/Button&gt;
      &lt;/div&gt;

      {/* Sessions */}
      &lt;div className=&quot;max-h-96 overflow-y-auto&quot;&gt;
        {sessions.length === 0 ? (
          &lt;div className=&quot;p-4 text-center&quot;&gt;
            &lt;EmptyStates.NoSessions /&gt;
          &lt;/div&gt;
        ) : (
          &lt;div className=&quot;p-2&quot;&gt;
            {sessions.map((session) =&gt; (
              &lt;SessionCardCompact
                key={session.id}
                session={session}
                onClick={() =&gt; handleSessionClick(session)}
              /&gt;
            ))}
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/ui/Card.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

interface CardProps {
  children: React.ReactNode;
  className?: string;
  padding?: &apos;none&apos; | &apos;sm&apos; | &apos;md&apos; | &apos;lg&apos;;
  shadow?: &apos;none&apos; | &apos;sm&apos; | &apos;md&apos; | &apos;lg&apos;;
  hover?: boolean;
}

interface CardHeaderProps {
  children: React.ReactNode;
  className?: string;
}

interface CardBodyProps {
  children: React.ReactNode;
  className?: string;
}

interface CardFooterProps {
  children: React.ReactNode;
  className?: string;
}

export const Card: React.FC&lt;CardProps&gt; = ({
  children,
  className,
  padding = &apos;md&apos;,
  shadow = &apos;md&apos;,
  hover = false,
}) =&gt; {
  const baseClasses = &apos;bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700&apos;;
  
  const paddingClasses = {
    none: &apos;&apos;,
    sm: &apos;p-4&apos;,
    md: &apos;p-6&apos;,
    lg: &apos;p-8&apos;,
  };
  
  const shadowClasses = {
    none: &apos;&apos;,
    sm: &apos;shadow-sm&apos;,
    md: &apos;shadow-md&apos;,
    lg: &apos;shadow-lg&apos;,
  };

  return (
    &lt;div
      className={clsx(
        baseClasses,
        paddingClasses[padding],
        shadowClasses[shadow],
        hover &amp;&amp; &apos;hover:shadow-lg transition-shadow duration-200&apos;,
        className
      )}
    &gt;
      {children}
    &lt;/div&gt;
  );
};

export const CardHeader: React.FC&lt;CardHeaderProps&gt; = ({
  children,
  className,
}) =&gt; {
  return (
    &lt;div className={clsx(&apos;border-b border-gray-200 dark:border-gray-700 px-6 py-4&apos;, className)}&gt;
      {children}
    &lt;/div&gt;
  );
};

export const CardBody: React.FC&lt;CardBodyProps&gt; = ({
  children,
  className,
}) =&gt; {
  return (
    &lt;div className={clsx(&apos;px-6 py-4&apos;, className)}&gt;
      {children}
    &lt;/div&gt;
  );
};

export const CardFooter: React.FC&lt;CardFooterProps&gt; = ({
  children,
  className,
}) =&gt; {
  return (
    &lt;div className={clsx(&apos;border-t border-gray-200 dark:border-gray-700 px-6 py-4&apos;, className)}&gt;
      {children}
    &lt;/div&gt;
  );
};</file><file path="src/components/ui/DropdownMenu.tsx">import React, { useState, useRef, useEffect } from &apos;react&apos;;
import { Button } from &apos;./Button&apos;;

interface DropdownMenuProps {
  trigger: React.ReactNode;
  children: React.ReactNode;
  align?: &apos;left&apos; | &apos;right&apos;;
  closeOnSelect?: boolean;
}

export const DropdownMenu: React.FC&lt;DropdownMenuProps&gt; = ({
  trigger,
  children,
  align = &apos;right&apos;,
  closeOnSelect = false,
}) =&gt; {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef&lt;HTMLDivElement&gt;(null);

  useEffect(() =&gt; {
    const handleClickOutside = (event: MouseEvent) =&gt; {
      if (dropdownRef.current &amp;&amp; !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener(&apos;mousedown&apos;, handleClickOutside);
    return () =&gt; document.removeEventListener(&apos;mousedown&apos;, handleClickOutside);
  }, []);

  const alignClasses = {
    left: &apos;left-0&apos;,
    right: &apos;right-0&apos;,
  };

  return (
    &lt;div className=&quot;relative inline-block text-left&quot; ref={dropdownRef} data-dropdown&gt;
      &lt;div onClick={() =&gt; setIsOpen(!isOpen)}&gt;
        {trigger}
      &lt;/div&gt;
      
      {isOpen &amp;&amp; (
        &lt;div className={`
          absolute z-50 mt-2 w-48 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5
          ${alignClasses[align]}
        `}&gt;
          &lt;div className=&quot;py-1&quot;&gt;
            {children}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

interface DropdownMenuItemProps {
  onClick: () =&gt; void;
  children: React.ReactNode;
  variant?: &apos;default&apos; | &apos;danger&apos;;
  disabled?: boolean;
  closeOnClick?: boolean;
}

export const DropdownMenuItem: React.FC&lt;DropdownMenuItemProps&gt; = ({
  onClick,
  children,
  variant = &apos;default&apos;,
  disabled = false,
  closeOnClick = true,
}) =&gt; {
  const variantClasses = {
    default: &apos;text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&apos;,
    danger: &apos;text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20&apos;,
  };

  const disabledClasses = disabled ? &apos;opacity-50 cursor-not-allowed&apos; : &apos;&apos;;

  // Get the parent DropdownMenu component to control its state
  const getDropdownMenu = () =&gt; {
    let element = document.activeElement as HTMLElement;
    while (element &amp;&amp; element.parentElement) {
      if (element.parentElement.hasAttribute(&apos;data-dropdown&apos;)) {
        return element.parentElement;
      }
      element = element.parentElement;
    }
    return null;
  };

  const handleClick = () =&gt; {
    if (!disabled) {
      onClick();
      // Close the dropdown if closeOnClick is true
      if (closeOnClick) {
        const dropdown = getDropdownMenu();
        if (dropdown) {
          const clickEvent = new MouseEvent(&apos;mousedown&apos;, {
            bubbles: true,
            cancelable: true,
            view: window,
          });
          document.dispatchEvent(clickEvent);
        }
      }
    }
  };

  return (
    &lt;button
      onClick={handleClick}
      disabled={disabled}
      className={`
        w-full text-left px-4 py-2 text-sm transition-colors duration-200
        ${variantClasses[variant]}
        ${disabledClasses}
      `}
    &gt;
      {children}
    &lt;/button&gt;
  );
};</file><file path="src/components/ui/Input.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

interface InputProps extends React.InputHTMLAttributes&lt;HTMLInputElement&gt; {
  label?: string;
  error?: string;
  helperText?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export const Input: React.FC&lt;InputProps&gt; = ({
  label,
  error,
  helperText,
  leftIcon,
  rightIcon,
  className,
  id,
  ...props
}) =&gt; {
  const inputId = id || `input-${Math.random().toString(36).substr(2, 9)}`;
  
  return (
    &lt;div className=&quot;w-full&quot;&gt;
      {label &amp;&amp; (
        &lt;label 
          htmlFor={inputId}
          className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1&quot;
        &gt;
          {label}
        &lt;/label&gt;
      )}
      
      &lt;div className=&quot;relative&quot;&gt;
        {leftIcon &amp;&amp; (
          &lt;div className=&quot;absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none&quot;&gt;
            &lt;div className=&quot;h-5 w-5 text-gray-400&quot;&gt;
              {leftIcon}
            &lt;/div&gt;
          &lt;/div&gt;
        )}
        
        &lt;input
          id={inputId}
          className={clsx(
            &apos;block w-full rounded-lg border border-gray-300 px-3 py-2 text-sm&apos;,
            &apos;placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500&apos;,
            &apos;disabled:bg-gray-100 disabled:text-gray-500 disabled:cursor-not-allowed&apos;,
            &apos;dark:bg-gray-800 dark:border-gray-600 dark:text-white dark:placeholder-gray-500&apos;,
            &apos;dark:focus:ring-blue-400 dark:focus:border-blue-400&apos;,
            error &amp;&amp; &apos;border-red-500 focus:ring-red-500 focus:border-red-500&apos;,
            leftIcon &amp;&amp; &apos;pl-10&apos;,
            rightIcon &amp;&amp; &apos;pr-10&apos;,
            className
          )}
          {...props}
        /&gt;
        
        {rightIcon &amp;&amp; (
          &lt;div className=&quot;absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none&quot;&gt;
            &lt;div className=&quot;h-5 w-5 text-gray-400&quot;&gt;
              {rightIcon}
            &lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
      
      {error &amp;&amp; (
        &lt;p className=&quot;mt-1 text-sm text-red-600 dark:text-red-400&quot;&gt;
          {error}
        &lt;/p&gt;
      )}
      
      {helperText &amp;&amp; !error &amp;&amp; (
        &lt;p className=&quot;mt-1 text-sm text-gray-500 dark:text-gray-400&quot;&gt;
          {helperText}
        &lt;/p&gt;
      )}
    &lt;/div&gt;
  );
};</file><file path="src/components/ui/Loading.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

interface LoadingProps {
  size?: &apos;sm&apos; | &apos;md&apos; | &apos;lg&apos;;
  text?: string;
  className?: string;
  overlay?: boolean;
}

export const Loading: React.FC&lt;LoadingProps&gt; = ({
  size = &apos;md&apos;,
  text,
  className,
  overlay = false,
}) =&gt; {
  const sizeClasses = {
    sm: &apos;h-4 w-4&apos;,
    md: &apos;h-6 w-6&apos;,
    lg: &apos;h-8 w-8&apos;,
  };

  const containerClasses = clsx(
    &apos;flex items-center justify-center&apos;,
    overlay &amp;&amp; &apos;fixed inset-0 bg-black bg-opacity-50 z-50&apos;,
    className
  );

  const spinner = (
    &lt;svg
      className={clsx(&apos;animate-spin text-blue-600 dark:text-blue-400&apos;, sizeClasses[size])}
      xmlns=&quot;http://www.w3.org/2000/svg&quot;
      fill=&quot;none&quot;
      viewBox=&quot;0 0 24 24&quot;
    &gt;
      &lt;circle
        className=&quot;opacity-25&quot;
        cx=&quot;12&quot;
        cy=&quot;12&quot;
        r=&quot;10&quot;
        stroke=&quot;currentColor&quot;
        strokeWidth=&quot;4&quot;
      /&gt;
      &lt;path
        className=&quot;opacity-75&quot;
        fill=&quot;currentColor&quot;
        d=&quot;M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z&quot;
      /&gt;
    &lt;/svg&gt;
  );

  if (overlay) {
    return (
      &lt;div className={containerClasses}&gt;
        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-lg p-6 shadow-lg&quot;&gt;
          &lt;div className=&quot;flex flex-col items-center space-y-3&quot;&gt;
            {spinner}
            {text &amp;&amp; (
              &lt;p className=&quot;text-sm text-gray-600 dark:text-gray-300&quot;&gt;
                {text}
              &lt;/p&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className={containerClasses}&gt;
      &lt;div className=&quot;flex items-center space-x-3&quot;&gt;
        {spinner}
        {text &amp;&amp; (
          &lt;span className=&quot;text-sm text-gray-600 dark:text-gray-300&quot;&gt;
            {text}
          &lt;/span&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

interface LoadingSkeletonProps {
  lines?: number;
  className?: string;
}

export const LoadingSkeleton: React.FC&lt;LoadingSkeletonProps&gt; = ({
  lines = 3,
  className,
}) =&gt; {
  return (
    &lt;div className={clsx(&apos;space-y-3&apos;, className)}&gt;
      {Array.from({ length: lines }).map((_, index) =&gt; (
        &lt;div
          key={index}
          className=&quot;h-4 bg-gray-200 dark:bg-gray-700 rounded animate-pulse&quot;
          style={{
            width: `${Math.random() * 40 + 60}%`, // Random width between 60-100%
          }}
        /&gt;
      ))}
    &lt;/div&gt;
  );
};

interface LoadingCardProps {
  title?: boolean;
  lines?: number;
  className?: string;
}

export const LoadingCard: React.FC&lt;LoadingCardProps&gt; = ({
  title = true,
  lines = 3,
  className,
}) =&gt; {
  return (
    &lt;div className={clsx(&apos;bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6&apos;, className)}&gt;
      {title &amp;&amp; (
        &lt;div className=&quot;h-6 bg-gray-200 dark:bg-gray-700 rounded mb-4 animate-pulse w-3/4&quot; /&gt;
      )}
      &lt;LoadingSkeleton lines={lines} /&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/ui/ReadingSourcesLoader.tsx">import React from &apos;react&apos;;

interface ReadingSourcesLoaderProps {
  className?: string;
}

export const ReadingSourcesLoader: React.FC&lt;ReadingSourcesLoaderProps&gt; = ({ className }) =&gt; {
  return (
    &lt;div className={`flex items-center justify-center p-4 ${className}`}&gt;
      &lt;div className=&quot;flex flex-col items-center space-y-3&quot;&gt;
        {/* Circular progress indicator */}
        &lt;div className=&quot;relative&quot;&gt;
          &lt;div className=&quot;w-8 h-8 border-4 border-gray-200 dark:border-gray-700 rounded-full&quot;&gt;&lt;/div&gt;
          &lt;div className=&quot;absolute top-0 left-0 w-8 h-8 border-4 border-blue-500 rounded-full border-t-transparent animate-spin&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        
        {/* Loading text */}
        &lt;div className=&quot;text-sm text-gray-600 dark:text-gray-400 font-medium&quot;&gt;
          Reading the sources
        &lt;/div&gt;
        
        {/* Animated dots */}
        &lt;div className=&quot;flex space-x-1&quot;&gt;
          &lt;div className=&quot;w-2 h-2 bg-gray-400 rounded-full animate-bounce&quot; style={{ animationDelay: &apos;0ms&apos; }}&gt;&lt;/div&gt;
          &lt;div className=&quot;w-2 h-2 bg-gray-400 rounded-full animate-bounce&quot; style={{ animationDelay: &apos;150ms&apos; }}&gt;&lt;/div&gt;
          &lt;div className=&quot;w-2 h-2 bg-gray-400 rounded-full animate-bounce&quot; style={{ animationDelay: &apos;300ms&apos; }}&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/ui/ResponseProgressBar.tsx">import React from &apos;react&apos;;

interface ResponseProgressBarProps {
  progress: number; // Progress percentage (0-100)
  currentStep: string; // Name of the current step
  className?: string;
}

export const ResponseProgressBar: React.FC&lt;ResponseProgressBarProps&gt; = ({ 
  progress, 
  currentStep, 
  className 
}) =&gt; {
  // Ensure progress is within bounds
  const clampedProgress = Math.min(100, Math.max(0, progress));
  
  return (
    &lt;div className={`max-w-[85%] sm:max-w-xs lg:max-w-md xl:max-w-lg mx-auto ${className}`}&gt;
      {/* &quot;Reading the sources&quot; text */}
      &lt;div className=&quot;text-sm text-gray-600 dark:text-gray-400 font-medium mb-3 text-center&quot;&gt;
        Reading the sources
      &lt;/div&gt;
      
      {/* Progress bar container */}
      &lt;div className=&quot;w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-3&quot;&gt;
        {/* Progress bar fill */}
        &lt;div 
          className=&quot;bg-blue-500 h-2.5 rounded-full transition-all duration-300 ease-out&quot;
          style={{ width: `${clampedProgress}%` }}
        &gt;&lt;/div&gt;
      &lt;/div&gt;
      
      {/* Current step name and percentage */}
      &lt;div className=&quot;flex justify-between items-center text-xs text-gray-500 dark:text-gray-400&quot;&gt;
        &lt;span className=&quot;truncate mr-2&quot;&gt;{currentStep}&lt;/span&gt;
        &lt;span className=&quot;font-medium&quot;&gt;{clampedProgress}%&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

// Predefined progress steps for easy reference
export const PROGRESS_STEPS = {
  QUERY_REWRITING: { name: &apos;Query Rewriting&apos;, percentage: 25 },
  EMBEDDING_GENERATION: { name: &apos;Embedding Generation&apos;, percentage: 50 },
  VECTOR_SEARCH: { name: &apos;Vector Search&apos;, percentage: 75 },
  RESPONSE_GENERATION: { name: &apos;Response Generation&apos;, percentage: 90 },
  RESPONSE_FORMATTING: { name: &apos;Response Formatting&apos;, percentage: 100 }
} as const;

// Helper function to get step info
export const getProgressStep = (step: keyof typeof PROGRESS_STEPS) =&gt; {
  return PROGRESS_STEPS[step];
};</file><file path="src/components/ui/Switch.tsx">import React, { forwardRef } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

export interface SwitchProps extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {
  checked?: boolean;
  onCheckedChange?: (checked: boolean) =&gt; void;
  disabled?: boolean;
  size?: &apos;sm&apos; | &apos;md&apos; | &apos;lg&apos;;
}

export const Switch = forwardRef&lt;HTMLButtonElement, SwitchProps&gt;(
  ({ className, checked = false, onCheckedChange, disabled = false, size = &apos;md&apos;, ...props }, ref) =&gt; {
    const handleClick = () =&gt; {
      if (!disabled &amp;&amp; onCheckedChange) {
        onCheckedChange(!checked);
      }
    };

    const sizeClasses = {
      sm: &apos;w-8 h-4&apos;,
      md: &apos;w-11 h-6&apos;,
      lg: &apos;w-14 h-8&apos;
    };

    const thumbSizeClasses = {
      sm: &apos;w-3 h-3&apos;,
      md: &apos;w-5 h-5&apos;,
      lg: &apos;w-6 h-6&apos;
    };

    const thumbTranslateClasses = {
      sm: checked ? &apos;translate-x-4&apos; : &apos;translate-x-0.5&apos;,
      md: checked ? &apos;translate-x-5&apos; : &apos;translate-x-0.5&apos;,
      lg: checked ? &apos;translate-x-6&apos; : &apos;translate-x-1&apos;
    };

    return (
      &lt;button
        type=&quot;button&quot;
        role=&quot;switch&quot;
        aria-checked={checked}
        disabled={disabled}
        className={clsx(
          &apos;relative inline-flex flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2&apos;,
          checked
            ? &apos;bg-blue-600 focus:ring-blue-500&apos;
            : &apos;bg-gray-200 dark:bg-gray-700 focus:ring-gray-500&apos;,
          disabled &amp;&amp; &apos;opacity-50 cursor-not-allowed&apos;,
          sizeClasses[size],
          className
        )}
        onClick={handleClick}
        ref={ref}
        {...props}
      &gt;
        &lt;span
          className={clsx(
            &apos;pointer-events-none inline-block rounded-full bg-white shadow transform ring-0 transition-transform duration-200 ease-in-out&apos;,
            thumbSizeClasses[size],
            thumbTranslateClasses[size]
          )}
        /&gt;
      &lt;/button&gt;
    );
  }
);

Switch.displayName = &apos;Switch&apos;;</file><file path="src/components/ui/TestModal.tsx">import React, { useEffect, useRef } from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;

interface TestModalProps {
  isOpen: boolean;
  onClose: () =&gt; void;
}

export const TestModal: React.FC&lt;TestModalProps&gt; = ({ isOpen, onClose }) =&gt; {
  const modalRef = useRef&lt;HTMLDivElement&gt;(null);

  useEffect(() =&gt; {
    console.log(&apos;üîç TestModal: isOpen changed&apos;, { isOpen });
    
    if (isOpen &amp;&amp; modalRef.current) {
      console.log(&apos;üîç TestModal: Modal mounted, checking visibility&apos;, {
        node: modalRef.current,
        offsetWidth: modalRef.current.offsetWidth,
        offsetHeight: modalRef.current.offsetHeight,
        offsetParent: modalRef.current.offsetParent,
        visibility: window.getComputedStyle(modalRef.current).visibility,
        display: window.getComputedStyle(modalRef.current).display,
        opacity: window.getComputedStyle(modalRef.current).opacity,
        position: window.getComputedStyle(modalRef.current).position,
        zIndex: window.getComputedStyle(modalRef.current).zIndex,
        computedStyle: window.getComputedStyle(modalRef.current).cssText
      });
    }
  }, [isOpen]);

  if (!isOpen) {
    console.log(&apos;üîç TestModal: isOpen is false, returning null&apos;);
    return null;
  }

  console.log(&apos;üîç TestModal: About to render test modal&apos;);

  const modalContent = (
    &lt;div 
      ref={modalRef}
      style={{
        position: &apos;fixed&apos;,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: &apos;rgba(0, 0, 0, 0.5)&apos;,
        zIndex: 99999,
        display: &apos;flex&apos;,
        alignItems: &apos;center&apos;,
        justifyContent: &apos;center&apos;,
        visibility: &apos;visible&apos;,
        opacity: 1
      }}
      onClick={onClose}
    &gt;
      &lt;div 
        style={{
          backgroundColor: &apos;white&apos;,
          padding: &apos;20px&apos;,
          borderRadius: &apos;8px&apos;,
          maxWidth: &apos;400px&apos;,
          width: &apos;90%&apos;,
          position: &apos;relative&apos;,
          zIndex: 100000
        }}
        onClick={(e) =&gt; e.stopPropagation()}
      &gt;
        &lt;h2 style={{ color: &apos;black&apos;, marginBottom: &apos;10px&apos; }}&gt;Test Modal&lt;/h2&gt;
        &lt;p style={{ color: &apos;black&apos;, marginBottom: &apos;20px&apos; }}&gt;This is a test modal to check if modals can render at all.&lt;/p&gt;
        &lt;button 
          onClick={onClose}
          style={{
            backgroundColor: &apos;#3b82f6&apos;,
            color: &apos;white&apos;,
            border: &apos;none&apos;,
            padding: &apos;8px 16px&apos;,
            borderRadius: &apos;4px&apos;,
            cursor: &apos;pointer&apos;
          }}
        &gt;
          Close
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );

  console.log(&apos;üîç TestModal: About to render via createPortal&apos;);
  
  // Render directly to document.body without creating a separate container
  return ReactDOM.createPortal(modalContent, document.body);
};

// Hook for testing the modal
export const useTestModal = () =&gt; {
  const [isOpen, setIsOpen] = React.useState(false);

  const openModal = () =&gt; {
    console.log(&apos;üîç useTestModal: Opening test modal&apos;);
    setIsOpen(true);
  };

  const closeModal = () =&gt; {
    console.log(&apos;üîç useTestModal: Closing test modal&apos;);
    setIsOpen(false);
  };

  const TestModalComponent = () =&gt; &lt;TestModal isOpen={isOpen} onClose={closeModal} /&gt;;

  return {
    openModal,
    closeModal,
    TestModal: TestModalComponent,
    isOpen
  };
};</file><file path="src/components/SubscriptionModal.tsx">&apos;use client&apos;

import { Fragment, useState, useEffect } from &apos;react&apos;
import { Dialog, Transition } from &apos;@headlessui/react&apos;
import { createClient } from &apos;@/utils/supabase/client&apos;

export default function SubscriptionModal() {
    const [open, setOpen] = useState(false)
    const [loading, setLoading] = useState(true)
    const supabase = createClient()

    useEffect(() =&gt; {
        async function checkSubscription() {
            const { data: { user } } = await supabase.auth.getUser()
            if (!user) {
                setLoading(false)
                return
            }

            const { data: profile } = await supabase
                .from(&apos;profiles&apos;)
                .select(&apos;*&apos;)
                .eq(&apos;id&apos;, user.id)
                .single()

            if (profile) {
                const now = new Date()
                const trialStart = new Date(profile.trial_start_date)
                const trialEnd = new Date(trialStart.getTime() + 30 * 24 * 60 * 60 * 1000) // 30 days
                const isSubscribed = profile.is_subscribed

                if (!isSubscribed &amp;&amp; now &gt; trialEnd) {
                    setOpen(true)
                }
            }
            setLoading(false)
        }

        checkSubscription()
    }, [])

    if (loading) return null

    return (
        &lt;Transition.Root show={open} as={Fragment}&gt;
            &lt;Dialog as=&quot;div&quot; className=&quot;relative z-50&quot; onClose={() =&gt; { }}&gt;
                &lt;Transition.Child
                    as={Fragment}
                    enter=&quot;ease-out duration-300&quot;
                    enterFrom=&quot;opacity-0&quot;
                    enterTo=&quot;opacity-100&quot;
                    leave=&quot;ease-in duration-200&quot;
                    leaveFrom=&quot;opacity-100&quot;
                    leaveTo=&quot;opacity-0&quot;
                &gt;
                    &lt;div className=&quot;fixed inset-0 bg-gray-900 bg-opacity-75 transition-opacity&quot; /&gt;
                &lt;/Transition.Child&gt;

                &lt;div className=&quot;fixed inset-0 z-10 w-screen overflow-y-auto&quot;&gt;
                    &lt;div className=&quot;flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0&quot;&gt;
                        &lt;Transition.Child
                            as={Fragment}
                            enter=&quot;ease-out duration-300&quot;
                            enterFrom=&quot;opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95&quot;
                            enterTo=&quot;opacity-100 translate-y-0 sm:scale-100&quot;
                            leave=&quot;ease-in duration-200&quot;
                            leaveFrom=&quot;opacity-100 translate-y-0 sm:scale-100&quot;
                            leaveTo=&quot;opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95&quot;
                        &gt;
                            &lt;Dialog.Panel className=&quot;relative transform overflow-hidden rounded-lg bg-white px-4 pb-4 pt-5 text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-sm sm:p-6&quot;&gt;
                                &lt;div&gt;
                                    &lt;div className=&quot;mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-indigo-100&quot;&gt;
                                        &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; strokeWidth={1.5} stroke=&quot;currentColor&quot; className=&quot;w-6 h-6 text-indigo-600&quot;&gt;
                                            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; d=&quot;M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z&quot; /&gt;
                                        &lt;/svg&gt;
                                    &lt;/div&gt;
                                    &lt;div className=&quot;mt-3 text-center sm:mt-5&quot;&gt;
                                        &lt;Dialog.Title as=&quot;h3&quot; className=&quot;text-base font-semibold leading-6 text-gray-900&quot;&gt;
                                            Free Trial Ended
                                        &lt;/Dialog.Title&gt;
                                        &lt;div className=&quot;mt-2&quot;&gt;
                                            &lt;p className=&quot;text-sm text-gray-500&quot;&gt;
                                                Your 1-month free trial has expired. To continue using the app, please subscribe.
                                            &lt;/p&gt;
                                        &lt;/div&gt;
                                    &lt;/div&gt;
                                &lt;/div&gt;
                                &lt;div className=&quot;mt-5 sm:mt-6&quot;&gt;
                                    &lt;a
                                        href=&quot;https://t.me/your_telegram_username&quot; // Replace with actual link or env var
                                        target=&quot;_blank&quot;
                                        rel=&quot;noopener noreferrer&quot;
                                        className=&quot;inline-flex w-full justify-center rounded-md bg-indigo-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600&quot;
                                    &gt;
                                        Contact for Subscription
                                    &lt;/a&gt;
                                &lt;/div&gt;
                            &lt;/Dialog.Panel&gt;
                        &lt;/Transition.Child&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/Dialog&gt;
        &lt;/Transition.Root&gt;
    )
}</file><file path="src/services/gemini/chatService.ts">import { geminiService } from &apos;./geminiService&apos;;
import type { Message } from &apos;@/types/message&apos;;
import type { VectorSearchResult } from &apos;@/types/embedding&apos;;
import type { AppSettings } from &apos;@/types/settings&apos;;

export interface ChatStreamEvent {
  type: &apos;start&apos; | &apos;chunk&apos; | &apos;citation&apos; | &apos;progress&apos; | &apos;thinking&apos; | &apos;end&apos; | &apos;error&apos; | &apos;status&apos; | &apos;textChunk&apos; | &apos;citations&apos; | &apos;done&apos;;
  content?: string;
  citation?: any;
  error?: string;
  message?: string;
  citations?: any[];
  progress?: {
    stage: &apos;embedding&apos; | &apos;searching&apos; | &apos;generating&apos; | &apos;processing&apos;;
    percentage: number;
    message: string;
  };
  metadata?: {
    tokensGenerated?: number;
    tokensPerSecond?: number;
    timeElapsed?: number;
  };
}

export class ChatService {
  async generateResponse(
    messages: Message[],
    context: VectorSearchResult[],
    settings: AppSettings
  ): Promise&lt;string&gt; {
    try {
      const contextText = this.buildContext(context);
      const prompt = this.buildPrompt(messages[messages.length - 1]?.content || &apos;&apos;, contextText);

      return await geminiService.generateResponse(
        prompt,
        undefined,
        undefined,
        {
          temperature: settings.temperature,
          maxTokens: settings.maxTokens,
        }
      );
    } catch (error) {
      console.error(&apos;Error generating chat response:&apos;, error);
      throw new Error(&apos;Failed to generate chat response&apos;);
    }
  }

  async generateStreamingResponse(
    messages: Message[],
    context: VectorSearchResult[],
    settings: AppSettings,
    onEvent: (event: ChatStreamEvent) =&gt; void
  ): Promise&lt;void&gt; {
    try {
      const contextText = this.buildContext(context);
      const prompt = this.buildPrompt(messages[messages.length - 1]?.content || &apos;&apos;, contextText);

      onEvent({ type: &apos;start&apos; });

      const stream = await geminiService.generateStreamingResponse(
        prompt,
        undefined,
        undefined,
        {
          temperature: settings.temperature,
          maxTokens: settings.maxTokens,
          onChunk: (chunk: string) =&gt; {
            onEvent({ type: &apos;chunk&apos;, content: chunk });
          },
        }
      );

      // Process the stream
      let fullResponse = &apos;&apos;;
      for await (const chunk of stream) {
        fullResponse += chunk;
      }

      // Extract citations if needed
      const citations = this.extractCitations(fullResponse, context);
      if (citations.length &gt; 0) {
        onEvent({ type: &apos;citation&apos;, citation: citations });
      }

      onEvent({ type: &apos;end&apos; });
    } catch (error) {
      console.error(&apos;Error generating streaming response:&apos;, error);
      onEvent({ 
        type: &apos;error&apos;, 
        error: error instanceof Error ? error.message : &apos;Unknown error occurred&apos; 
      });
    }
  }

  private buildPrompt(userMessage: string, context: string): string {
    if (!context) {
      return `I cannot answer this question as no document context has been provided. Please upload relevant documents first.

Question: ${userMessage}`;
    }

    return `CRITICAL INSTRUCTIONS - READ CAREFULLY:
1. You MUST ONLY use information from the provided context below
2. You are FORBIDDEN from using any general knowledge or external information
3. If the context does not contain the answer, you MUST respond with &quot;I cannot answer this question based on the provided documents.&quot;
4. Do NOT attempt to answer questions about topics not covered in the context
5. NEVER answer questions about current events, politics, celebrities, or general knowledge not in the documents
6. Every single statement you make must be directly supported by the provided context

CRITICAL CITATION ACCURACY REQUIREMENTS:
- BEFORE citing any source, VERIFY that the information you&apos;re presenting actually appears in that source
- Each citation [number] MUST reference a source that CONTAINS the specific information you&apos;re citing
- NEVER cite a source that discusses a different topic, even if it&apos;s related
- Example: If you&apos;re defining &quot;cataract&quot;, ONLY cite sources that actually contain the cataract definition
- DO NOT cite sources about ophthalmoscopy or ultrasound when defining cataract
- Read each source carefully and ensure the content matches what you&apos;re claiming
- If you&apos;re unsure whether a source contains the information, DO NOT cite it
- It is BETTER to have fewer citations than to cite irrelevant sources

CITATION VERIFICATION PROCESS:
1. Make a factual claim
2. IMMEDIATELY check if the source [number] actually contains this information
3. If YES, add the citation
4. If NO, either find the correct source or remove the claim
5. Double-check: Does source [number] really say what I&apos;m claiming?

VANCOUVER CITATION STYLE:
- Use numbered citations in square brackets: [1], [2], [3]
- Citations must be numbered sequentially in order they appear
- Place citations immediately after the information they support
- Every factual statement must have a citation
- Citations are mandatory for all claims
- WARNING: Citing incorrect sources will mislead users and is unacceptable

Context Documents:
${context}

Question: ${userMessage}

Remember: Answer ONLY using the provided context with proper Vancouver style citations. CITATION ACCURACY IS YOUR HIGHEST PRIORITY. If the context doesn&apos;t contain the answer, say so explicitly.`;
  }

  private buildContext(contextResults: VectorSearchResult[]): string {
    if (contextResults.length === 0) {
      return &apos;&apos;;
    }

    return contextResults
      .map((result, index) =&gt; {
        const { chunk, document } = result;
        const source = document.title || document.fileName;
        const page = chunk.metadata.pageNumber ? ` (Page ${chunk.metadata.pageNumber})` : &apos;&apos;;
        
        // Handle combined chunks with special formatting
        let contentPrefix = &apos;&apos;;
        if (chunk.metadata.isCombined) {
          const chunkCount = chunk.metadata.originalChunkCount || 1;
          contentPrefix = `[Combined from ${chunkCount} chunks on this page]\n`;
        }
        
        return `[${index + 1}] From &quot;${source}&quot;${page}:
${contentPrefix}${chunk.content}`;
      })
      .join(&apos;\n\n&apos;);
  }

  private extractCitations(response: string, context: VectorSearchResult[]): any[] {
    // Enhanced citation extraction with validation
    const citationPattern = /\[(\d+)\]/g;
    const citations: any[] = [];
    const usedIndices = new Set&lt;number&gt;();
    let match;
    
    while ((match = citationPattern.exec(response)) !== null) {
      const originalIndex = parseInt(match[1], 10);
      const zeroBasedIndex = originalIndex - 1; // Convert to 0-based index
      
      // Validate citation index is within range
      if (zeroBasedIndex &gt;= 0 &amp;&amp; zeroBasedIndex &lt; context.length) {
        const result = context[zeroBasedIndex];
        
        // Skip duplicates
        const citationKey = `${result.document.title || result.document.fileName}_${result.chunk.metadata?.pageNumber || &apos;unknown&apos;}`;
        if (!usedIndices.has(zeroBasedIndex)) {
          usedIndices.add(zeroBasedIndex);
          
          // Create citation with enhanced metadata for combined chunks
          const citation: any = {
            document: result.document.title || result.document.fileName,
            page: result.chunk.metadata.pageNumber,
            excerpt: result.chunk.content, // Use full content (which may be combined)
            sourceIndex: originalIndex,
            chunkId: result.chunk.id,
          };
          
          // Add combined chunk metadata if applicable
          if (result.chunk.metadata.isCombined) {
            citation.isCombined = true;
            citation.originalChunkCount = result.chunk.metadata.originalChunkCount;
            citation.combinedChunkIds = result.chunk.metadata.combinedChunkIds;
          }
          
          citations.push(citation);
        }
      } else {
        console.warn(`Invalid citation [${originalIndex}]: Index out of range (available: 1-${context.length})`);
      }
    }

    return citations;
  }

  async validateResponse(response: string): Promise&lt;boolean&gt; {
    try {
      // Basic validation checks
      if (!response || response.trim().length === 0) {
        return false;
      }

      // Check for reasonable length
      if (response.length &gt; 10000) {
        return false;
      }

      // Check for coherent text (basic check)
      const words = response.split(/\s+/);
      if (words.length &lt; 3) {
        return false;
      }

      return true;
    } catch (error) {
      console.error(&apos;Error validating response:&apos;, error);
      return false;
    }
  }

  formatResponse(response: string, citations: any[] = []): string {
    let formatted = response;

    // Add citation sources at the end if citations exist
    if (citations.length &gt; 0) {
      formatted += &apos;\n\nSources:\n&apos;;
      citations.forEach((citation, index) =&gt; {
        const pageInfo = citation.page ? `, Page ${citation.page}` : &apos;&apos;;
        formatted += `${index + 1}. ${citation.document}${pageInfo}\n`;
      });
    }

    return formatted;
  }

  async generateTitle(firstMessage: string): Promise&lt;string&gt; {
    try {
      const prompt = `Generate a short, descriptive title (max 5 words) for a conversation that starts with this message: &quot;${firstMessage}&quot;`;
      
      const title = await geminiService.generateResponse(prompt);
      
      // Clean up and truncate if needed
      return title
        .replace(/^[&quot;&apos;]|[&quot;&apos;]$/g, &apos;&apos;) // Remove quotes
        .substring(0, 50)
        .trim();
    } catch (error) {
      console.error(&apos;Error generating title:&apos;, error);
      // Fallback to first few words of the message
      return firstMessage
        .split(/\s+/)
        .slice(0, 5)
        .join(&apos; &apos;)
        .substring(0, 50);
    }
  }

  /**
   * Estimate token count from text (rough approximation)
   */
  private estimateTokenCount(text: string): number {
    // Rough estimation: ~4 characters per token for English
    return Math.ceil(text.length / 4);
  }

  /**
   * Validate streaming response in real-time
   */
  private validateStreamingChunk(chunk: string, fullResponse: string): {
    isValid: boolean;
    warnings: string[];
  } {
    const warnings: string[] = [];
    let isValid = true;

    // Check for repeated content (possible loops)
    if (fullResponse.length &gt; 100 &amp;&amp; chunk.length &gt; 0) {
      const recentText = fullResponse.slice(-100);
      if (recentText.includes(chunk) &amp;&amp; chunk.length &gt; 10) {
        warnings.push(&apos;Possible content repetition detected&apos;);
        isValid = false;
      }
    }

    // Check for excessive citation density
    const citationMatches = (fullResponse + chunk).match(/\[\d+\]/g);
    if (citationMatches &amp;&amp; citationMatches.length &gt; 10) {
      warnings.push(&apos;High citation density detected&apos;);
    }

    return { isValid, warnings };
  }

  /**
   * Detect if response is getting too long
   */
  private isResponseTooLong(response: string, maxTokens: number): boolean {
    const estimatedTokens = this.estimateTokenCount(response);
    return estimatedTokens &gt; maxTokens * 0.9; // 90% of max tokens
  }

  /**
   * Extract citations in real-time as they appear with validation
   */
  private extractCitationsRealTime(text: string, context: VectorSearchResult[]): Array&lt;{
    index: number;
    position: number;
    citation: any;
  }&gt; {
    const citationPattern = /\[(\d+)\]/g;
    const citations: Array&lt;{ index: number; position: number; citation: any }&gt; = [];
    const usedIndices = new Set&lt;number&gt;();
    let match;

    while ((match = citationPattern.exec(text)) !== null) {
      const originalIndex = parseInt(match[1], 10);
      const zeroBasedIndex = originalIndex - 1; // Convert to 0-based index
      
      // Validate citation index
      if (zeroBasedIndex &gt;= 0 &amp;&amp; zeroBasedIndex &lt; context.length) {
        // Skip duplicates
        if (!usedIndices.has(zeroBasedIndex)) {
          usedIndices.add(zeroBasedIndex);
          const result = context[zeroBasedIndex];
          
          // Create citation with enhanced metadata for combined chunks
          const citation: any = {
            document: result.document.title || result.document.fileName,
            page: result.chunk.metadata.pageNumber,
            excerpt: result.chunk.content, // Use full content (which may be combined)
            sourceIndex: originalIndex,
            chunkId: result.chunk.id,
          };
          
          // Add combined chunk metadata if applicable
          if (result.chunk.metadata.isCombined) {
            citation.isCombined = true;
            citation.originalChunkCount = result.chunk.metadata.originalChunkCount;
            citation.combinedChunkIds = result.chunk.metadata.combinedChunkIds;
          }
          
          citations.push({
            index: originalIndex, // Keep 1-based for display
            position: match.index,
            citation,
          });
        }
      } else {
        console.warn(`Invalid citation [${originalIndex}] in real-time extraction: Index out of range (available: 1-${context.length})`);
      }
    }

    return citations;
  }
}

// Singleton instance
export const chatService = new ChatService();</file><file path="src/services/gemini/embeddingService.ts">import { geminiService } from &apos;./geminiService&apos;;
import type { EmbeddingChunk } from &apos;@/types/embedding&apos;;
import type { Document } from &apos;@/types/document&apos;;

export class EmbeddingService {
  async generateEmbedding(text: string): Promise&lt;Float32Array&gt; {
    try {
      return await geminiService.embedText(text);
    } catch (error) {
      console.error(&apos;Error generating embedding:&apos;, error);
      throw new Error(&apos;Failed to generate embedding&apos;);
    }
  }

  async generateEmbeddingsBatch(texts: string[]): Promise&lt;Float32Array[]&gt; {
    try {
      return await geminiService.embedBatch(texts);
    } catch (error) {
      console.error(&apos;Error generating batch embeddings:&apos;, error);
      throw new Error(&apos;Failed to generate batch embeddings&apos;);
    }
  }

  async processDocumentChunks(
    document: Document,
    chunks: Array&lt;{
      id: string;
      text: string;
      metadata?: any;
    }&gt;
  ): Promise&lt;EmbeddingChunk[]&gt; {
    try {
      const texts = chunks.map(chunk =&gt; chunk.text);
      const embeddings = await this.generateEmbeddingsBatch(texts);

      return chunks.map((chunk, index) =&gt; ({
        id: chunk.id,
        documentId: document.id,
        sessionId: document.sessionId,
        chunkIndex: index,
        content: chunk.text,
        source: document.filename,
        page: chunk.metadata?.page,
        embedding: embeddings[index],
        tokenCount: this.estimateTokenCount(chunk.text),
        embeddingNorm: this.calculateNorm(embeddings[index]),
        metadata: {
          pageNumber: chunk.metadata?.page,
          chunkIndex: index,
          startPosition: 0, // TODO: Calculate actual position
          endPosition: chunk.text.length,
          tokenCount: this.estimateTokenCount(chunk.text),
        },
        createdAt: new Date(),
      }));
    } catch (error) {
      console.error(&apos;Error processing document chunks:&apos;, error);
      throw new Error(&apos;Failed to process document chunks&apos;);
    }
  }

  private estimateTokenCount(text: string): number {
    // Rough estimation: ~4 characters per token
    return Math.ceil(text.length / 4);
  }

  private calculateNorm(vector: Float32Array): number {
    let sum = 0;
    for (let i = 0; i &lt; vector.length; i++) {
      sum += vector[i] * vector[i];
    }
    return Math.sqrt(sum);
  }

  async validateEmbedding(embedding: Float32Array): Promise&lt;boolean&gt; {
    try {
      // Check if embedding has valid dimensions (should be 768 for gemini-embedding-001)
      if (embedding.length !== 768) {
        return false;
      }

      // Check for NaN or Infinity values
      for (let i = 0; i &lt; embedding.length; i++) {
        if (!isFinite(embedding[i])) {
          return false;
        }
      }

      // Check if embedding norm is reasonable (not all zeros)
      const norm = this.calculateNorm(embedding);
      return norm &gt; 0;
    } catch (error) {
      console.error(&apos;Error validating embedding:&apos;, error);
      return false;
    }
  }

  normalizeEmbedding(embedding: Float32Array): Float32Array {
    const norm = this.calculateNorm(embedding);
    if (norm === 0) {
      return embedding; // Avoid division by zero
    }

    const normalized = new Float32Array(embedding.length);
    for (let i = 0; i &lt; embedding.length; i++) {
      normalized[i] = embedding[i] / norm;
    }

    return normalized;
  }

  async generateEmbeddingWithRetry(
    text: string,
    maxRetries: number = 3
  ): Promise&lt;Float32Array&gt; {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {
      try {
        const embedding = await this.generateEmbedding(text);
        
        if (await this.validateEmbedding(embedding)) {
          return embedding;
        } else {
          throw new Error(&apos;Generated embedding failed validation&apos;);
        }
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(&apos;Unknown error&apos;);
        
        if (attempt === maxRetries) {
          break;
        }

        // Exponential backoff
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve =&gt; setTimeout(resolve, delay));
      }
    }

    throw lastError || new Error(&apos;Failed to generate embedding after retries&apos;);
  }
}

// Singleton instance
export const embeddingService = new EmbeddingService();</file><file path="src/services/gemini/geminiService.ts">import { GoogleGenAI } from &apos;@google/genai&apos;;
import type { AppSettings, ApiKeyValidationResult } from &apos;@/types/settings&apos;;

export class GeminiService {
  private genAI: GoogleGenAI | null = null;
  private modelName: string = &apos;gemini-2.5-flash-lite&apos;;
  private embeddingModelName: string = &apos;text-embedding-004&apos;;

  initialize(apiKey: string, modelName: string = &apos;gemini-2.5-flash-lite&apos;, embeddingModelName: string = &apos;text-embedding-004&apos;) {
    try {
      console.log(&apos;[GEMINI INIT]&apos;, &apos;Starting Gemini service initialization with new SDK&apos;);
      console.log(&apos;[GEMINI INIT]&apos;, `API Key provided: ${apiKey ? &apos;YES&apos; : &apos;NO&apos;}`);
      console.log(&apos;[GEMINI INIT]&apos;, `Requested model name: ${modelName}`);
      console.log(&apos;[GEMINI INIT]&apos;, `Embedding model name: ${embeddingModelName}`);
      console.log(&apos;[GEMINI INIT]&apos;, `SDK Version: ${this.getSDKVersion()}`);
      
      this.genAI = new GoogleGenAI({ apiKey });
      this.modelName = modelName;
      this.embeddingModelName = embeddingModelName;
      
      console.log(&apos;[GEMINI INIT]&apos;, `GoogleGenAI instance created for model: ${modelName}`);
      console.log(&apos;[GEMINI INIT]&apos;, `Embedding model configured: ${embeddingModelName}`);
      console.log(&apos;[GEMINI INIT]&apos;, &apos;Gemini service initialization completed successfully&apos;);
    } catch (error) {
      console.error(&apos;[GEMINI INIT ERROR]&apos;, &apos;Failed to initialize Gemini:&apos;, error);
      console.error(&apos;[GEMINI INIT ERROR]&apos;, &apos;Error details:&apos;, {
        message: error instanceof Error ? error.message : String(error),
        status: (error as any)?.status,
        statusText: (error as any)?.statusText,
        stack: error instanceof Error ? error.stack : undefined
      });
      throw new Error(&apos;Failed to initialize Gemini API&apos;);
    }
  }

  private getSDKVersion(): string {
    try {
      // Try to get version from package.json or other sources
      return &apos;0.2.0&apos;; // From package.json
    } catch {
      return &apos;unknown&apos;;
    }
  }

  private ensureInitialized() {
    if (!this.genAI) {
      throw new Error(&apos;Gemini service not initialized. Call initialize() first.&apos;);
    }
  }

  async generateResponse(
    prompt: string,
    context?: string,
    systemPrompt?: string,
    options?: {
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise&lt;string&gt; {
    this.ensureInitialized();

    try {
      let fullPrompt = &apos;&apos;;
      
      if (systemPrompt) {
        fullPrompt += `System: ${systemPrompt}\n\n`;
      }
      
      if (context) {
        fullPrompt += `Context:\n${context}\n\n`;
      }
      
      fullPrompt += `User: ${prompt}`;

      const generationConfig = {
        temperature: options?.temperature || 0.7,
        maxOutputTokens: options?.maxTokens || 4096,
      };

      const result = await this.genAI!.models.generateContent({
        model: this.modelName,
        contents: fullPrompt,
        config: generationConfig
      });
      return result.candidates?.[0]?.content?.parts?.[0]?.text || &apos;&apos;;
    } catch (error) {
      console.error(&apos;Error generating response:&apos;, error);
      throw new Error(&apos;Failed to generate response from Gemini&apos;);
    }
  }

  async generateStreamingResponse(
    prompt: string,
    context?: string,
    systemPrompt?: string,
    options?: {
      temperature?: number;
      maxTokens?: number;
      onChunk?: (chunk: string) =&gt; void;
    }
  ): Promise&lt;AsyncIterable&lt;string&gt;&gt; {
    this.ensureInitialized();

    try {
      let fullPrompt = &apos;&apos;;
      
      if (systemPrompt) {
        fullPrompt += `System: ${systemPrompt}\n\n`;
      }
      
      if (context) {
        fullPrompt += `Context:\n${context}\n\n`;
      }
      
      fullPrompt += `User: ${prompt}`;

      const generationConfig = {
        temperature: options?.temperature || 0.7,
        maxOutputTokens: options?.maxTokens || 4096,
      };

      console.log(&apos;[GEMINI STREAM]&apos;, &apos;Starting streaming response generation&apos;);
      console.log(&apos;[GEMINI STREAM]&apos;, `Prompt length: ${fullPrompt.length} characters`);
      console.log(&apos;[GEMINI STREAM]&apos;, `Model being used: ${this.modelName || &apos;unknown&apos;}`);
      console.log(&apos;[GEMINI STREAM]&apos;, `Temperature: ${generationConfig.temperature}`);
      console.log(&apos;[GEMINI STREAM]&apos;, `Max tokens: ${generationConfig.maxOutputTokens}`);
      
      const result = await this.genAI!.models.generateContentStream({
        model: this.modelName,
        contents: fullPrompt,
        config: generationConfig
      });
      
      console.log(&apos;[GEMINI STREAM]&apos;, &apos;Stream created successfully&apos;);
      return this.createStreamingIterable(result, options?.onChunk);
    } catch (error) {
      console.error(&apos;[GEMINI STREAM ERROR]&apos;, &apos;Error generating streaming response:&apos;, error);
      console.error(&apos;[GEMINI STREAM ERROR]&apos;, &apos;Error details:&apos;, {
        message: error instanceof Error ? error.message : String(error),
        status: (error as any)?.status,
        statusText: (error as any)?.statusText,
        stack: error instanceof Error ? error.stack : undefined
      });
      throw new Error(&apos;Failed to generate streaming response from Gemini&apos;);
    }
  }

  private async *createStreamingIterable(
    result: AsyncIterable&lt;any&gt;,
    onChunk?: (chunk: string) =&gt; void
  ): AsyncIterable&lt;string&gt; {
    for await (const chunk of result) {
      const chunkText = chunk.candidates?.[0]?.content?.parts?.[0]?.text || &apos;&apos;;
      if (chunkText) {
        onChunk?.(chunkText);
        yield chunkText;
      }
    }
  }

  async embedText(text: string): Promise&lt;Float32Array&gt; {
    this.ensureInitialized();

    try {
      const result = await this.genAI!.models.embedContent({
        model: this.embeddingModelName,
        contents: text
      });
      const embedding = result.embeddings?.[0];
      const values = embedding?.values || [];
      return new Float32Array(values);
    } catch (error) {
      console.error(&apos;Error embedding text:&apos;, error);
      throw new Error(&apos;Failed to embed text with Gemini&apos;);
    }
  }

  async embedBatch(texts: string[]): Promise&lt;Float32Array[]&gt; {
    this.ensureInitialized();

    try {
      const embeddings = await Promise.all(
        texts.map(text =&gt; this.embedText(text))
      );
      return embeddings;
    } catch (error) {
      console.error(&apos;Error embedding batch:&apos;, error);
      throw new Error(&apos;Failed to embed batch with Gemini&apos;);
    }
  }

  async validateApiKey(apiKey: string): Promise&lt;ApiKeyValidationResult&gt; {
    const startTime = Date.now();
    
    try {
      // Check if API key format is valid (basic validation)
      if (!apiKey || typeof apiKey !== &apos;string&apos; || apiKey.trim().length === 0) {
        return {
          isValid: false,
          error: {
            type: &apos;INVALID_KEY&apos;,
            message: &apos;API key is required and must be a valid string&apos;
          },
          responseTime: Date.now() - startTime
        };
      }

      // Check for basic Gemini API key format (starts with &apos;AIza&apos;)
      if (!apiKey.startsWith(&apos;AIza&apos;)) {
        return {
          isValid: false,
          error: {
            type: &apos;INVALID_KEY&apos;,
            message: &apos;Invalid API key format. Gemini API keys typically start with &quot;AIza&quot;&apos;
          },
          responseTime: Date.now() - startTime
        };
      }

      const tempGenAI = new GoogleGenAI({ apiKey });
      
      // Try a simple generation to validate the key
      const result = await tempGenAI.models.generateContent({
        model: &apos;gemini-2.5-flash-lite&apos;,
        contents: &apos;Hello&apos;
      });
      
      return {
        isValid: true,
        responseTime: Date.now() - startTime
      };
    } catch (error: any) {
      const responseTime = Date.now() - startTime;
      console.error(&apos;API key validation failed:&apos;, error);
      
      // Parse different types of errors
      if (error.status === 400) {
        return {
          isValid: false,
          error: {
            type: &apos;INVALID_KEY&apos;,
            message: &apos;Invalid API key. Please check your key and try again.&apos;,
            details: error.message
          },
          responseTime
        };
      } else if (error.status === 403) {
        return {
          isValid: false,
          error: {
            type: &apos;PERMISSION_DENIED&apos;,
            message: &apos;Permission denied. The API key might not have access to the Gemini API.&apos;,
            details: error.message
          },
          responseTime
        };
      } else if (error.status === 429) {
        return {
          isValid: false,
          error: {
            type: &apos;QUOTA_EXCEEDED&apos;,
            message: &apos;API quota exceeded. Please check your usage limits and try again later.&apos;,
            details: error.message
          },
          responseTime
        };
      } else if (error.code === &apos;ECONNRESET&apos; || error.code === &apos;ENOTFOUND&apos; || error.code === &apos;ETIMEDOUT&apos;) {
        return {
          isValid: false,
          error: {
            type: &apos;NETWORK_ERROR&apos;,
            message: &apos;Network error. Please check your internet connection and try again.&apos;,
            details: error.message
          },
          responseTime
        };
      } else {
        return {
          isValid: false,
          error: {
            type: &apos;UNKNOWN_ERROR&apos;,
            message: &apos;An unexpected error occurred while validating the API key.&apos;,
            details: error.message || String(error)
          },
          responseTime
        };
      }
    }
  }


  isInitialized(): boolean {
    return this.genAI !== null;
  }
}

// Singleton instance
export const geminiService = new GeminiService();</file><file path="src/services/gemini/index.ts">// Gemini API services
export { geminiService } from &apos;./geminiService&apos;;
export { embeddingService } from &apos;./embeddingService&apos;;
export { chatService, type ChatStreamEvent } from &apos;./chatService&apos;;

// Service factory for easy dependency injection
export class GeminiServiceFactory {
  private static initialized = false;

  static async initialize(apiKey: string, modelName?: string, embeddingModelName?: string): Promise&lt;void&gt; {
    if (this.initialized) {
      return;
    }

    try {
      const { geminiService } = await import(&apos;./geminiService&apos;);
      geminiService.initialize(apiKey, modelName, embeddingModelName);
      this.initialized = true;
    } catch (error) {
      console.error(&apos;Failed to initialize Gemini services:&apos;, error);
      throw error;
    }
  }

  static isInitialized(): boolean {
    return this.initialized;
  }

  static reset(): void {
    this.initialized = false;
  }
}

// Export convenience functions
export const initializeGeminiServices = GeminiServiceFactory.initialize;
export const isGeminiInitialized = GeminiServiceFactory.isInitialized;
export const resetGeminiServices = GeminiServiceFactory.reset;</file><file path="src/services/indexedDB/documentService.ts">import { db } from &apos;./db&apos;;
import type { Document, DocumentCreate, DocumentUpdate } from &apos;@/types&apos;;
import { ensureDate } from &apos;@/utils/date&apos;;
import { userIdLogger } from &apos;@/utils/userIdDebugLogger&apos;;

export class DocumentService {
  /**
   * Create a new document
   */
  async createDocument(data: DocumentCreate, userId: string): Promise&lt;Document&gt; {
    userIdLogger.logServiceCall(&apos;documentService&apos;, &apos;createDocument&apos;, &apos;create&apos;, userId);
    
    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: createDocument called with:&apos;, {
      id: data.id,
      sessionId: data.sessionId,
      filename: data.filename,
      status: &apos;pending&apos;,
      userId
    });

    if (!db) throw new Error(&apos;Database not available&apos;);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;documentService.createDocument&apos;, new Error(&apos;Attempt to create document without userId&apos;), userId);
      throw new Error(&apos;userId is required to create a document&apos;);
    }
    
    const document: Document = {
      id: data.id || crypto.randomUUID(), // Allow custom ID for JSON imports
      userId,
      sessionId: data.sessionId,
      filename: data.filename,
      fileSize: data.fileSize,
      status: &apos;pending&apos;,
      pageCount: data.pageCount,
      processedAt: data.processedAt,
      createdAt: new Date(),
      enabled: true,
      originalPath: data.originalPath,
      storedPath: data.storedPath,
      mimeType: data.mimeType,
      checksum: data.checksum,
      title: data.title,
      author: data.author,
      language: data.language,
      ingestError: data.ingestError,
    };

    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Document object to be added:&apos;, {
      id: document.id,
      sessionId: document.sessionId,
      filename: document.filename,
      status: document.status,
      enabled: document.enabled
    });

    await db.documents.add(document);

    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Document added to database, verifying...&apos;);

    // Verify the document was actually added
    const verifyDoc = await db.documents.get(document.id);
    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Verification - document in database:&apos;, {
      found: !!verifyDoc,
      id: verifyDoc?.id,
      sessionId: verifyDoc?.sessionId,
      filename: verifyDoc?.filename,
      status: verifyDoc?.status,
      enabled: verifyDoc?.enabled
    });

    return document;
  }

  /**
   * Get all documents for a session
   */
  async getDocumentsBySession(sessionId: string, userId: string): Promise&lt;Document[]&gt; {
    userIdLogger.logServiceCall(&apos;documentService&apos;, &apos;getDocumentsBySession&apos;, &apos;read&apos;, userId);
    
    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: getDocumentsBySession called with:&apos;, { sessionId, userId });

    if (!db) {
      console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Database not available, returning empty array&apos;);
      return [];
    }

    if (!userId) {
      userIdLogger.logError(&apos;documentService.getDocumentsBySession&apos;, new Error(&apos;Attempt to get documents without userId&apos;), userId);
      console.log(&apos;üîç DOCUMENT SERVICE DEBUG: No userId provided, returning empty array&apos;);
      return [];
    }

    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Querying documents for session:&apos;, sessionId, &apos;and user:&apos;, userId);

    // First, let&apos;s check all documents in the database
    const allDocs = await db.documents.toArray();
    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: ALL documents in database:&apos;, {
      totalCount: allDocs.length,
      documents: allDocs.map(doc =&gt; ({
        id: doc.id,
        sessionId: doc.sessionId,
        userId: doc.userId,
        filename: doc.filename,
        status: doc.status,
        enabled: doc.enabled
      }))
    });

    // Now check the specific session query with userId filter
    const documents = await db.documents
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .and((doc: Document) =&gt; doc.userId === userId)
      .sortBy(&apos;createdAt&apos;);

    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Raw documents from database:&apos;, {
      count: documents.length,
      documents: documents.map(doc =&gt; ({
        id: doc.id,
        filename: doc.filename,
        status: doc.status,
        enabled: doc.enabled,
        sessionId: doc.sessionId,
        userId: doc.userId
      }))
    });

    // Ensure date fields are Date objects (handles IndexedDB serialization)
    const processedDocuments = documents.map(document =&gt; ({
      ...document,
      createdAt: ensureDate(document.createdAt),
      processedAt: document.processedAt ? ensureDate(document.processedAt) : undefined
    }));

    console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Processed documents to return:&apos;, {
      count: processedDocuments.length,
      documents: processedDocuments.map(doc =&gt; ({
        id: doc.id,
        filename: doc.filename,
        status: doc.status,
        enabled: doc.enabled,
        sessionId: doc.sessionId,
        userId: doc.userId,
        processedAt: doc.processedAt
      }))
    });

    return processedDocuments;
  }

  /**
   * Get enabled documents for a session
   */
  async getEnabledDocumentsBySession(sessionId: string, userId: string): Promise&lt;Document[]&gt; {
    if (!db) return [];
    if (!userId) return [];
    
    const documents = await db.documents
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .and((doc: Document) =&gt; doc.enabled === true &amp;&amp; doc.userId === userId)
      .sortBy(&apos;createdAt&apos;);

    // Ensure date fields are Date objects (handles IndexedDB serialization)
    return documents.map(document =&gt; ({
      ...document,
      createdAt: ensureDate(document.createdAt),
      processedAt: document.processedAt ? ensureDate(document.processedAt) : undefined
    }));
  }

  /**
   * Get a specific document by ID
   */
  async getDocument(id: string, userId?: string): Promise&lt;Document | undefined&gt; {
    userIdLogger.logServiceCall(&apos;documentService&apos;, &apos;getDocument&apos;, &apos;read&apos;, userId || null);
    
    if (!db) return undefined;
    const document = await db.documents.get(id);
    if (!document) return undefined;
    
    // If userId is provided, verify ownership
    if (userId &amp;&amp; document.userId !== userId) {
      userIdLogger.logError(&apos;documentService.getDocument&apos;, new Error(&apos;Attempt to access document belonging to different user&apos;), userId);
      console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Access denied - document belongs to different user&apos;);
      return undefined;
    }

    // Ensure date fields are Date objects (handles IndexedDB serialization)
    return {
      ...document,
      createdAt: ensureDate(document.createdAt),
      processedAt: document.processedAt ? ensureDate(document.processedAt) : undefined
    };
  }

  /**
   * Update a document
   */
  async updateDocument(id: string, updates: DocumentUpdate, userId?: string): Promise&lt;void&gt; {
    if (!db) return;
    const existing = await db.documents.get(id);
    if (!existing) return;
    
    // If userId is provided, verify ownership
    if (userId &amp;&amp; existing.userId !== userId) {
      console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Update denied - document belongs to different user&apos;);
      return;
    }
    
    const updated = { ...existing, ...updates };
    await db.documents.put(updated);
  }

  /**
   * Update document status
   */
  async updateDocumentStatus(id: string, status: Document[&apos;status&apos;], error?: string, userId?: string): Promise&lt;void&gt; {
    if (!db) return;
    await this.updateDocument(id, {
      status,
      ingestError: error,
      processedAt: status === &apos;completed&apos; ? new Date() : undefined
    }, userId);
  }

  /**
   * Toggle document enabled status
   */
  async toggleDocumentEnabled(id: string, userId?: string): Promise&lt;void&gt; {
    const document = await this.getDocument(id, userId);
    if (document) {
      await this.updateDocument(id, { enabled: !document.enabled }, userId);
    }
  }

  /**
   * Delete a document and its embeddings
   */
  async deleteDocument(id: string, userId?: string): Promise&lt;void&gt; {
    userIdLogger.logServiceCall(&apos;documentService&apos;, &apos;deleteDocument&apos;, &apos;delete&apos;, userId || null);
    
    if (!db) return;
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;documentService.deleteDocument&apos;, new Error(&apos;Attempt to delete document without userId&apos;), userId || null);
      console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Delete denied - no userId provided&apos;);
      return;
    }
    
    // Verify ownership before deletion
    const document = await this.getDocument(id, userId);
    if (!document) {
      userIdLogger.logError(&apos;documentService.deleteDocument&apos;, new Error(&apos;Delete denied - document not found or access denied&apos;), userId);
      console.log(&apos;üîç DOCUMENT SERVICE DEBUG: Delete denied - document not found or access denied&apos;);
      return;
    }
    
    await db.transaction(&apos;rw&apos;, db.documents, db.embeddings, async () =&gt; {
      // Delete document
      await db!.documents.delete(id);

      // Delete related embeddings
      await db!.embeddings.where(&apos;documentId&apos;).equals(id).delete();
    });
  }

  /**
   * Get document count for a session
   */
  async getDocumentCount(sessionId: string, userId: string): Promise&lt;number&gt; {
    if (!db) return 0;
    if (!userId) return 0;
    return await db.documents
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .and((doc: Document) =&gt; doc.userId === userId)
      .count();
  }

  /**
   * Get documents by status
   */
  async getDocumentsByStatus(sessionId: string, status: Document[&apos;status&apos;], userId: string): Promise&lt;Document[]&gt; {
    if (!db) return [];
    if (!userId) return [];
    
    const documents = await db.documents
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .and((doc: Document) =&gt; doc.status === status &amp;&amp; doc.userId === userId)
      .sortBy(&apos;createdAt&apos;);

    // Ensure date fields are Date objects (handles IndexedDB serialization)
    return documents.map(document =&gt; ({
      ...document,
      createdAt: ensureDate(document.createdAt),
      processedAt: document.processedAt ? ensureDate(document.processedAt) : undefined
    }));
  }

  /**
   * Get processing documents for a session
   */
  async getProcessingDocuments(sessionId: string, userId: string): Promise&lt;Document[]&gt; {
    return await this.getDocumentsByStatus(sessionId, &apos;processing&apos;, userId);
  }

  /**
   * Get failed documents for a session
   */
  async getFailedDocuments(sessionId: string, userId: string): Promise&lt;Document[]&gt; {
    return await this.getDocumentsByStatus(sessionId, &apos;failed&apos;, userId);
  }

  /**
   * Check if a document with the given ID exists across all sessions
   * Returns the document if found, undefined otherwise
   */
  async getDocumentAcrossAllSessions(id: string): Promise&lt;Document | undefined&gt; {
    if (!db) return undefined;
    
    const document = await db.documents.get(id);
    if (!document) return undefined;

    // Ensure date fields are Date objects (handles IndexedDB serialization)
    return {
      ...document,
      createdAt: ensureDate(document.createdAt),
      processedAt: document.processedAt ? ensureDate(document.processedAt) : undefined
    };
  }

  /**
   * Check if a document with the given filename exists in a specific session
   * Returns the document if found, undefined otherwise
   */
  async getDocumentByFilename(sessionId: string, filename: string, userId: string): Promise&lt;Document | undefined&gt; {
    if (!db) return undefined;
    if (!userId) return undefined;
    
    const document = await db.documents
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .and((doc: Document) =&gt; doc.filename === filename &amp;&amp; doc.userId === userId)
      .first();
    
    if (!document) return undefined;

    // Ensure date fields are Date objects (handles IndexedDB serialization)
    return {
      ...document,
      createdAt: ensureDate(document.createdAt),
      processedAt: document.processedAt ? ensureDate(document.processedAt) : undefined
    };
  }
}

export const documentService = new DocumentService();</file><file path="src/services/indexedDB/index.ts">// IndexedDB services export
import { RAGDatabase } from &apos;./db&apos;;
import { SessionService } from &apos;./sessionService&apos;;
import { MessageService } from &apos;./messageService&apos;;
import { DocumentService } from &apos;./documentService&apos;;
import { EmbeddingService } from &apos;./embeddingService&apos;;
import { SettingsService } from &apos;./settingsService&apos;;

// Re-export services
export { RAGDatabase, SessionService, MessageService, DocumentService, EmbeddingService, SettingsService };

// Service factory for easy dependency injection
export class IndexedDBServices {
  private db: RAGDatabase;
  
  public sessionService: SessionService;
  public messageService: MessageService;
  public documentService: DocumentService;
  public embeddingService: EmbeddingService;
  public settingsService: SettingsService;

  constructor() {
    this.db = new RAGDatabase();
    
    this.sessionService = new SessionService();
    this.messageService = new MessageService();
    this.documentService = new DocumentService();
    this.embeddingService = new EmbeddingService();
    this.settingsService = new SettingsService();
  }

  /**
   * Initialize database and services
   */
  async initialize(): Promise&lt;void&gt; {
    await this.db.open();
  }

  /**
   * Close database connection
   */
  async close(): Promise&lt;void&gt; {
    this.db.close();
  }

  /**
   * Clear all data (for reset functionality)
   */
  async clearAllData(): Promise&lt;void&gt; {
    await this.db.delete();
    await this.db.open();
  }
}

// Singleton instance for global access
let indexedDBServices: IndexedDBServices | null = null;

export function getIndexedDBServices(): IndexedDBServices {
  if (!indexedDBServices) {
    indexedDBServices = new IndexedDBServices();
  }
  return indexedDBServices;
}

// Initialize services on import
export async function initializeIndexedDBServices(): Promise&lt;IndexedDBServices&gt; {
  const services = getIndexedDBServices();
  await services.initialize();
  return services;
}</file><file path="src/services/indexedDB/messageService.ts">import { db } from &apos;./db&apos;;
import type { Message, MessageCreate } from &apos;@/types&apos;;
import { ensureDate } from &apos;@/utils/date&apos;;
import { userIdLogger } from &apos;@/utils/userIdDebugLogger&apos;;

export class MessageService {
  /**
   * Create a new message
   */
  async createMessage(data: MessageCreate, userId?: string): Promise&lt;Message&gt; {
    userIdLogger.logServiceCall(&apos;messageService&apos;, &apos;createMessage&apos;, &apos;create&apos;, userId || null);
    
    if (!db) throw new Error(&apos;Database not available&apos;);
    
    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(data.sessionId);
      if (!session) {
        userIdLogger.logError(&apos;messageService.createMessage&apos;, new Error(&apos;Attempt to create message for non-existent session&apos;), userId);
        throw new Error(&apos;Session not found&apos;);
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;messageService.createMessage&apos;, new Error(&apos;Attempt to create message for session belonging to different user&apos;), userId);
        throw new Error(&apos;Access denied&apos;);
      }
    }
    
    const message: Message = {
      id: crypto.randomUUID(),
      sessionId: data.sessionId,
      content: data.content,
      role: data.role,
      timestamp: new Date(),
      citations: data.citations,
    };

    // DEBUG: Log message content before storing
    console.log(&apos;[MESSAGE SERVICE CREATE DEBUG]&apos;, {
      messageId: message.id,
      content: data.content,
      hasNewlines: data.content.includes(&apos;\n&apos;),
      newlineCount: (data.content.match(/\n/g) || []).length,
      bulletCount: (data.content.match(/^\* /gm) || []).length,
      firstFewLines: data.content.split(&apos;\n&apos;).slice(0, 5)
    });

    await db.messages.add(message);
    
    // DEBUG: Verify what was actually stored
    const storedMessage = await db.messages.get(message.id);
    if (storedMessage) {
      console.log(&apos;[MESSAGE SERVICE STORED DEBUG]&apos;, {
        messageId: storedMessage.id,
        content: storedMessage.content,
        hasNewlines: storedMessage.content.includes(&apos;\n&apos;),
        newlineCount: (storedMessage.content.match(/\n/g) || []).length,
        bulletCount: (storedMessage.content.match(/^\* /gm) || []).length,
        firstFewLines: storedMessage.content.split(&apos;\n&apos;).slice(0, 5),
        contentMatches: data.content === storedMessage.content
      });
    }
    
    return message;
  }

  /**
   * Get all messages for a session ordered by createdAt
   */
  async getMessagesBySession(sessionId: string, userId?: string): Promise&lt;Message[]&gt; {
    userIdLogger.logServiceCall(&apos;messageService&apos;, &apos;getMessagesBySession&apos;, &apos;read&apos;, userId || null);
    
    if (!db) return [];
    
    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(sessionId);
      if (!session) {
        userIdLogger.logError(&apos;messageService.getMessagesBySession&apos;, new Error(&apos;Attempt to get messages for non-existent session&apos;), userId);
        return []; // Return empty array if session doesn&apos;t exist or doesn&apos;t belong to user
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;messageService.getMessagesBySession&apos;, new Error(&apos;Attempt to get messages for session belonging to different user&apos;), userId);
        return []; // Return empty array if session doesn&apos;t exist or doesn&apos;t belong to user
      }
    }
    
    const messages = await db.messages
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .sortBy(&apos;timestamp&apos;);
    
    // Ensure timestamp is a Date object (handles IndexedDB serialization)
    const processedMessages = messages.map(message =&gt; {
      const processedMessage = {
        ...message,
        timestamp: ensureDate(message.timestamp)
      };
      
      // DEBUG: Log each retrieved message
      console.log(&apos;[MESSAGE SERVICE RETRIEVE DEBUG]&apos;, {
        messageId: message.id,
        content: message.content,
        hasNewlines: message.content.includes(&apos;\n&apos;),
        newlineCount: (message.content.match(/\n/g) || []).length,
        bulletCount: (message.content.match(/^\* /gm) || []).length,
        firstFewLines: message.content.split(&apos;\n&apos;).slice(0, 5)
      });
      
      return processedMessage;
    });
    
    return processedMessages;
  }

  /**
   * Get a specific message by ID
   */
  async getMessage(id: string, userId?: string): Promise&lt;Message | undefined&gt; {
    userIdLogger.logServiceCall(&apos;messageService&apos;, &apos;getMessage&apos;, &apos;read&apos;, userId || null);
    
    if (!db) return undefined;
    const message = await db.messages.get(id);
    if (!message) return undefined;
    
    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(message.sessionId);
      if (!session) {
        userIdLogger.logError(&apos;messageService.getMessage&apos;, new Error(&apos;Attempt to get message for non-existent session&apos;), userId);
        return undefined;
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;messageService.getMessage&apos;, new Error(&apos;Attempt to get message for session belonging to different user&apos;), userId);
        return undefined;
      }
    }
    
    // Ensure timestamp is a Date object (handles IndexedDB serialization)
    return {
      ...message,
      timestamp: ensureDate(message.timestamp)
    };
  }

  /**
   * Update a message
   */
  async updateMessage(id: string, updates: Partial&lt;Message&gt;, userId?: string): Promise&lt;void&gt; {
    userIdLogger.logServiceCall(&apos;messageService&apos;, &apos;updateMessage&apos;, &apos;update&apos;, userId || null);
    
    if (!db) return;
    const existing = await db.messages.get(id);
    if (!existing) return;
    
    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(existing.sessionId);
      if (!session) {
        userIdLogger.logError(&apos;messageService.updateMessage&apos;, new Error(&apos;Attempt to update message for non-existent session&apos;), userId);
        return;
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;messageService.updateMessage&apos;, new Error(&apos;Attempt to update message for session belonging to different user&apos;), userId);
        return;
      }
    }
    
    const updated = { ...existing, ...updates };
    await db.messages.put(updated);
  }

  /**
   * Delete a message
   */
  async deleteMessage(id: string, userId?: string): Promise&lt;void&gt; {
    userIdLogger.logServiceCall(&apos;messageService&apos;, &apos;deleteMessage&apos;, &apos;delete&apos;, userId || null);
    
    if (!db) return;
    
    // If userId is provided, verify session ownership
    if (userId) {
      const message = await db.messages.get(id);
      if (!message) {
        userIdLogger.logError(&apos;messageService.deleteMessage&apos;, new Error(&apos;Attempt to delete non-existent message&apos;), userId);
        return;
      }
      
      const session = await db.sessions.get(message.sessionId);
      if (!session) {
        userIdLogger.logError(&apos;messageService.deleteMessage&apos;, new Error(&apos;Attempt to delete message for non-existent session&apos;), userId);
        return;
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;messageService.deleteMessage&apos;, new Error(&apos;Attempt to delete message for session belonging to different user&apos;), userId);
        return;
      }
    }
    
    await db.messages.delete(id);
  }

  /**
   * Delete all messages for a session
   */
  async deleteMessagesBySession(sessionId: string, userId?: string): Promise&lt;void&gt; {
    userIdLogger.logServiceCall(&apos;messageService&apos;, &apos;deleteMessagesBySession&apos;, &apos;delete&apos;, userId || null);
    
    if (!db) return;
    
    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(sessionId);
      if (!session) {
        userIdLogger.logError(&apos;messageService.deleteMessagesBySession&apos;, new Error(&apos;Attempt to delete messages for non-existent session&apos;), userId);
        return;
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;messageService.deleteMessagesBySession&apos;, new Error(&apos;Attempt to delete messages for session belonging to different user&apos;), userId);
        return;
      }
    }
    
    await db.messages.where(&apos;sessionId&apos;).equals(sessionId).delete();
  }

  /**
   * Get message count for a session
   */
  async getMessageCount(sessionId: string): Promise&lt;number&gt; {
    if (!db) return 0;
    return await db.messages.where(&apos;sessionId&apos;).equals(sessionId).count();
  }

  /**
   * Get last message for a session
   */
  async getLastMessage(sessionId: string, userId?: string): Promise&lt;Message | undefined&gt; {
    userIdLogger.logServiceCall(&apos;messageService&apos;, &apos;getLastMessage&apos;, &apos;read&apos;, userId || null);
    
    if (!db) return undefined;
    
    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(sessionId);
      if (!session) {
        userIdLogger.logError(&apos;messageService.getLastMessage&apos;, new Error(&apos;Attempt to get last message for non-existent session&apos;), userId);
        return undefined;
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;messageService.getLastMessage&apos;, new Error(&apos;Attempt to get last message for session belonging to different user&apos;), userId);
        return undefined;
      }
    }
    
    const messages = await db.messages
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .reverse()
      .sortBy(&apos;timestamp&apos;);
    
    if (messages.length === 0) return undefined;
    
    // Ensure timestamp is a Date object (handles IndexedDB serialization)
    const lastMessage = messages[0];
    return {
      ...lastMessage,
      timestamp: ensureDate(lastMessage.timestamp)
    };
  }
}

export const messageService = new MessageService();</file><file path="src/services/indexedDB/sessionService.ts">import { db } from &apos;./db&apos;;
import type { Session, SessionCreate, SessionUpdate } from &apos;@/types&apos;;
import { ensureDate } from &apos;@/utils/date&apos;;
import { userIdLogger } from &apos;@/utils/userIdDebugLogger&apos;;

export class SessionService {
  /**
   * Create a new session
   */
  async createSession(data: SessionCreate, userId: string): Promise&lt;Session&gt; {
    userIdLogger.logServiceCall(&apos;sessionService&apos;, &apos;createSession&apos;, &apos;create&apos;, userId);
    
    if (!db) throw new Error(&apos;Database not available&apos;);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;sessionService.createSession&apos;, new Error(&apos;Attempt to create session without userId&apos;), userId);
      throw new Error(&apos;userId is required to create a session&apos;);
    }
    
    const session: Session = {
      id: crypto.randomUUID(),
      userId,
      name: data.name,
      description: data.description,
      createdAt: new Date(),
      updatedAt: new Date(),
      documentCount: 0,
    };

    await db.sessions.add(session);
    return session;
  }

  /**
   * Get all sessions for a user ordered by updatedAt (most recent first)
   */
  async getSessions(userId: string): Promise&lt;Session[]&gt; {
    userIdLogger.logServiceCall(&apos;sessionService&apos;, &apos;getSessions&apos;, &apos;read&apos;, userId);
    
    if (!db) return [];
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;sessionService.getSessions&apos;, new Error(&apos;Attempt to get sessions without userId&apos;), userId);
      return [];
    }
    
    const sessions = await db.sessions
      .where(&apos;userId&apos;)
      .equals(userId)
      .reverse()
      .sortBy(&apos;updatedAt&apos;);

    // Ensure date fields are Date objects (handles IndexedDB serialization)
    return sessions.map(session =&gt; ({
      ...session,
      createdAt: ensureDate(session.createdAt),
      updatedAt: ensureDate(session.updatedAt),
      lastMessageAt: session.lastMessageAt ? ensureDate(session.lastMessageAt) : undefined
    }));
  }

  /**
   * Get a specific session by ID
   */
  async getSession(id: string, userId?: string): Promise&lt;Session | undefined&gt; {
    userIdLogger.logServiceCall(&apos;sessionService&apos;, &apos;getSession&apos;, &apos;read&apos;, userId || null);
    
    if (!db) return undefined;
    const session = await db.sessions.get(id);
    if (!session) return undefined;

    // If userId is provided, verify session ownership
    if (userId &amp;&amp; session.userId !== userId) {
      userIdLogger.logError(&apos;sessionService.getSession&apos;, new Error(&apos;Attempt to access session belonging to different user&apos;), userId);
      return undefined; // Return undefined if session doesn&apos;t belong to user
    }

    // Ensure date fields are Date objects (handles IndexedDB serialization)
    return {
      ...session,
      createdAt: ensureDate(session.createdAt),
      updatedAt: ensureDate(session.updatedAt),
      lastMessageAt: session.lastMessageAt ? ensureDate(session.lastMessageAt) : undefined
    };
  }

  /**
   * Update a session
   */
  async updateSession(id: string, updates: SessionUpdate, userId?: string): Promise&lt;void&gt; {
    userIdLogger.logServiceCall(&apos;sessionService&apos;, &apos;updateSession&apos;, &apos;update&apos;, userId || null);
    
    if (!db) return;
    const existing = await db.sessions.get(id);
    if (!existing) return;
    
    // If userId is provided, verify ownership
    if (userId &amp;&amp; existing.userId !== userId) {
      userIdLogger.logError(&apos;sessionService.updateSession&apos;, new Error(&apos;Attempt to update session belonging to different user&apos;), userId);
      return;
    }
    
    const updated = {
      ...existing,
      ...updates,
      updatedAt: new Date()
    };
    await db.sessions.put(updated);
  }

  /**
   * Delete a session and all related data
   */
  async deleteSession(id: string, userId?: string): Promise&lt;void&gt; {
    userIdLogger.logServiceCall(&apos;sessionService&apos;, &apos;deleteSession&apos;, &apos;delete&apos;, userId || null);
    
    if (!db) return;
    
    // First verify ownership if userId is provided
    if (userId) {
      const session = await db.sessions.get(id);
      if (!session) {
        userIdLogger.logError(&apos;sessionService.deleteSession&apos;, new Error(&apos;Attempt to delete non-existent session&apos;), userId);
        return;
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;sessionService.deleteSession&apos;, new Error(&apos;Attempt to delete session belonging to different user&apos;), userId);
        return;
      }
    }
    
    await db.transaction(&apos;rw&apos;, db.sessions, db.messages, db.documents, db.embeddings, async () =&gt; {
      // Delete session
      await db!.sessions.delete(id);

      // Delete related messages
      const messages = await db!.messages.where(&apos;sessionId&apos;).equals(id).toArray();
      await Promise.all(messages.map((message: any) =&gt; db!.messages.delete(message.id)));

      // Delete related documents and embeddings
      const documents = await db!.documents.where(&apos;sessionId&apos;).equals(id).toArray();
      for (const document of documents) {
        await db!.documents.delete(document.id);

        // Delete embeddings for this document
        const embeddings = await db!.embeddings.where(&apos;documentId&apos;).equals(document.id).toArray();
        await Promise.all(embeddings.map((embedding: any) =&gt; db!.embeddings.delete(embedding.id)));
      }
    });
  }

  /**
   * Update document count for a session
   */
  async updateDocumentCount(sessionId: string, userId?: string): Promise&lt;void&gt; {
    userIdLogger.logServiceCall(&apos;sessionService&apos;, &apos;updateDocumentCount&apos;, &apos;update&apos;, userId || null);
    
    if (!db) return;
    
    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(sessionId);
      if (!session) {
        userIdLogger.logError(&apos;sessionService.updateDocumentCount&apos;, new Error(&apos;Attempt to update document count for non-existent session&apos;), userId);
        return;
      }
      
      if (session.userId !== userId) {
        userIdLogger.logError(&apos;sessionService.updateDocumentCount&apos;, new Error(&apos;Attempt to update document count for session belonging to different user&apos;), userId);
        return;
      }
    }
    
    const documentCount = await db.documents.where(&apos;sessionId&apos;).equals(sessionId).count();
    await this.updateSession(sessionId, { documentCount: documentCount || 0 }, userId);
  }
}

export const sessionService = new SessionService();</file><file path="src/services/rag/errorHandler.ts">import type { Document } from &apos;@/types/document&apos;;
import type { PreprocessedPackage } from &apos;@/types/preprocessed&apos;;
import type { EmbeddingGenerationProgress } from &apos;@/types/embedding&apos;;

export interface IngestionError {
  code: string;
  message: string;
  details?: any;
  timestamp: Date;
  recoverable: boolean;
  suggestedAction?: string;
}

export interface ErrorHandlingResult {
  success: boolean;
  errors: IngestionError[];
  warnings: string[];
  recovered?: boolean;
  fallbackData?: any;
}

export interface ErrorContext {
  operation: &apos;package_validation&apos; | &apos;document_processing&apos; | &apos;embedding_generation&apos; | &apos;metadata_extraction&apos; | &apos;storage&apos;;
  documentId?: string;
  sessionId?: string;
  filename?: string;
  step?: string;
  data?: any;
}

export class IngestionErrorHandler {
  private errorHistory: Map&lt;string, IngestionError[]&gt; = new Map();

  /**
   * Handle package validation errors with detailed analysis
   */
  handlePackageValidationError(
    error: any,
    packageData: PreprocessedPackage,
    context: ErrorContext
  ): ErrorHandlingResult {
    const errors: IngestionError[] = [];
    const warnings: string[] = [];

    // Analyze the error type
    if (error instanceof SyntaxError) {
      errors.push({
        code: &apos;INVALID_JSON&apos;,
        message: &apos;Package contains invalid JSON format&apos;,
        details: { originalError: error.message },
        timestamp: new Date(),
        recoverable: false,
        suggestedAction: &apos;Please check the JSON file format and try again&apos;
      });
    } else if (error.message?.includes(&apos;format_version&apos;)) {
      errors.push({
        code: &apos;UNSUPPORTED_VERSION&apos;,
        message: `Unsupported package format version: ${packageData.format_version}`,
        details: { supportedVersions: [&apos;1.0&apos;], providedVersion: packageData.format_version },
        timestamp: new Date(),
        recoverable: false,
        suggestedAction: &apos;Please use a package with format version 1.0&apos;
      });
    } else if (error.message?.includes(&apos;document_metadata&apos;)) {
      errors.push({
        code: &apos;MISSING_METADATA&apos;,
        message: &apos;Required document metadata is missing&apos;,
        details: { missingFields: this.extractMissingFields(error.message) },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Add missing metadata fields to the package&apos;
      });
    } else {
      errors.push({
        code: &apos;VALIDATION_FAILED&apos;,
        message: `Package validation failed: ${error.message}`,
        details: { originalError: error.message, stack: error.stack },
        timestamp: new Date(),
        recoverable: false,
        suggestedAction: &apos;Please check the package format and content&apos;
      });
    }

    // Log errors for debugging
    this.logErrors(errors, context);

    return {
      success: false,
      errors,
      warnings
    };
  }

  /**
   * Handle document processing errors with recovery options
   */
  handleDocumentProcessingError(
    error: any,
    document: Document,
    context: ErrorContext
  ): ErrorHandlingResult {
    const errors: IngestionError[] = [];
    const warnings: string[] = [];
    let recovered = false;
    let fallbackData: any;

    // Analyze error type and provide recovery options
    if (error.message?.includes(&apos;file not found&apos;) || error.message?.includes(&apos;ENOENT&apos;)) {
      errors.push({
        code: &apos;FILE_NOT_FOUND&apos;,
        message: `Document file not found: ${document.filename}`,
        details: { originalPath: document.originalPath, storedPath: document.storedPath },
        timestamp: new Date(),
        recoverable: false,
        suggestedAction: &apos;Please re-upload the document&apos;
      });
    } else if (error.message?.includes(&apos;permission&apos;) || error.message?.includes(&apos;access&apos;)) {
      errors.push({
        code: &apos;ACCESS_DENIED&apos;,
        message: `Permission denied accessing document: ${document.filename}`,
        details: { originalError: error.message },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Check file permissions or try re-uploading&apos;
      });
    } else if (error.message?.includes(&apos;memory&apos;) || error.message?.includes(&apos;heap&apos;)) {
      errors.push({
        code: &apos;MEMORY_LIMIT&apos;,
        message: &apos;Insufficient memory to process document&apos;,
        details: { fileSize: document.fileSize },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Try processing a smaller document or close other applications&apos;
      });
      
      // Attempt recovery with smaller chunks
      fallbackData = {
        chunkSize: 500, // Reduce from default 1000
        chunkOverlap: 100
      };
      recovered = true;
    } else if (error.message?.includes(&apos;timeout&apos;)) {
      errors.push({
        code: &apos;PROCESSING_TIMEOUT&apos;,
        message: &apos;Document processing timed out&apos;,
        details: { timeout: error.timeout, documentSize: document.fileSize },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Try processing a smaller document or increase timeout&apos;
      });
      
      fallbackData = {
        retryWithSmallerChunks: true
      };
      recovered = true;
    } else if (error.message?.includes(&apos;embedding&apos;)) {
      errors.push({
        code: &apos;EMBEDDING_GENERATION_FAILED&apos;,
        message: &apos;Failed to generate embeddings for document chunks&apos;,
        details: { originalError: error.message },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Check API key and network connection&apos;
      });
      
      // Try to continue with partial embeddings
      fallbackData = {
        continueWithPartial: true,
        processedChunks: error.processedChunks || 0
      };
      recovered = true;
    } else {
      errors.push({
        code: &apos;PROCESSING_FAILED&apos;,
        message: `Document processing failed: ${error.message}`,
        details: { originalError: error.message, stack: error.stack },
        timestamp: new Date(),
        recoverable: false,
        suggestedAction: &apos;Please check the document format and try again&apos;
      });
    }

    // Log errors for debugging
    this.logErrors(errors, context);

    return {
      success: false,
      errors,
      warnings,
      recovered,
      fallbackData
    };
  }

  /**
   * Handle embedding generation errors with retry logic
   */
  handleEmbeddingError(
    error: any,
    chunkText: string,
    context: ErrorContext
  ): ErrorHandlingResult {
    const errors: IngestionError[] = [];
    const warnings: string[] = [];
    let recovered = false;
    let fallbackData: any;

    if (error.message?.includes(&apos;API key&apos;) || error.message?.includes(&apos;authentication&apos;)) {
      errors.push({
        code: &apos;API_KEY_INVALID&apos;,
        message: &apos;Invalid or missing API key for embedding service&apos;,
        details: { service: &apos;gemini&apos; },
        timestamp: new Date(),
        recoverable: false,
        suggestedAction: &apos;Please check your API key configuration&apos;
      });
    } else if (error.message?.includes(&apos;quota&apos;) || error.message?.includes(&apos;rate limit&apos;)) {
      errors.push({
        code: &apos;RATE_LIMIT_EXCEEDED&apos;,
        message: &apos;API rate limit exceeded&apos;,
        details: { retryAfter: error.retryAfter || &apos;60 seconds&apos; },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Wait and retry the request&apos;
      });
      
      fallbackData = {
        retryDelay: error.retryAfter || 60000, // 60 seconds default
        exponentialBackoff: true
      };
      recovered = true;
    } else if (error.message?.includes(&apos;network&apos;) || error.message?.includes(&apos;connection&apos;)) {
      errors.push({
        code: &apos;NETWORK_ERROR&apos;,
        message: &apos;Network connection failed&apos;,
        details: { originalError: error.message },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Check internet connection and retry&apos;
      });
      
      fallbackData = {
        maxRetries: 3,
        retryDelay: 5000 // 5 seconds
      };
      recovered = true;
    } else if (error.message?.includes(&apos;content&apos;) || error.message?.includes(&apos;text too long&apos;)) {
      errors.push({
        code: &apos;CONTENT_TOO_LONG&apos;,
        message: &apos;Text content exceeds maximum length for embedding&apos;,
        details: { textLength: chunkText.length },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Split the text into smaller chunks&apos;
      });
      
      warnings.push(&apos;Text chunk is too long, will be split automatically&apos;);
      fallbackData = {
        splitChunk: true,
        maxLength: 8000 // Gemini has a limit
      };
      recovered = true;
    } else {
      errors.push({
        code: &apos;EMBEDDING_FAILED&apos;,
        message: `Embedding generation failed: ${error.message}`,
        details: { originalError: error.message, chunkLength: chunkText.length },
        timestamp: new Date(),
        recoverable: false,
        suggestedAction: &apos;Check the content and try again&apos;
      });
    }

    // Log errors for debugging
    this.logErrors(errors, context);

    return {
      success: false,
      errors,
      warnings,
      recovered,
      fallbackData
    };
  }

  /**
   * Handle storage errors with cleanup options
   */
  handleStorageError(
    error: any,
    operation: string,
    context: ErrorContext
  ): ErrorHandlingResult {
    const errors: IngestionError[] = [];
    const warnings: string[] = [];
    let recovered = false;
    let fallbackData: any;

    if (error.name === &apos;QuotaExceededError&apos;) {
      errors.push({
        code: &apos;STORAGE_QUOTA_EXCEEDED&apos;,
        message: &apos;Browser storage quota exceeded&apos;,
        details: { operation },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Clear old data or use a different browser&apos;
      });
      
      fallbackData = {
        cleanupOldSessions: true,
        clearCache: true
      };
      recovered = true;
    } else if (error.name === &apos;InvalidStateError&apos;) {
      errors.push({
        code: &apos;DATABASE_CORRUPTED&apos;,
        message: &apos;Database is in an invalid state&apos;,
        details: { operation, originalError: error.message },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Clear browser data and reload the page&apos;
      });
      
      fallbackData = {
        reinitializeDatabase: true
      };
      recovered = true;
    } else if (error.name === &apos;TransactionInactiveError&apos;) {
      errors.push({
        code: &apos;TRANSACTION_FAILED&apos;,
        message: &apos;Database transaction failed or was inactive&apos;,
        details: { operation },
        timestamp: new Date(),
        recoverable: true,
        suggestedAction: &apos;Retry the operation&apos;
      });
      
      fallbackData = {
        retryTransaction: true,
        maxRetries: 3
      };
      recovered = true;
    } else {
      errors.push({
        code: &apos;STORAGE_ERROR&apos;,
        message: `Storage operation failed: ${error.message}`,
        details: { operation, originalError: error.message, stack: error.stack },
        timestamp: new Date(),
        recoverable: false,
        suggestedAction: &apos;Please refresh the page and try again&apos;
      });
    }

    // Log errors for debugging
    this.logErrors(errors, context);

    return {
      success: false,
      errors,
      warnings,
      recovered,
      fallbackData
    };
  }

  /**
   * Create user-friendly error message
   */
  createUserFriendlyMessage(errors: IngestionError[]): string {
    if (errors.length === 0) {
      return &apos;An unknown error occurred&apos;;
    }

    const primaryError = errors[0];
    
    // Create user-friendly message based on error code
    switch (primaryError.code) {
      case &apos;INVALID_JSON&apos;:
        return &apos;The uploaded file is not a valid JSON package. Please check the file format.&apos;;
      
      case &apos;UNSUPPORTED_VERSION&apos;:
        return &apos;This package format is not supported. Please use a package with format version 1.0.&apos;;
      
      case &apos;MISSING_METADATA&apos;:
        return &apos;The package is missing required information. Please ensure all metadata is included.&apos;;
      
      case &apos;FILE_NOT_FOUND&apos;:
        return &apos;The document file could not be found. Please re-upload the document.&apos;;
      
      case &apos;ACCESS_DENIED&apos;:
        return &apos;Permission to access the document was denied. Please check file permissions.&apos;;
      
      case &apos;MEMORY_LIMIT&apos;:
        return &apos;The document is too large to process. Please try a smaller document.&apos;;
      
      case &apos;PROCESSING_TIMEOUT&apos;:
        return &apos;Document processing took too long. Please try a smaller document.&apos;;
      
      case &apos;API_KEY_INVALID&apos;:
        return &apos;There is a problem with the API configuration. Please check your settings.&apos;;
      
      case &apos;RATE_LIMIT_EXCEEDED&apos;:
        return &apos;Too many requests were made. Please wait a moment and try again.&apos;;
      
      case &apos;NETWORK_ERROR&apos;:
        return &apos;Network connection failed. Please check your internet connection.&apos;;
      
      case &apos;STORAGE_QUOTA_EXCEEDED&apos;:
        return &apos;Browser storage is full. Please clear old data to continue.&apos;;
      
      case &apos;DATABASE_CORRUPTED&apos;:
        return &apos;There is a problem with the local database. Please refresh the page.&apos;;
      
      default:
        return primaryError.suggestedAction || primaryError.message;
    }
  }

  /**
   * Extract missing fields from error message
   */
  private extractMissingFields(errorMessage: string): string[] {
    const missingFields: string[] = [];
    
    // Common field patterns
    const fieldPatterns = [
      /title/gi,
      /author/gi,
      /filename/gi,
      /file_size/gi,
      /page_count/gi,
      /chunk_count/gi,
      /embedding_model/gi
    ];
    
    fieldPatterns.forEach(pattern =&gt; {
      if (pattern.test(errorMessage)) {
        const fieldName = pattern.source.replace(/[\/\\gi]/g, &apos;&apos;);
        missingFields.push(fieldName);
      }
    });
    
    return missingFields;
  }

  /**
   * Log errors for debugging
   */
  private logErrors(errors: IngestionError[], context: ErrorContext): void {
    const sessionKey = context.sessionId || &apos;global&apos;;
    
    if (!this.errorHistory.has(sessionKey)) {
      this.errorHistory.set(sessionKey, []);
    }
    
    const sessionErrors = this.errorHistory.get(sessionKey)!;
    sessionErrors.push(...errors);
    
    // Keep only last 50 errors per session
    if (sessionErrors.length &gt; 50) {
      sessionErrors.splice(0, sessionErrors.length - 50);
    }
    
    // Log to console for debugging
    console.group(`üö® Ingestion Error [${context.operation}]`);
    console.error(&apos;Context:&apos;, context);
    errors.forEach((error, index) =&gt; {
      console.error(`Error ${index + 1}:`, error);
    });
    console.groupEnd();
  }

  /**
   * Get error history for a session
   */
  getErrorHistory(sessionId?: string): IngestionError[] {
    const sessionKey = sessionId || &apos;global&apos;;
    return this.errorHistory.get(sessionKey) || [];
  }

  /**
   * Clear error history for a session
   */
  clearErrorHistory(sessionId?: string): void {
    const sessionKey = sessionId || &apos;global&apos;;
    this.errorHistory.delete(sessionKey);
  }

  /**
   * Get error statistics
   */
  getErrorStats(sessionId?: string): {
    totalErrors: number;
    errorsByCode: Record&lt;string, number&gt;;
    recoverableErrors: number;
    recentErrors: IngestionError[];
  } {
    const errors = this.getErrorHistory(sessionId);
    const errorsByCode: Record&lt;string, number&gt; = {};
    let recoverableErrors = 0;
    
    errors.forEach(error =&gt; {
      errorsByCode[error.code] = (errorsByCode[error.code] || 0) + 1;
      if (error.recoverable) {
        recoverableErrors++;
      }
    });
    
    return {
      totalErrors: errors.length,
      errorsByCode,
      recoverableErrors,
      recentErrors: errors.slice(-10) // Last 10 errors
    };
  }
}

// Singleton instance
export const ingestionErrorHandler = new IngestionErrorHandler();</file><file path="src/services/rag/index.ts">// RAG (Retrieval-Augmented Generation) services
export { vectorSearchService } from &apos;./vectorSearch&apos;;
export { documentProcessor } from &apos;./documentProcessor&apos;;
export { chatPipeline } from &apos;./chatPipeline&apos;;
export { packageValidator } from &apos;./packageValidator&apos;;
export { citationService } from &apos;./citationService&apos;;
export { ResponseFormatter } from &apos;./responseFormatter&apos;;
export { metadataExtractor } from &apos;./metadataExtractor&apos;;
export { ingestionErrorHandler } from &apos;./errorHandler&apos;;
export { progressTracker, createDocumentIngestionOperation, createVectorSearchOperation, createChatGenerationOperation } from &apos;./progressTracker&apos;;

// Re-export types for convenience
export type { VectorSearchResult } from &apos;@/types/embedding&apos;;
export type { ChatStreamEvent } from &apos;../gemini/chatService&apos;;
export type { ExtractedMetadata, MetadataExtractionResult } from &apos;./metadataExtractor&apos;;
export type { ProcessedCitations, Citation } from &apos;./citationService&apos;;
export type { IngestionError, ErrorHandlingResult, ErrorContext } from &apos;./errorHandler&apos;;
export type { ProgressOperation, ProgressStep, ProgressEvent, ProgressCallback } from &apos;./progressTracker&apos;;</file><file path="src/services/rag/metadataExtractor.ts">import type { Document, DocumentCreate, DocumentUpdate } from &apos;@/types/document&apos;;
import type { PreprocessedPackage } from &apos;@/types/preprocessed&apos;;

export interface ExtractedMetadata {
  title?: string;
  author?: string;
  language?: string;
  subject?: string;
  keywords?: string[];
  creationDate?: Date;
  modificationDate?: Date;
  producer?: string;
  creator?: string;
  pageCount?: number;
  wordCount?: number;
  characterCount?: number;
  readingTimeMinutes?: number;
  chunkSize?: number;
  chunkOverlap?: number;
  embeddingModel?: string;
  processingNotes?: string[];
}

export interface MetadataExtractionResult {
  success: boolean;
  metadata: ExtractedMetadata;
  warnings: string[];
  errors: string[];
}

export class MetadataExtractor {
  
  /**
   * Extract comprehensive metadata from a preprocessed package
   */
  async extractFromPreprocessedPackage(packageData: PreprocessedPackage): Promise&lt;MetadataExtractionResult&gt; {
    const result: MetadataExtractionResult = {
      success: true,
      metadata: {},
      warnings: [],
      errors: []
    };

    try {
      // Extract document metadata from package
      const docMeta = packageData.document_metadata;
      
      // Basic document info
      result.metadata.title = this.extractTitle(docMeta);
      result.metadata.pageCount = docMeta.page_count;
      result.metadata.embeddingModel = docMeta.embedding_model;
      
      // Chunk settings
      if (docMeta.chunk_settings) {
        result.metadata.chunkSize = docMeta.chunk_settings.chunk_size;
        result.metadata.chunkOverlap = docMeta.chunk_settings.chunk_overlap;
      }

      // Dates
      result.metadata.creationDate = this.parseDate(docMeta.created_at);
      result.metadata.modificationDate = this.parseDate(docMeta.processed_at);

      // Extract content-based metadata from chunks
      const contentMetadata = await this.extractFromChunks(packageData.chunks);
      result.metadata.wordCount = contentMetadata.wordCount;
      result.metadata.characterCount = contentMetadata.characterCount;
      result.metadata.readingTimeMinutes = contentMetadata.readingTimeMinutes;
      result.metadata.language = contentMetadata.language;

      // Merge metadata
      Object.assign(result.metadata, contentMetadata.additional);

      // Validate extracted metadata
      this.validateExtractedMetadata(result);

    } catch (error) {
      result.success = false;
      result.errors.push(`Failed to extract metadata: ${error instanceof Error ? error.message : &apos;Unknown error&apos;}`);
    }

    return result;
  }

  /**
   * Extract metadata from document content (for non-preprocessed documents)
   */
  async extractFromContent(content: string, filename?: string): Promise&lt;MetadataExtractionResult&gt; {
    const result: MetadataExtractionResult = {
      success: true,
      metadata: {},
      warnings: [],
      errors: []
    };

    try {
      // Basic content analysis
      result.metadata.characterCount = content.length;
      result.metadata.wordCount = this.countWords(content);
      // Calculate reading time with a more reasonable cap for very large documents
      const rawReadingTime = Math.ceil(result.metadata.wordCount / 200);
      result.metadata.readingTimeMinutes = Math.min(rawReadingTime, 720); // Cap at 12 hours

      // Extract title from content
      if (!result.metadata.title) {
        result.metadata.title = this.extractTitleFromContent(content);
      }

      // Extract potential metadata from content patterns
      const contentPatterns = this.extractContentPatterns(content);
      Object.assign(result.metadata, contentPatterns);

      // Language detection (basic)
      result.metadata.language = this.detectLanguage(content);

      // Extract keywords
      result.metadata.keywords = this.extractKeywords(content);

      // Use filename as fallback title
      if (!result.metadata.title &amp;&amp; filename) {
        result.metadata.title = filename.replace(/\.[^/.]+$/, &apos;&apos;); // Remove extension
        result.warnings.push(&apos;Using filename as title - no clear title found in content&apos;);
      }

    } catch (error) {
      result.success = false;
      result.errors.push(`Failed to extract metadata from content: ${error instanceof Error ? error.message : &apos;Unknown error&apos;}`);
    }

    return result;
  }

  /**
   * Apply extracted metadata to a document
   */
  applyToDocument(document: Document | DocumentCreate, metadata: ExtractedMetadata): DocumentUpdate {
    const update: DocumentUpdate = {};

    // Only include fields that are actually defined
    if (metadata.title !== undefined) update.title = metadata.title;
    if (metadata.author !== undefined) update.author = metadata.author;
    if (metadata.language !== undefined) update.language = metadata.language;
    if (metadata.pageCount !== undefined) update.pageCount = metadata.pageCount;

    return update;
  }

  /**
   * Extract title from document metadata
   */
  private extractTitle(docMeta: any): string | undefined {
    // Try various title fields
    if (docMeta.title) return docMeta.title;
    if (docMeta.document_title) return docMeta.document_title;
    if (docMeta.filename) return docMeta.filename.replace(/\.[^/.]+$/, &apos;&apos;);
    return undefined;
  }

  /**
   * Extract metadata from chunks
   */
  private async extractFromChunks(chunks: any[]): Promise&lt;{
    wordCount: number;
    characterCount: number;
    readingTimeMinutes: number;
    language?: string;
    additional: any;
  }&gt; {
    let totalWordCount = 0;
    let totalCharCount = 0;
    const allText: string[] = [];

    for (const chunk of chunks) {
      if (chunk.text) {
        allText.push(chunk.text);
        totalWordCount += this.countWords(chunk.text);
        totalCharCount += chunk.text.length;
      }
    }

    const combinedText = allText.join(&apos; &apos;);
    
    // Calculate reading time with a more reasonable cap for very large documents
    const rawReadingTime = Math.ceil(totalWordCount / 200);
    const cappedReadingTime = Math.min(rawReadingTime, 720); // Cap at 12 hours
    
    return {
      wordCount: totalWordCount,
      characterCount: totalCharCount,
      readingTimeMinutes: cappedReadingTime,
      language: this.detectLanguage(combinedText),
      additional: {}
    };
  }

  /**
   * Extract title from content
   */
  private extractTitleFromContent(content: string): string | undefined {
    const lines = content.split(&apos;\n&apos;).map(line =&gt; line.trim()).filter(line =&gt; line.length &gt; 0);
    
    // Look for title candidates in first few lines
    for (let i = 0; i &lt; Math.min(10, lines.length); i++) {
      const line = lines[i];
      
      // Skip if too long or too short for a title
      if (line.length &lt; 10 || line.length &gt; 200) continue;
      
      // Skip if it looks like a header/footer
      if (this.isLikelyHeaderOrFooter(line)) continue;
      
      // Skip if it contains numbers that look like page numbers or dates
      if (/\d{4}|\b\d+\/\d+\/\d+\b/.test(line)) continue;
      
      // Good candidate for title
      return line;
    }
    
    return undefined;
  }

  /**
   * Extract patterns from content
   */
  private extractContentPatterns(content: string): any {
    const metadata: any = {};
    
    // Look for author patterns
    const authorPatterns = [
      /(?:author|by|written by)\s*:?\s*([^\n\r]+)/i,
      /^(.+?)\s+(?:author|writer|creator)/im
    ];
    
    for (const pattern of authorPatterns) {
      const match = content.match(pattern);
      if (match &amp;&amp; match[1] &amp;&amp; match[1].trim().length &lt; 100) {
        metadata.author = match[1].trim();
        break;
      }
    }

    // Look for subject/topic
    const subjectPatterns = [
      /(?:subject|topic)\s*:?\s*([^\n\r]+)/i,
      /^(?:abstract|summary)\s*:?\s*([^\n\r]+)/i
    ];
    
    for (const pattern of subjectPatterns) {
      const match = content.match(pattern);
      if (match &amp;&amp; match[1] &amp;&amp; match[1].trim().length &lt; 200) {
        metadata.subject = match[1].trim();
        break;
      }
    }

    return metadata;
  }

  /**
   * Detect language (basic implementation)
   */
  private detectLanguage(content: string): string {
    // Simple language detection based on common words
    const sample = content.substring(0, 1000).toLowerCase();
    
    // Check for common English words
    const englishWords = [&apos;the&apos;, &apos;and&apos;, &apos;or&apos;, &apos;but&apos;, &apos;in&apos;, &apos;on&apos;, &apos;at&apos;, &apos;to&apos;, &apos;for&apos;, &apos;of&apos;, &apos;with&apos;, &apos;by&apos;];
    const englishMatches = englishWords.filter(word =&gt; sample.includes(word)).length;
    
    // Check for common Spanish words
    const spanishWords = [&apos;el&apos;, &apos;la&apos;, &apos;y&apos;, &apos;o&apos;, &apos;pero&apos;, &apos;en&apos;, &apos;de&apos;, &apos;para&apos;, &apos;con&apos;, &apos;por&apos;, &apos;un&apos;, &apos;una&apos;];
    const spanishMatches = spanishWords.filter(word =&gt; sample.includes(word)).length;
    
    // Check for common French words
    const frenchWords = [&apos;le&apos;, &apos;la&apos;, &apos;et&apos;, &apos;ou&apos;, &apos;mais&apos;, &apos;dans&apos;, &apos;de&apos;, &apos;pour&apos;, &apos;avec&apos;, &apos;par&apos;, &apos;un&apos;, &apos;une&apos;];
    const frenchMatches = frenchWords.filter(word =&gt; sample.includes(word)).length;
    
    if (englishMatches &gt; spanishMatches &amp;&amp; englishMatches &gt; frenchMatches) {
      return &apos;en&apos;;
    } else if (spanishMatches &gt; englishMatches &amp;&amp; spanishMatches &gt; frenchMatches) {
      return &apos;es&apos;;
    } else if (frenchMatches &gt; englishMatches &amp;&amp; frenchMatches &gt; spanishMatches) {
      return &apos;fr&apos;;
    }
    
    return &apos;en&apos;; // Default to English
  }

  /**
   * Extract keywords from content
   */
  private extractKeywords(content: string): string[] {
    // Simple keyword extraction - remove common words and get frequent terms
    const commonWords = new Set([
      &apos;the&apos;, &apos;and&apos;, &apos;or&apos;, &apos;but&apos;, &apos;in&apos;, &apos;on&apos;, &apos;at&apos;, &apos;to&apos;, &apos;for&apos;, &apos;of&apos;, &apos;with&apos;, &apos;by&apos;,
      &apos;a&apos;, &apos;an&apos;, &apos;is&apos;, &apos;are&apos;, &apos;was&apos;, &apos;were&apos;, &apos;be&apos;, &apos;been&apos;, &apos;being&apos;, &apos;have&apos;, &apos;has&apos;,
      &apos;had&apos;, &apos;do&apos;, &apos;does&apos;, &apos;did&apos;, &apos;will&apos;, &apos;would&apos;, &apos;could&apos;, &apos;should&apos;, &apos;may&apos;, &apos;might&apos;,
      &apos;can&apos;, &apos;this&apos;, &apos;that&apos;, &apos;these&apos;, &apos;those&apos;, &apos;i&apos;, &apos;you&apos;, &apos;he&apos;, &apos;she&apos;, &apos;it&apos;, &apos;we&apos;, &apos;they&apos;
    ]);
    
    const words = content.toLowerCase()
      .replace(/[^\w\s]/g, &apos; &apos;)
      .split(/\s+/)
      .filter(word =&gt; word.length &gt; 3 &amp;&amp; !commonWords.has(word));
    
    // Count frequency
    const wordCount = new Map&lt;string, number&gt;();
    words.forEach(word =&gt; {
      wordCount.set(word, (wordCount.get(word) || 0) + 1);
    });
    
    // Get top keywords
    return Array.from(wordCount.entries())
      .sort((a, b) =&gt; b[1] - a[1])
      .slice(0, 10)
      .map(([word]) =&gt; word);
  }

  /**
   * Check if line is likely header or footer
   */
  private isLikelyHeaderOrFooter(line: string): boolean {
    // Common header/footer patterns
    const patterns = [
      /^\d+$/, // Just numbers (page numbers)
      /^\d+\s+of\s+\d+$/, // &quot;1 of 10&quot;
      /^\w+\s+\d{1,2},?\s+\d{4}$/, // Dates
      /^(page|pg|p)\.?\s*\d+/i, // Page indicators
      /^¬©\s*\d{4}/, // Copyright
      /^(confidential|draft|internal)/i // Document status
    ];
    
    return patterns.some(pattern =&gt; pattern.test(line));
  }

  /**
   * Count words in text
   */
  private countWords(text: string): number {
    return text.trim().split(/\s+/).filter(word =&gt; word.length &gt; 0).length;
  }

  /**
   * Parse date string
   */
  private parseDate(dateString?: string): Date | undefined {
    if (!dateString) return undefined;
    
    try {
      return new Date(dateString);
    } catch {
      return undefined;
    }
  }

  /**
   * Validate extracted metadata
   */
  private validateExtractedMetadata(result: MetadataExtractionResult): void {
    const { metadata } = result;
    
    // Validate page count
    if (metadata.pageCount !== undefined &amp;&amp; (metadata.pageCount &lt; 0 || metadata.pageCount &gt; 10000)) {
      result.warnings.push(`Unusual page count: ${metadata.pageCount}`);
    }
    
    // Validate word count
    if (metadata.wordCount !== undefined &amp;&amp; (metadata.wordCount &lt; 0 || metadata.wordCount &gt; 1000000)) {
      result.warnings.push(`Unusual word count: ${metadata.wordCount}`);
    }
    
    // Validate reading time
    if (metadata.readingTimeMinutes !== undefined &amp;&amp;
        (metadata.readingTimeMinutes &lt; 0 || metadata.readingTimeMinutes &gt; 720)) {
      result.warnings.push(`Unusual reading time: ${metadata.readingTimeMinutes} minutes`);
    }
    
    // Check for missing important metadata
    if (!metadata.title) {
      result.warnings.push(&apos;No title found in document&apos;);
    }
    
    if (!metadata.language) {
      result.warnings.push(&apos;Could not detect document language&apos;);
    }
  }
}

// Singleton instance
export const metadataExtractor = new MetadataExtractor();</file><file path="src/services/rag/packageValidator.ts">import type { PreprocessedPackage, PackageValidationResult } from &apos;@/types/preprocessed&apos;;

export class PackageValidator {
  /**
   * Validate a preprocessed package format and structure
   */
  async validatePackage(packageData: any): Promise&lt;PackageValidationResult&gt; {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // Check if package data exists
      if (!packageData || typeof packageData !== &apos;object&apos;) {
        return {
          isValid: false,
          version: &apos;unknown&apos;,
          errors: [&apos;Package data is missing or invalid&apos;],
          warnings
        };
      }

      // Extract version
      const version = packageData.format_version || &apos;unknown&apos;;

      // Validate format version
      if (!packageData.format_version) {
        errors.push(&apos;Missing format_version field&apos;);
      } else if (typeof packageData.format_version !== &apos;string&apos;) {
        errors.push(&apos;format_version must be a string&apos;);
      } else if (!this.isSupportedVersion(packageData.format_version)) {
        errors.push(`Unsupported format version: ${packageData.format_version}. Supported versions: 1.0`);
      }

      // Validate export_metadata
      const exportMetaValidation = this.validateExportMetadata(packageData.export_metadata);
      errors.push(...exportMetaValidation.errors);
      warnings.push(...exportMetaValidation.warnings);

      // Validate document_metadata
      const docMetaValidation = this.validateDocumentMetadata(packageData.document_metadata);
      errors.push(...docMetaValidation.errors);
      warnings.push(...docMetaValidation.warnings);

      // Validate chunks
      const chunksValidation = this.validateChunks(packageData.chunks, packageData.document_metadata);
      errors.push(...chunksValidation.errors);
      warnings.push(...chunksValidation.warnings);

      // Validate export_stats if present
      if (packageData.export_stats) {
        const statsValidation = this.validateExportStats(packageData.export_stats);
        errors.push(...statsValidation.errors);
        warnings.push(...statsValidation.warnings);
      }

      return {
        isValid: errors.length === 0,
        version,
        errors,
        warnings
      };

    } catch (error) {
      return {
        isValid: false,
        version: &apos;unknown&apos;,
        errors: [`Validation error: ${error instanceof Error ? error.message : &apos;Unknown error&apos;}`],
        warnings
      };
    }
  }

  private isSupportedVersion(version: string): boolean {
    const supportedVersions = [&apos;1.0&apos;];
    return supportedVersions.includes(version);
  }

  private validateExportMetadata(exportMeta: any): { errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!exportMeta) {
      errors.push(&apos;Missing export_metadata section&apos;);
      return { errors, warnings };
    }

    if (typeof exportMeta !== &apos;object&apos;) {
      errors.push(&apos;export_metadata must be an object&apos;);
      return { errors, warnings };
    }

    // Required fields
    const requiredFields = [&apos;exported_at&apos;, &apos;source_system&apos;, &apos;document_id&apos;, &apos;session_id&apos;];
    for (const field of requiredFields) {
      if (!exportMeta[field]) {
        errors.push(`Missing required field in export_metadata: ${field}`);
      } else if (typeof exportMeta[field] !== &apos;string&apos;) {
        errors.push(`export_metadata.${field} must be a string`);
      }
    }

    // Validate exported_at format
    if (exportMeta.exported_at) {
      try {
        const exportDate = new Date(exportMeta.exported_at);
        if (isNaN(exportDate.getTime())) {
          errors.push(&apos;export_metadata.exported_at is not a valid ISO date&apos;);
        }
      } catch {
        errors.push(&apos;export_metadata.exported_at is not a valid date format&apos;);
      }
    }

    // Validate source_system
    if (exportMeta.source_system &amp;&amp; exportMeta.source_system !== &apos;LocalDocs AI&apos;) {
      warnings.push(`Unusual source_system: ${exportMeta.source_system}. Expected &apos;LocalDocs AI&apos;`);
    }

    return { errors, warnings };
  }

  private validateDocumentMetadata(docMeta: any): { errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!docMeta) {
      errors.push(&apos;Missing document_metadata section&apos;);
      return { errors, warnings };
    }

    if (typeof docMeta !== &apos;object&apos;) {
      errors.push(&apos;document_metadata must be an object&apos;);
      return { errors, warnings };
    }

    // Required fields
    const requiredFields = [&apos;id&apos;, &apos;filename&apos;, &apos;file_size&apos;, &apos;page_count&apos;, &apos;chunk_count&apos;, &apos;embedding_model&apos;];
    for (const field of requiredFields) {
      if (docMeta[field] === undefined || docMeta[field] === null) {
        errors.push(`Missing required field in document_metadata: ${field}`);
      }
    }

    // Type validation
    if (docMeta.file_size !== undefined &amp;&amp; typeof docMeta.file_size !== &apos;number&apos;) {
      errors.push(&apos;document_metadata.file_size must be a number&apos;);
    }

    if (docMeta.page_count !== undefined &amp;&amp; typeof docMeta.page_count !== &apos;number&apos;) {
      errors.push(&apos;document_metadata.page_count must be a number&apos;);
    }

    if (docMeta.chunk_count !== undefined &amp;&amp; typeof docMeta.chunk_count !== &apos;number&apos;) {
      errors.push(&apos;document_metadata.chunk_count must be a number&apos;);
    }

    // Validate file size
    if (docMeta.file_size !== undefined &amp;&amp; docMeta.file_size &lt; 0) {
      errors.push(&apos;document_metadata.file_size must be non-negative&apos;);
    }

    // Validate page count
    if (docMeta.page_count !== undefined &amp;&amp; docMeta.page_count &lt; 1) {
      errors.push(&apos;document_metadata.page_count must be at least 1&apos;);
    }

    // Validate chunk count
    if (docMeta.chunk_count !== undefined &amp;&amp; docMeta.chunk_count &lt; 1) {
      errors.push(&apos;document_metadata.chunk_count must be at least 1&apos;);
    }

    // Validate embedding model
    if (docMeta.embedding_model &amp;&amp; typeof docMeta.embedding_model === &apos;string&apos;) {
      const supportedModels = [&apos;gemini-embedding-001&apos;, &apos;text-embedding-004&apos;, &apos;models/text-embedding-004&apos;];
      if (!supportedModels.includes(docMeta.embedding_model)) {
        warnings.push(`Unknown embedding model: ${docMeta.embedding_model}`);
      }
    }

    // Validate chunk_settings
    if (docMeta.chunk_settings) {
      const chunkSettingsValidation = this.validateChunkSettings(docMeta.chunk_settings);
      errors.push(...chunkSettingsValidation.errors);
      warnings.push(...chunkSettingsValidation.warnings);
    }

    return { errors, warnings };
  }

  private validateChunkSettings(chunkSettings: any): { errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (typeof chunkSettings !== &apos;object&apos;) {
      errors.push(&apos;chunk_settings must be an object&apos;);
      return { errors, warnings };
    }

    if (chunkSettings.chunk_size !== undefined) {
      if (typeof chunkSettings.chunk_size !== &apos;number&apos;) {
        errors.push(&apos;chunk_settings.chunk_size must be a number&apos;);
      } else if (chunkSettings.chunk_size &lt; 100 || chunkSettings.chunk_size &gt; 8000) {
        warnings.push(`Unusual chunk_size: ${chunkSettings.chunk_size}. Expected range: 100-8000`);
      }
    }

    if (chunkSettings.chunk_overlap !== undefined) {
      if (typeof chunkSettings.chunk_overlap !== &apos;number&apos;) {
        errors.push(&apos;chunk_settings.chunk_overlap must be a number&apos;);
      } else if (chunkSettings.chunk_overlap &lt; 0 || chunkSettings.chunk_overlap &gt; 1000) {
        warnings.push(`Unusual chunk_overlap: ${chunkSettings.chunk_overlap}. Expected range: 0-1000`);
      }
    }

    return { errors, warnings };
  }

  private validateChunks(chunks: any, docMeta: any): { errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!chunks) {
      errors.push(&apos;Missing chunks array&apos;);
      return { errors, warnings };
    }

    if (!Array.isArray(chunks)) {
      errors.push(&apos;chunks must be an array&apos;);
      return { errors, warnings };
    }

    if (chunks.length === 0) {
      errors.push(&apos;chunks array cannot be empty&apos;);
      return { errors, warnings };
    }

    // Check chunk count matches metadata
    if (docMeta &amp;&amp; docMeta.chunk_count &amp;&amp; chunks.length !== docMeta.chunk_count) {
      warnings.push(`Chunk count mismatch: metadata says ${docMeta.chunk_count}, but found ${chunks.length} chunks`);
    }

    // Validate each chunk
    for (let i = 0; i &lt; chunks.length; i++) {
      const chunkValidation = this.validateChunk(chunks[i], i);
      errors.push(...chunkValidation.errors);
      warnings.push(...chunkValidation.warnings);
    }

    return { errors, warnings };
  }

  private validateChunk(chunk: any, index: number): { errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!chunk || typeof chunk !== &apos;object&apos;) {
      errors.push(`Chunk ${index} is not a valid object`);
      return { errors, warnings };
    }

    // Required fields
    const requiredFields = [&apos;id&apos;, &apos;text&apos;, &apos;embedding&apos;, &apos;metadata&apos;];
    for (const field of requiredFields) {
      if (chunk[field] === undefined || chunk[field] === null) {
        errors.push(`Chunk ${index}: Missing required field: ${field}`);
      }
    }

    // Validate id
    if (chunk.id &amp;&amp; typeof chunk.id !== &apos;string&apos;) {
      errors.push(`Chunk ${index}: id must be a string`);
    }

    // Validate text
    if (chunk.text !== undefined) {
      if (typeof chunk.text !== &apos;string&apos;) {
        errors.push(`Chunk ${index}: text must be a string`);
      } else if (chunk.text.trim().length === 0) {
        warnings.push(`Chunk ${index}: text is empty or whitespace only`);
      } else if (chunk.text.length &gt; 10000) {
        warnings.push(`Chunk ${index}: text is very long (${chunk.text.length} characters)`);
      }
    }

    // Validate embedding
    if (chunk.embedding !== undefined) {
      if (!Array.isArray(chunk.embedding)) {
        errors.push(`Chunk ${index}: embedding must be an array`);
      } else {
        // Check embedding dimensions
        if (chunk.embedding.length !== 768) {
          errors.push(`Chunk ${index}: embedding must have 768 dimensions, found ${chunk.embedding.length}`);
        }

        // Check for invalid values
        for (let j = 0; j &lt; chunk.embedding.length; j++) {
          const val = chunk.embedding[j];
          if (typeof val !== &apos;number&apos; || !isFinite(val)) {
            errors.push(`Chunk ${index}: embedding contains invalid value at index ${j}: ${val}`);
            break;
          }
        }
      }
    }

    // Validate metadata
    if (chunk.metadata !== undefined) {
      if (typeof chunk.metadata !== &apos;object&apos;) {
        errors.push(`Chunk ${index}: metadata must be an object`);
      } else {
        // Check for expected metadata fields
        if (chunk.metadata.page !== undefined &amp;&amp; typeof chunk.metadata.page !== &apos;number&apos;) {
          errors.push(`Chunk ${index}: metadata.page must be a number`);
        }

        if (chunk.metadata.chunk_index !== undefined &amp;&amp; typeof chunk.metadata.chunk_index !== &apos;number&apos;) {
          errors.push(`Chunk ${index}: metadata.chunk_index must be a number`);
        }

        if (chunk.metadata.source !== undefined &amp;&amp; typeof chunk.metadata.source !== &apos;string&apos;) {
          errors.push(`Chunk ${index}: metadata.source must be a string`);
        }
      }
    }

    // Validate embedding_dimensions if present
    if (chunk.embedding_dimensions !== undefined) {
      if (typeof chunk.embedding_dimensions !== &apos;number&apos;) {
        errors.push(`Chunk ${index}: embedding_dimensions must be a number`);
      } else if (chunk.embedding &amp;&amp; chunk.embedding.length !== chunk.embedding_dimensions) {
        errors.push(`Chunk ${index}: embedding_dimensions (${chunk.embedding_dimensions}) doesn&apos;t match actual embedding length (${chunk.embedding.length})`);
      }
    }

    return { errors, warnings };
  }

  private validateExportStats(exportStats: any): { errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (typeof exportStats !== &apos;object&apos;) {
      errors.push(&apos;export_stats must be an object&apos;);
      return { errors, warnings };
    }

    // Common export stats fields (optional)
    const optionalFields = [&apos;total_documents&apos;, &apos;total_chunks&apos;, &apos;total_tokens&apos;, &apos;processing_time_seconds&apos;];
    for (const field of optionalFields) {
      if (exportStats[field] !== undefined &amp;&amp; typeof exportStats[field] !== &apos;number&apos;) {
        errors.push(`export_stats.${field} must be a number`);
      }
    }

    return { errors, warnings };
  }
}

// Singleton instance
export const packageValidator = new PackageValidator();</file><file path="src/services/rag/progressTracker.ts">/**
 * Progress Tracker Service
 * 
 * Provides comprehensive progress tracking for document processing operations
 * with real-time updates, detailed status information, and time estimates.
 */

export interface ProgressStep {
  id: string;
  name: string;
  description: string;
  status: &apos;pending&apos; | &apos;in_progress&apos; | &apos;completed&apos; | &apos;error&apos; | &apos;skipped&apos;;
  progress: number; // 0-100
  startTime?: number;
  endTime?: number;
  duration?: number;
  error?: string;
  metadata?: Record&lt;string, any&gt;;
}

export interface ProgressOperation {
  id: string;
  type: &apos;document_ingestion&apos; | &apos;vector_search&apos; | &apos;chat_generation&apos; | &apos;batch_processing&apos;;
  title: string;
  description: string;
  status: &apos;pending&apos; | &apos;in_progress&apos; | &apos;completed&apos; | &apos;error&apos; | &apos;cancelled&apos;;
  progress: number; // 0-100
  startTime: number;
  endTime?: number;
  duration?: number;
  estimatedDuration?: number;
  currentStep?: string;
  steps: ProgressStep[];
  metadata: {
    sessionId?: string;
    documentId?: string;
    fileName?: string;
    totalItems?: number;
    processedItems?: number;
    [key: string]: any;
  };
  error?: string;
  cancellable: boolean;
  cancelled?: boolean;
}

export interface ProgressEvent {
  operationId: string;
  type: &apos;start&apos; | &apos;progress&apos; | &apos;step_start&apos; | &apos;step_progress&apos; | &apos;step_complete&apos; | &apos;complete&apos; | &apos;error&apos; | &apos;cancel&apos;;
  data: any;
  timestamp: number;
}

export interface ProgressCallback {
  (event: ProgressEvent): void;
}

class ProgressTracker {
  private operations: Map&lt;string, ProgressOperation&gt; = new Map();
  private listeners: Map&lt;string, ProgressCallback[]&gt; = new Map();
  private globalListeners: ProgressCallback[] = [];

  /**
   * Create a new progress tracking operation
   */
  createOperation(config: Omit&lt;ProgressOperation, &apos;id&apos; | &apos;startTime&apos; | &apos;progress&apos; | &apos;status&apos; | &apos;steps&apos;&gt;): ProgressOperation {
    const operation: ProgressOperation = {
      id: this.generateId(),
      startTime: Date.now(),
      progress: 0,
      status: &apos;pending&apos;,
      steps: [],
      ...config
    };

    this.operations.set(operation.id, operation);
    this.emitEvent(operation.id, &apos;start&apos;, { operation });
    
    return operation;
  }

  /**
   * Generate a unique ID for operations and steps
   */
  private generateId(): string {
    return `progress_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Add a step to an operation
   */
  addStep(operationId: string, stepConfig: Omit&lt;ProgressStep, &apos;id&apos; | &apos;status&apos; | &apos;progress&apos;&gt;): ProgressStep {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    const step: ProgressStep = {
      id: this.generateId(),
      status: &apos;pending&apos;,
      progress: 0,
      ...stepConfig
    };

    operation.steps.push(step);
    return step;
  }

  /**
   * Start an operation
   */
  startOperation(operationId: string): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    operation.status = &apos;in_progress&apos;;
    operation.startTime = Date.now();
    this.emitEvent(operationId, &apos;start&apos;, { operation });
  }

  /**
   * Start a step within an operation
   */
  startStep(operationId: string, stepId: string): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    const step = operation.steps.find(s =&gt; s.id === stepId);
    if (!step) {
      throw new Error(`Step ${stepId} not found in operation ${operationId}`);
    }

    step.status = &apos;in_progress&apos;;
    step.startTime = Date.now();
    operation.currentStep = stepId;
    
    this.updateOperationProgress(operationId);
    this.emitEvent(operationId, &apos;step_start&apos;, { step });
  }

  /**
   * Update progress for a step
   */
  updateStepProgress(operationId: string, stepId: string, progress: number, metadata?: any): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    const step = operation.steps.find(s =&gt; s.id === stepId);
    if (!step) {
      throw new Error(`Step ${stepId} not found in operation ${operationId}`);
    }

    step.progress = Math.min(100, Math.max(0, progress));
    if (metadata) {
      step.metadata = { ...step.metadata, ...metadata };
    }

    this.updateOperationProgress(operationId);
    this.emitEvent(operationId, &apos;step_progress&apos;, { step, progress });
  }

  /**
   * Complete a step
   */
  completeStep(operationId: string, stepId: string, metadata?: any): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    const step = operation.steps.find(s =&gt; s.id === stepId);
    if (!step) {
      throw new Error(`Step ${stepId} not found in operation ${operationId}`);
    }

    step.status = &apos;completed&apos;;
    step.progress = 100;
    step.endTime = Date.now();
    step.duration = step.endTime - (step.startTime || step.endTime);
    
    if (metadata) {
      step.metadata = { ...step.metadata, ...metadata };
    }

    this.updateOperationProgress(operationId);
    this.emitEvent(operationId, &apos;step_complete&apos;, { step });
  }

  /**
   * Mark a step as failed
   */
  failStep(operationId: string, stepId: string, error: string): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    const step = operation.steps.find(s =&gt; s.id === stepId);
    if (!step) {
      throw new Error(`Step ${stepId} not found in operation ${operationId}`);
    }

    step.status = &apos;error&apos;;
    step.endTime = Date.now();
    step.duration = step.endTime - (step.startTime || step.endTime);
    step.error = error;

    this.emitEvent(operationId, &apos;error&apos;, { step, error });
  }

  /**
   * Skip a step
   */
  skipStep(operationId: string, stepId: string, reason?: string): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    const step = operation.steps.find(s =&gt; s.id === stepId);
    if (!step) {
      throw new Error(`Step ${stepId} not found in operation ${operationId}`);
    }

    step.status = &apos;skipped&apos;;
    step.progress = 100;
    step.endTime = Date.now();
    
    if (reason) {
      step.metadata = { ...step.metadata, skipReason: reason };
    }

    this.updateOperationProgress(operationId);
  }

  /**
   * Update overall operation progress based on steps
   */
  private updateOperationProgress(operationId: string): void {
    const operation = this.operations.get(operationId);
    if (!operation || operation.steps.length === 0) {
      return;
    }

    const totalSteps = operation.steps.length;
    const completedSteps = operation.steps.filter(s =&gt; s.status === &apos;completed&apos; || s.status === &apos;skipped&apos;).length;
    const inProgressSteps = operation.steps.filter(s =&gt; s.status === &apos;in_progress&apos;);
    
    let progress = (completedSteps / totalSteps) * 100;
    
    // Add progress from currently running step
    if (inProgressSteps.length &gt; 0) {
      const stepProgress = inProgressSteps.reduce((sum, step) =&gt; sum + step.progress, 0) / inProgressSteps.length;
      progress += (stepProgress / totalSteps);
    }

    operation.progress = Math.min(100, Math.max(0, progress));
    
    // Update processed items count if available
    if (operation.metadata.totalItems) {
      operation.metadata.processedItems = Math.floor((operation.progress / 100) * operation.metadata.totalItems);
    }

    this.emitEvent(operationId, &apos;progress&apos;, {
      progress: operation.progress,
      processedItems: operation.metadata.processedItems
    });
  }

  /**
   * Complete an operation
   */
  completeOperation(operationId: string, metadata?: any): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    operation.status = &apos;completed&apos;;
    operation.progress = 100;
    operation.endTime = Date.now();
    operation.duration = operation.endTime - operation.startTime;
    operation.currentStep = undefined;
    
    if (metadata) {
      operation.metadata = { ...operation.metadata, ...metadata };
    }

    // Complete any remaining in-progress steps
    operation.steps.forEach(step =&gt; {
      if (step.status === &apos;in_progress&apos;) {
        step.status = &apos;completed&apos;;
        step.progress = 100;
        step.endTime = operation.endTime;
        if (step.endTime) {
          step.duration = step.endTime - (step.startTime || step.endTime);
        }
      }
    });

    this.emitEvent(operationId, &apos;complete&apos;, { operation });
  }

  /**
   * Fail an operation
   */
  failOperation(operationId: string, error: string): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    operation.status = &apos;error&apos;;
    operation.endTime = Date.now();
    operation.duration = operation.endTime - operation.startTime;
    operation.error = error;
    operation.currentStep = undefined;

    this.emitEvent(operationId, &apos;error&apos;, { operation, error });
  }

  /**
   * Cancel an operation
   */
  cancelOperation(operationId: string, reason?: string): void {
    const operation = this.operations.get(operationId);
    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    if (!operation.cancellable) {
      throw new Error(`Operation ${operationId} is not cancellable`);
    }

    operation.status = &apos;cancelled&apos;;
    operation.endTime = Date.now();
    operation.duration = operation.endTime - operation.startTime;
    operation.cancelled = true;
    operation.currentStep = undefined;

    if (reason) {
      operation.metadata = { ...operation.metadata, cancelReason: reason };
    }

    this.emitEvent(operationId, &apos;cancel&apos;, { operation, reason });
  }

  /**
   * Get operation by ID
   */
  getOperation(operationId: string): ProgressOperation | undefined {
    return this.operations.get(operationId);
  }

  /**
   * Get all operations
   */
  getAllOperations(): ProgressOperation[] {
    return Array.from(this.operations.values());
  }

  /**
   * Get operations by status
   */
  getOperationsByStatus(status: ProgressOperation[&apos;status&apos;]): ProgressOperation[] {
    return Array.from(this.operations.values()).filter(op =&gt; op.status === status);
  }

  /**
   * Get active operations (pending or in_progress)
   */
  getActiveOperations(): ProgressOperation[] {
    return Array.from(this.operations.values()).filter(op =&gt;
      op.status === &apos;pending&apos; || op.status === &apos;in_progress&apos;
    );
  }

  /**
   * Clean up completed operations older than specified time
   */
  cleanup(olderThanMs: number = 3600000): string[] { // Default 1 hour
    const cutoff = Date.now() - olderThanMs;
    const toRemove: string[] = [];

    this.operations.forEach((operation, id) =&gt; {
      if (
        (operation.status === &apos;completed&apos; || operation.status === &apos;error&apos; || operation.status === &apos;cancelled&apos;) &amp;&amp;
        operation.endTime &amp;&amp;
        operation.endTime &lt; cutoff
      ) {
        toRemove.push(id);
      }
    });

    toRemove.forEach(id =&gt; {
      this.operations.delete(id);
      this.listeners.delete(id);
    });

    return toRemove;
  }

  /**
   * Add event listener for specific operation
   */
  addListener(operationId: string, callback: ProgressCallback): void {
    if (!this.listeners.has(operationId)) {
      this.listeners.set(operationId, []);
    }
    this.listeners.get(operationId)!.push(callback);
  }

  /**
   * Add global event listener for all operations
   */
  addGlobalListener(callback: ProgressCallback): void {
    this.globalListeners.push(callback);
  }

  /**
   * Remove event listener
   */
  removeListener(operationId: string, callback: ProgressCallback): void {
    const listeners = this.listeners.get(operationId);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index &gt; -1) {
        listeners.splice(index, 1);
      }
    }
  }

  /**
   * Remove global event listener
   */
  removeGlobalListener(callback: ProgressCallback): void {
    const index = this.globalListeners.indexOf(callback);
    if (index &gt; -1) {
      this.globalListeners.splice(index, 1);
    }
  }

  /**
   * Emit progress event
   */
  private emitEvent(operationId: string, type: ProgressEvent[&apos;type&apos;], data: any): void {
    const event: ProgressEvent = {
      operationId,
      type,
      data,
      timestamp: Date.now()
    };

    // Notify operation-specific listeners
    const listeners = this.listeners.get(operationId);
    if (listeners) {
      listeners.forEach(callback =&gt; {
        try {
          callback(event);
        } catch (error) {
          console.error(&apos;Error in progress listener:&apos;, error);
        }
      });
    }

    // Notify global listeners
    this.globalListeners.forEach(callback =&gt; {
      try {
        callback(event);
      } catch (error) {
        console.error(&apos;Error in global progress listener:&apos;, error);
      }
    });
  }

  /**
   * Get operation statistics
   */
  getStats(): {
    total: number;
    pending: number;
    inProgress: number;
    completed: number;
    error: number;
    cancelled: number;
    averageDuration: number;
  } {
    const operations = Array.from(this.operations.values());
    
    return {
      total: operations.length,
      pending: operations.filter(op =&gt; op.status === &apos;pending&apos;).length,
      inProgress: operations.filter(op =&gt; op.status === &apos;in_progress&apos;).length,
      completed: operations.filter(op =&gt; op.status === &apos;completed&apos;).length,
      error: operations.filter(op =&gt; op.status === &apos;error&apos;).length,
      cancelled: operations.filter(op =&gt; op.status === &apos;cancelled&apos;).length,
      averageDuration: operations
        .filter(op =&gt; op.duration !== undefined)
        .reduce((sum, op) =&gt; sum + (op.duration || 0), 0) /
        operations.filter(op =&gt; op.duration !== undefined).length || 0
    };
  }
}

// Singleton instance
export const progressTracker = new ProgressTracker();

// Convenience functions for common operations
export function createDocumentIngestionOperation(config: {
  sessionId: string;
  documentId: string;
  fileName: string;
  totalChunks?: number;
}): ProgressOperation {
  return progressTracker.createOperation({
    type: &apos;document_ingestion&apos;,
    title: `Processing ${config.fileName}`,
    description: &apos;Ingesting document and processing embeddings&apos;,
    cancellable: true,
    metadata: {
      sessionId: config.sessionId,
      documentId: config.documentId,
      fileName: config.fileName,
      totalItems: config.totalChunks
    }
  });
}

export function createVectorSearchOperation(config: {
  sessionId: string;
  query: string;
}): ProgressOperation {
  return progressTracker.createOperation({
    type: &apos;vector_search&apos;,
    title: &apos;Searching documents&apos;,
    description: `Finding relevant content for: &quot;${config.query.substring(0, 50)}...&quot;`,
    cancellable: false,
    metadata: {
      sessionId: config.sessionId,
      query: config.query
    }
  });
}

export function createChatGenerationOperation(config: {
  sessionId: string;
  messageCount?: number;
}): ProgressOperation {
  return progressTracker.createOperation({
    type: &apos;chat_generation&apos;,
    title: &apos;Generating response&apos;,
    description: &apos;Creating AI response with citations&apos;,
    cancellable: true,
    metadata: {
      sessionId: config.sessionId,
      messageCount: config.messageCount
    }
  });
}</file><file path="src/services/index.ts">// Main services export file
export * from &apos;./indexedDB&apos;;
export * from &apos;./gemini&apos;;
export * from &apos;./rag&apos;;
export * from &apos;./libraryService&apos;;

// Service factory for easy dependency injection
import { getIndexedDBServices } from &apos;./indexedDB&apos;;
import { geminiService, embeddingService, chatService } from &apos;./gemini&apos;;
import { vectorSearchService, documentProcessor, chatPipeline } from &apos;./rag&apos;;
import { libraryService } from &apos;./libraryService&apos;;

export const services = {
  // IndexedDB services
  indexedDB: getIndexedDBServices(),
  
  // Gemini API services
  gemini: geminiService,
  embedding: embeddingService,
  chat: chatService,
  
  // RAG services
  vectorSearch: vectorSearchService,
  documentProcessor: documentProcessor,
  chatPipeline: chatPipeline,
  
  // Library service
  library: libraryService,
};

export default services;</file><file path="src/services/libraryService.ts">import { LibraryItem } from &apos;@/types/library&apos;;

// ---------------- CONFIGURATION ----------------
const HF_USER = &apos;prayas12&apos;; 
const HF_REPO = &apos;meddy-library&apos;;
// &quot;resolve/main&quot; ensures we get the raw file from the latest commit
const BASE_URL = `https://huggingface.co/datasets/${HF_USER}/${HF_REPO}/resolve/main`;
// -----------------------------------------------

export const libraryService = {
  /**
   * Fetches the list of available books from library.json
   */
  async getAvailableBooks(): Promise&lt;LibraryItem[]&gt; {
    try {
      const response = await fetch(`${BASE_URL}/library.json`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch library index: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // Map the raw JSON to include the full download URL
      return data.map((item: any) =&gt; ({
        ...item,
        url: `${BASE_URL}/${item.filename}`
      }));
    } catch (error) {
      console.error(&quot;Library Index Error:&quot;, error);
      throw error;
    }
  },

  /**
   * Downloads and decompresses a .json.gz file directly into a JSON object
   * Uses the browser&apos;s native DecompressionStream for performance
   */
  async downloadAndParseBook(url: string): Promise&lt;any&gt; {
    console.log(`[Library] Starting download: ${url}`);
    const response = await fetch(url);
    
    if (!response.ok) throw new Error(`Download failed: ${response.statusText}`);
    if (!response.body) throw new Error(&quot;ReadableStream not supported by browser&quot;);

    // 1. Create a stream for decompression
    const ds = new DecompressionStream(&apos;gzip&apos;);
    
    // 2. Pipe the download stream through the decompressor
    const decompressedStream = response.body.pipeThrough(ds);
    
    // 3. Convert the stream into a Response object to easily parse JSON
    // This prevents having to buffer the whole string in JS memory manually
    const jsonResponse = new Response(decompressedStream);
    
    console.log(`[Library] Decompression complete, parsing JSON...`);
    return await jsonResponse.json();
  }
};</file><file path="src/store/index.ts">// Main store exports
export { useSessionStore } from &apos;./sessionStore&apos;;
export { useChatStore } from &apos;./chatStore&apos;;
export { useDocumentStore } from &apos;./documentStore&apos;;
export { useSettingsStore } from &apos;./settingsStore&apos;;

// Type exports
export type {
  SessionStore,
  ChatStore,
  DocumentStore,
  SettingsStore,
  AppStore
} from &apos;./types&apos;;

// Import the actual store hooks
import { useSessionStore } from &apos;./sessionStore&apos;;
import { useChatStore } from &apos;./chatStore&apos;;
import { useDocumentStore } from &apos;./documentStore&apos;;
import { useSettingsStore } from &apos;./settingsStore&apos;;

// For now, just export individual stores
// We can create a combined store later if needed for complex cross-store operations

// Export individual hooks for convenience
export const useSessions = () =&gt; {
  const sessionStore = useSessionStore();
  return {
    sessions: sessionStore.sessions,
    currentSession: sessionStore.currentSession,
    currentSessionId: sessionStore.currentSessionId,
    isLoading: sessionStore.isLoading,
    error: sessionStore.error,
    userId: sessionStore.userId,
    loadSessions: sessionStore.loadSessions,
    createSession: sessionStore.createSession,
    updateSession: sessionStore.updateSession,
    deleteSession: sessionStore.deleteSession,
    setCurrentSession: sessionStore.setCurrentSession,
    setCurrentSessionId: sessionStore.setCurrentSessionId,
  };
};

export const useChat = () =&gt; {
  const chatStore = useChatStore();
  return {
    messages: chatStore.messages,
    isStreaming: chatStore.isStreaming,
    streamingContent: chatStore.streamingContent,
    streamingCitations: chatStore.streamingCitations,
    error: chatStore.error,
    loadMessages: chatStore.loadMessages,
    sendMessage: chatStore.sendMessage,
    clearHistory: chatStore.clearHistory,
    setStreamingState: chatStore.setStreamingState,
    addMessage: chatStore.addMessage,
    setError: chatStore.setError,
  };
};

export const useDocuments = () =&gt; {
  const documentStore = useDocumentStore();
  return {
    documents: documentStore.documents,
    progressMap: documentStore.progressMap,
    isUploading: documentStore.isUploading,
    error: documentStore.error,
    loadDocuments: documentStore.loadDocuments,
    uploadDocuments: documentStore.uploadDocuments,
    updateDocument: documentStore.updateDocument,
    deleteDocument: documentStore.deleteDocument,
    setProgress: documentStore.setProgress,
    clearProgress: documentStore.clearProgress,
    setUploading: documentStore.setUploading,
  };
};

export const useSettings = () =&gt; {
  const settingsStore = useSettingsStore();
  return {
    settings: settingsStore.settings,
    isLoading: settingsStore.isLoading,
    error: settingsStore.error,
    userId: settingsStore.userId,
    loadSettings: settingsStore.loadSettings,
    updateSettings: settingsStore.updateSettings,
    resetSettings: settingsStore.resetSettings,
    validateApiKey: settingsStore.validateApiKey,
    setLoading: settingsStore.setLoading,
    setError: settingsStore.setError,
  };
};</file><file path="src/store/sessionStore.ts">import { create } from &apos;zustand&apos;;
import { devtools, persist } from &apos;zustand/middleware&apos;;
import type { SessionStore, AppStore } from &apos;./types&apos;;
import type { Session, SessionCreate, SessionUpdate } from &apos;@/types&apos;;
import { getIndexedDBServices } from &apos;../services/indexedDB&apos;;
import { userIdLogger } from &apos;../utils/userIdDebugLogger&apos;;

// Helper function to get services (client-side only)
const getSessionService = () =&gt; {
  if (typeof window !== &apos;undefined&apos;) {
    const services = getIndexedDBServices();
    return services.sessionService;
  }
  return null;
};

export const useSessionStore = create&lt;SessionStore&gt;()(
  devtools(
    persist(
      (set, get) =&gt; ({
        // Initial state
        sessions: [],
        currentSession: null,
        currentSessionId: null,
        isLoading: false,
        error: null,
        userId: null,

        // Actions
        loadSessions: async (userId: string) =&gt; {
          // Only run on client side
          if (typeof window === &apos;undefined&apos;) {
            console.warn(&apos;[SESSION STORE] Skipping loadSessions during SSR&apos;);
            return;
          }
          
          const operationId = userIdLogger.logOperationStart(&apos;SessionStore&apos;, &apos;loadSessions&apos;, userId);
          
          set({ isLoading: true, error: null, userId });
          try {
            userIdLogger.logServiceCall(&apos;SessionStore&apos;, &apos;sessionService&apos;, &apos;getSessions&apos;, userId);
            const sessionService = getSessionService();
            if (!sessionService) {
              throw new Error(&apos;Session service not available&apos;);
            }
            const sessions = await sessionService.getSessions(userId);
            
            userIdLogger.logOperationEnd(&apos;SessionStore&apos;, operationId, userId);
            set({ sessions, isLoading: false });
          } catch (error) {
            userIdLogger.logError(&apos;SessionStore.loadSessions&apos;, error instanceof Error ? error : String(error), userId);
            set({
              isLoading: false,
              error: error instanceof Error ? error.message : &apos;Failed to load sessions&apos;
            });
          }
        },

        createSession: async (data: SessionCreate) =&gt; {
          // Only run on client side
          if (typeof window === &apos;undefined&apos;) {
            console.warn(&apos;[SESSION STORE] Skipping createSession during SSR&apos;);
            throw new Error(&apos;Cannot create session during SSR&apos;);
          }
          
          const { userId } = get();
          if (!userId) {
            const errorMsg = &apos;User ID not found. Please log in.&apos;;
            userIdLogger.logError(&apos;SessionStore.createSession&apos;, errorMsg, null);
            set({ error: errorMsg });
            throw new Error(&apos;User ID not found&apos;);
          }

          const operationId = userIdLogger.logOperationStart(&apos;SessionStore&apos;, &apos;createSession&apos;, userId);

          set({ isLoading: true, error: null });
          try {
            userIdLogger.logServiceCall(&apos;SessionStore&apos;, &apos;sessionService&apos;, &apos;createSession&apos;, userId);
            const sessionService = getSessionService();
            if (!sessionService) {
              throw new Error(&apos;Session service not available&apos;);
            }
            const newSession = await sessionService.createSession(data, userId);

            userIdLogger.logOperationEnd(&apos;SessionStore&apos;, operationId, userId);
            set(state =&gt; ({
              sessions: [newSession, ...state.sessions],
              isLoading: false
            }));

            return newSession;
          } catch (error) {
            userIdLogger.logError(&apos;SessionStore.createSession&apos;, error instanceof Error ? error : String(error), userId);
            set({
              isLoading: false,
              error: error instanceof Error ? error.message : &apos;Failed to create session&apos;
            });
            throw error;
          }
        },

        updateSession: async (id: string, data: SessionUpdate) =&gt; {
          set({ isLoading: true, error: null });
          try {
            const sessionService = getSessionService();
            if (!sessionService) {
              throw new Error(&apos;Session service not available&apos;);
            }
            await sessionService.updateSession(id, data);

            set(state =&gt; ({
              sessions: state.sessions.map(session =&gt;
                session.id === id
                  ? { ...session, ...data, updatedAt: new Date() }
                  : session
              ),
              currentSession: state.currentSession?.id === id
                ? { ...state.currentSession, ...data, updatedAt: new Date() }
                : state.currentSession,
              isLoading: false,
            }));
          } catch (error) {
            set({
              isLoading: false,
              error: error instanceof Error ? error.message : &apos;Failed to update session&apos;
            });
          }
        },

        deleteSession: async (id: string) =&gt; {
          set({ isLoading: true, error: null });
          try {
            const sessionService = getSessionService();
            if (!sessionService) {
              throw new Error(&apos;Session service not available&apos;);
            }
            await sessionService.deleteSession(id);

            set(state =&gt; ({
              sessions: state.sessions.filter(session =&gt; session.id !== id),
              currentSession: state.currentSession?.id === id ? null : state.currentSession,
              currentSessionId: state.currentSessionId === id ? null : state.currentSessionId,
              isLoading: false,
            }));
          } catch (error) {
            set({
              isLoading: false,
              error: error instanceof Error ? error.message : &apos;Failed to delete session&apos;
            });
          }
        },

        setCurrentSession: (session: Session | null) =&gt; {
          set({
            currentSession: session,
            currentSessionId: session?.id || null
          });
        },

        setCurrentSessionId: async (id: string | null) =&gt; {
          if (id) {
            try {
              const sessionService = getSessionService();
              if (!sessionService) {
                throw new Error(&apos;Session service not available&apos;);
              }
              const { userId } = get();
              const session = await sessionService.getSession(id, userId || undefined);
              set({
                currentSession: session,
                currentSessionId: id
              });
            } catch (error) {
              set({
                currentSession: null,
                currentSessionId: null,
                error: error instanceof Error ? error.message : &apos;Failed to load session&apos;
              });
            }
          } else {
            set({
              currentSession: null,
              currentSessionId: id
            });
          }
        },

        setError: (error: string | null) =&gt; {
          set({ error });
        },

        setUserId: (userId: string | null) =&gt; {
          userIdLogger.logStoreUpdate(&apos;SessionStore&apos;, userId, &apos;setUserId&apos;);
          set({ userId });
        },

        clearSessions: () =&gt; {
          userIdLogger.logStoreUpdate(&apos;SessionStore&apos;, null, &apos;clearSessions&apos;);
          set({
            sessions: [],
            currentSession: null,
            currentSessionId: null,
            userId: null,
            error: null
          });
        },
      }),
      {
        name: &apos;session-store&apos;,
        partialize: (state) =&gt; ({
          sessions: state.sessions,
          currentSessionId: state.currentSessionId,
          userId: state.userId,
        }),
      }
    ),
    {
      name: &apos;session-store&apos;,
    }
  )
);</file><file path="src/store/settingsStore.ts">import { create } from &apos;zustand&apos;;
import { devtools, persist } from &apos;zustand/middleware&apos;;
import type { SettingsStore } from &apos;./types&apos;;
import { AppSettings, SettingsUpdate } from &apos;@/types/settings&apos;;
import { getIndexedDBServices } from &apos;../services/indexedDB&apos;;

// Helper function to get services (client-side only)
const getSettingsService = () =&gt; {
  if (typeof window !== &apos;undefined&apos;) {
    const services = getIndexedDBServices();
    return services.settingsService;
  }
  return null;
};

export const useSettingsStore = create&lt;SettingsStore&gt;()(
  devtools(
    persist(
      (set, get) =&gt; ({
        // State
        settings: null,
        isLoading: false,
        error: null,
        userId: null,

        // Actions
        loadSettings: async (userId: string) =&gt; {
          // Only run on client side
          if (typeof window === &apos;undefined&apos;) {
            console.warn(&apos;[SETTINGS STORE] Skipping loadSettings during SSR&apos;);
            return;
          }
          
          set({ isLoading: true, error: null, userId });
          try {
            const settingsService = getSettingsService();
            if (!settingsService) {
              throw new Error(&apos;Settings service not available&apos;);
            }
            let settings = await settingsService.getSettings(userId);

            // If no settings exist, use defaults
            if (!settings) {
              settings = settingsService.getDefaultSettings(userId);
              await settingsService.updateSettings(settings, userId);
            }

            set({ settings, isLoading: false });
          } catch (error) {
            set({
              isLoading: false,
              error: error instanceof Error ? error.message : &apos;Failed to load settings&apos;,
            });
          }
        },

        updateSettings: async (newSettings: Partial&lt;AppSettings&gt;) =&gt; {
          // Only run on client side
          if (typeof window === &apos;undefined&apos;) {
            console.warn(&apos;[SETTINGS STORE] Skipping updateSettings during SSR&apos;);
            throw new Error(&apos;Cannot update settings during SSR&apos;);
          }
          
          const { userId } = get();
          if (!userId) {
            set({ error: &apos;User ID not found. Please log in.&apos; });
            throw new Error(&apos;User ID not found&apos;);
          }

          set({ isLoading: true, error: null });
          try {
            const settingsService = getSettingsService();
            if (!settingsService) {
              throw new Error(&apos;Settings service not available&apos;);
            }
            const updatedSettings = await settingsService.updateSettings(newSettings, userId);
            set({ settings: updatedSettings, isLoading: false });
          } catch (error) {
            set({
              isLoading: false,
              error: error instanceof Error ? error.message : &apos;Failed to update settings&apos;
            });
            throw error;
          }
        },

        resetSettings: async () =&gt; {
          const { userId } = get();
          if (!userId) {
            set({ error: &apos;User ID not found. Please log in.&apos; });
            throw new Error(&apos;User ID not found&apos;);
          }

          set({ isLoading: true, error: null });
          try {
            const settingsService = getSettingsService();
            if (!settingsService) {
              throw new Error(&apos;Settings service not available&apos;);
            }
            const defaultSettings = await settingsService.resetSettings(userId);
            set({ settings: defaultSettings, isLoading: false });
          } catch (error) {
            set({
              isLoading: false,
              error: error instanceof Error ? error.message : &apos;Failed to reset settings&apos;
            });
          }
        },

        validateApiKey: async (apiKey: string) =&gt; {
          try {
            // Basic format validation
            const geminiKeyPattern = /^AIza[0-9A-Za-z_-]{35}$/;
            if (!geminiKeyPattern.test(apiKey)) {
              return &apos;Invalid API key format&apos;;
            }
            return null;
          } catch (error) {
            return error instanceof Error ? error.message : &apos;API key validation failed&apos;;
          }
        },

        setUserId: (userId: string | null) =&gt; {
          set({ userId });
        },

        clearSettings: () =&gt; {
          set({
            settings: null,
            userId: null,
            error: null
          });
        },

        setLoading: (isLoading: boolean) =&gt; {
          set({ isLoading });
        },

        setError: (error: string | null) =&gt; {
          set({ error });
        },
      }),
      {
        name: &apos;settings-store&apos;,
        partialize: (state) =&gt; ({
          settings: state.settings,
          userId: state.userId,
        }),
      }
    )
  )
);</file><file path="src/types/citation.ts">// Simplified citation types for RAG chat application

export interface SimplifiedCitation {
  document: string;
  page: number;
  combinedContent: string; // Combined content from all chunks on this page
  sourceIndex: number; // Original source index from search results
  chunkIds: string[]; // IDs of all chunks that were combined
  similarity?: number; // Highest similarity score from the combined chunks
}

export interface SimplifiedCitationGroup {
  citations: SimplifiedCitation[];
  renumberedResponse: string;
  usedSourceIndices: number[];
  validationWarnings?: string[]; // Add validation warnings for simplified system
}

export interface PageGroup {
  documentId: string;
  documentTitle: string;
  page: number;
  chunks: Array&lt;{
    id: string;
    content: string;
    similarity: number;
  }&gt;;
}</file><file path="src/types/embedding.ts">// Embedding types for RAG chat application

export interface EmbeddingChunk {
  id: string;
  documentId: string;
  sessionId: string;
  chunkIndex: number;
  content: string;
  source?: string;
  page?: number;
  embedding: Float32Array;
  tokenCount: number;
  embeddingNorm: number;
  metadata: {
    pageNumber?: number;
    pageNumbers?: number[]; // Store multiple page numbers for combined chunks
    chunkIndex: number;
    startPosition: number;
    endPosition: number;
    tokenCount: number;
    embeddingNorm?: number;
    embeddingBytes?: ArrayBuffer;
    documentId?: string;
    sessionId?: string;
    source?: string;
    documentTitle?: string;
    documentAuthor?: string;
    documentLanguage?: string;
    embeddingModel?: string;
    combinedChunkIds?: string[]; // Store original chunk IDs for combined chunks
    isCombined?: boolean; // Flag to indicate if this is a combined chunk
    originalChunkCount?: number; // Number of original chunks combined
  };
  createdAt: Date;
}

export interface EmbeddingChunkCreate {
  documentId: string;
  sessionId: string;
  content: string;
  embedding: Float32Array;
  metadata: {
    pageNumber?: number;
    pageNumbers?: number[]; // Multiple pages for combined chunks
    chunkIndex: number;
    startPosition: number;
    endPosition: number;
    tokenCount: number;
    documentId?: string;
    sessionId?: string;
    source?: string;
    documentTitle?: string;
    documentAuthor?: string;
    documentLanguage?: string;
    embeddingModel?: string;
  };
}

export interface VectorSearchResult {
  chunk: EmbeddingChunk;
  similarity: number;
  document: {
    id: string;
    title: string;
    fileName: string;
  };
}

export interface EmbeddingGenerationRequest {
  chunks: string[];
  documentId: string;
  sessionId: string;
}

export interface EmbeddingGenerationProgress {
  totalChunks: number;
  processedChunks: number;
  currentChunk: string;
  isComplete: boolean;
  error?: string;
}</file><file path="src/types/index.ts">// Export all types from individual type files
export * from &apos;./session&apos;;
export * from &apos;./message&apos;;
export * from &apos;./document&apos;;
export * from &apos;./embedding&apos;;
export * from &apos;./settings&apos;;
export * from &apos;./preprocessed&apos;;
export * from &apos;./citation&apos;;
export * from &apos;./library&apos;;</file><file path="src/types/library.ts">export interface LibraryItem {
  id: string;
  name: string;
  description: string;
  filename: string;
  size: string;
  category: string;
  version: string;
  url: string; // Constructed dynamically in the service
}</file><file path="src/types/message.ts">export enum MessageSender {
  USER = &apos;user&apos;,
  ASSISTANT = &apos;assistant&apos;,
  SYSTEM = &apos;system&apos;,
}

export interface Message {
  id: string;
  sessionId: string;
  content: string;
  role: MessageSender;
  timestamp: Date;
  citations?: Citation[];
}

export interface Citation {
  document: string;
  page?: number;
  pages?: number[]; // Multiple pages for combined chunks
  pageRange?: string; // Formatted page range like &quot;5-7&quot; or &quot;5,7,9&quot;
  excerpt?: string;
  isCombined?: boolean; // Flag to indicate if this is from a combined chunk
  originalChunkCount?: number; // Number of original chunks combined
  combinedChunkIds?: string[]; // IDs of original chunks that were combined
}

export interface MessageCreate {
  sessionId: string;
  content: string;
  role: MessageSender;
  citations?: Citation[];
}

export interface ChatRequest {
  sessionId: string;
  message: string;
}

export interface ChatStreamEvent {
  type: &apos;userMessage&apos; | &apos;status&apos; | &apos;citations&apos; | &apos;textChunk&apos; | &apos;done&apos; | &apos;error&apos;;
  message?: string;
  citations?: Citation[];
}</file><file path="src/types/preprocessed.ts">// Preprocessed package types for RAG chat application

export interface PreprocessedPackage {
  format_version: string;
  export_metadata: {
    exported_at: string;
    source_system: string;
    document_id: string;
    session_id: string;
  };
  document_metadata: {
    id: string;
    filename: string;
    file_size: number;
    page_count: number;
    processed_at: string;
    created_at: string;
    chunk_count: number;
    embedding_model: string;
    chunk_settings: {
      chunk_size: number;
      chunk_overlap: number;
    };
  };
  chunks: PreprocessedChunk[];
}

// This interface is no longer needed as the new structure has chunks directly in the package
// export interface PreprocessedDocument {
//   id: string;
//   title: string;
//   fileName: string;
//   mimeType: string;
//   fileSize: number;
//   chunks: PreprocessedChunk[];
// }

export interface PreprocessedChunk {
  id: string;
  text: string;
  embedding: number[];
  metadata: {
    document_id: string;
    page: number;
    pageNumbers?: number[]; // Multiple pages for combined chunks
    chunk_index: number;
    source: string;
  };
  embedding_dimensions: number;
}

export interface PackageImportResult {
  success: boolean;
  sessionId: string;
  documentCount: number;
  chunkCount: number;
  error?: string;
}

export interface PackageValidationResult {
  isValid: boolean;
  version: string;
  errors: string[];
  warnings: string[];
}</file><file path="src/types/session.ts">// Session types for the RAG chat application

export interface Session {
  id: string;
  userId: string;
  name: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
  documentCount: number;
  messageCount?: number;
  lastMessageAt?: Date;
}

export interface SessionCreate {
  name: string;
  description?: string;
}

export interface SessionUpdate {
  name?: string;
  description?: string;
  updatedAt?: Date;
  documentCount?: number;
}</file><file path="src/utils/supabase/client.ts">import { createBrowserClient } from &apos;@supabase/ssr&apos;

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}</file><file path="src/utils/supabase/server.ts">import { createServerClient, type CookieOptions } from &apos;@supabase/ssr&apos;
import { cookies } from &apos;next/headers&apos;

export function createClient() {
    const cookieStore = cookies()

    return createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
            cookies: {
                get(name: string) {
                    return cookieStore.get(name)?.value
                },
                set(name: string, value: string, options: CookieOptions) {
                    try {
                        cookieStore.set({ name, value, ...options })
                    } catch (error) {
                        // The `set` method was called from a Server Component.
                        // This can be ignored if you have middleware refreshing
                        // user sessions.
                    }
                },
                remove(name: string, options: CookieOptions) {
                    try {
                        cookieStore.set({ name, value: &apos;&apos;, ...options })
                    } catch (error) {
                        // The `delete` method was called from a Server Component.
                        // This can be ignored if you have middleware refreshing
                        // user sessions.
                    }
                },
            },
        }
    )
}</file><file path="src/utils/date.ts">/**
 * Ensure the input is a Date object (handles string serialization from IndexedDB)
 */
export function ensureDate(date: Date | string | undefined | null): Date {
  // Handle undefined, null, or falsy values
  if (!date) {
    console.warn(&apos;No date provided, using current date&apos;);
    return new Date();
  }
  
  if (typeof date === &apos;string&apos;) {
    const dateObj = new Date(date);
    // Check if the date is valid
    if (isNaN(dateObj.getTime())) {
      // If invalid, return current date as fallback
      console.warn(&apos;Invalid date string provided, using current date:&apos;, date);
      return new Date();
    }
    return dateObj;
  }
  
  // Check if the Date object is valid
  if (isNaN(date.getTime())) {
    console.warn(&apos;Invalid Date object provided, using current date:&apos;, date);
    return new Date();
  }
  
  return date;
}

/**
 * Format date to short format (MMM d, yyyy)
 */
export function formatDateShort(date: Date | string | undefined | null): string {
  const dateObj = ensureDate(date);
  return dateObj.toLocaleDateString(&apos;en-US&apos;, {
    month: &apos;short&apos;,
    day: &apos;numeric&apos;,
    year: &apos;numeric&apos;,
  });
}

/**
 * Format date to long format with time
 */
export function formatDateLong(date: Date | string | undefined | null): string {
  const dateObj = ensureDate(date);
  return dateObj.toLocaleString(&apos;en-US&apos;, {
    month: &apos;long&apos;,
    day: &apos;numeric&apos;,
    year: &apos;numeric&apos;,
    hour: &apos;numeric&apos;,
    minute: &apos;2-digit&apos;,
    hour12: true,
  });
}

/**
 * Format time only (h:mm a)
 */
export function formatTime(date: Date | string | undefined | null): string {
  const dateObj = ensureDate(date);
  return dateObj.toLocaleTimeString(&apos;en-US&apos;, {
    hour: &apos;numeric&apos;,
    minute: &apos;2-digit&apos;,
    hour12: true,
  });
}

/**
 * Get relative time string
 */
export function getRelativeTime(date: Date | string | undefined | null): string {
  const dateObj = ensureDate(date);
  const now = new Date();
  const diff = now.getTime() - dateObj.getTime();
  
  const minutes = Math.floor(diff / (1000 * 60));
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  
  if (minutes &lt; 1) {
    return &apos;Just now&apos;;
  } else if (hours &lt; 1) {
    return `${minutes}m ago`;
  } else if (days &lt; 1) {
    return `${hours}h ago`;
  } else {
    return formatDateShort(dateObj);
  }
}

/**
 * Check if date is today
 */
export function isToday(date: Date | string | undefined | null): boolean {
  const dateObj = ensureDate(date);
  const today = new Date();
  return (
    dateObj.getDate() === today.getDate() &amp;&amp;
    dateObj.getMonth() === today.getMonth() &amp;&amp;
    dateObj.getFullYear() === today.getFullYear()
  );
}

/**
 * Check if date is yesterday
 */
export function isYesterday(date: Date | string | undefined | null): boolean {
  const dateObj = ensureDate(date);
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  
  return (
    dateObj.getDate() === yesterday.getDate() &amp;&amp;
    dateObj.getMonth() === yesterday.getMonth() &amp;&amp;
    dateObj.getFullYear() === yesterday.getFullYear()
  );
}</file><file path="src/utils/file.ts">/**
 * Format file size in bytes to human-readable format
 */
export const formatFileSize = (bytes: number): string =&gt; {
  if (bytes === 0) return &apos;0 Bytes&apos;;

  const k = 1024;
  const sizes = [&apos;Bytes&apos;, &apos;KB&apos;, &apos;MB&apos;, &apos;GB&apos;, &apos;TB&apos;];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &apos; &apos; + sizes[i];
};

/**
 * Get file extension from filename
 */
export const getFileExtension = (filename: string): string =&gt; {
  return filename.slice((filename.lastIndexOf(&apos;.&apos;) - 1 &gt;&gt;&gt; 0) + 2);
};

/**
 * Check if file is a supported document type
 */
export const isSupportedDocumentType = (filename: string): boolean =&gt; {
  const supportedTypes = [&apos;json&apos;];
  const extension = getFileExtension(filename).toLowerCase();
  return supportedTypes.includes(extension);
};

/**
 * Get MIME type from filename
 */
export const getMimeType = (filename: string): string =&gt; {
  const extension = getFileExtension(filename).toLowerCase();
  const mimeTypes: Record&lt;string, string&gt; = {
    json: &apos;application/json&apos;,
  };

  return mimeTypes[extension] || &apos;application/octet-stream&apos;;
};

/**
 * Generate a safe filename for storage
 */
export const generateSafeFilename = (filename: string): string =&gt; {
  // Remove special characters and replace with underscores
  return filename.replace(/[^a-zA-Z0-9.-]/g, &apos;_&apos;);
};

/**
 * Check if file size exceeds limit
 */
export const isFileSizeValid = (bytes: number, maxSizeInMB: number = 50): boolean =&gt; {
  const maxSizeInBytes = maxSizeInMB * 1024 * 1024;
  return bytes &lt;= maxSizeInBytes;
};</file><file path="src/utils/indentationAnalyzer.ts">/**
 * Indentation Analysis Utility
 * Helper functions to detect, analyze, and log indentation patterns in markdown text
 */

export interface IndentationAnalysis {
  totalLines: number;
  indentedLines: number;
  maxIndentLevel: number;
  indentPattern: string[];
  nestedListLevels: number[];
  hasNestedStructures: boolean;
  lineByLineAnalysis: LineAnalysis[];
}

export interface LineAnalysis {
  lineNumber: number;
  content: string;
  leadingSpaces: number;
  indentLevel: number;
  isListItem: boolean;
  isNested: boolean;
  bulletType: string | null;
}

export class IndentationAnalyzer {
  /**
   * Analyze indentation patterns in markdown text
   */
  static analyzeIndentation(text: string): IndentationAnalysis {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Starting analysis of ${text.length} characters`);
    
    const lines = text.split(&apos;\n&apos;);
    const lineAnalysis: LineAnalysis[] = [];
    const indentPattern: string[] = [];
    const nestedListLevels: number[] = [];
    let maxIndentLevel = 0;
    let indentedLines = 0;
    
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Processing ${lines.length} lines`);
    
    lines.forEach((line, index) =&gt; {
      const analysis = this.analyzeLine(line, index + 1);
      lineAnalysis.push(analysis);
      
      if (analysis.leadingSpaces &gt; 0) {
        indentedLines++;
        indentPattern.push(`${analysis.leadingSpaces} spaces`);
      }
      
      if (analysis.isNested) {
        nestedListLevels.push(analysis.indentLevel);
      }
      
      if (analysis.indentLevel &gt; maxIndentLevel) {
        maxIndentLevel = analysis.indentLevel;
      }
      
      // Log detailed line analysis
      console.log(`[${timestamp}] [INDENTATION ANALYZER] Line ${index + 1}:`, {
        content: line.substring(0, 50) + (line.length &gt; 50 ? &apos;...&apos; : &apos;&apos;),
        leadingSpaces: analysis.leadingSpaces,
        indentLevel: analysis.indentLevel,
        isListItem: analysis.isListItem,
        isNested: analysis.isNested,
        bulletType: analysis.bulletType,
        rawCharCodes: line.length &gt; 0 ? Array.from(line.substring(0, 10)).map(c =&gt; `${c}(${c.charCodeAt(0)})`).join(&apos; &apos;) : &apos;EMPTY&apos;
      });
    });
    
    const hasNestedStructures = nestedListLevels.length &gt; 0 || maxIndentLevel &gt; 0;
    
    const result: IndentationAnalysis = {
      totalLines: lines.length,
      indentedLines,
      maxIndentLevel,
      indentPattern,
      nestedListLevels,
      hasNestedStructures,
      lineByLineAnalysis: lineAnalysis
    };
    
    // Log summary analysis
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Analysis complete:`, {
      totalLines: result.totalLines,
      indentedLines: result.indentedLines,
      maxIndentLevel: result.maxIndentLevel,
      hasNestedStructures: result.hasNestedStructures,
      nestedListLevelsCount: result.nestedListLevels.length,
      uniqueIndentLevels: [...new Set(result.nestedListLevels)],
      sampleNestedLines: lineAnalysis
        .filter(l =&gt; l.isNested)
        .map(l =&gt; `Line ${l.lineNumber}: &quot;${l.content.substring(0, 30)}...&quot;`)
        .slice(0, 5)
    });
    
    return result;
  }
  
  /**
   * Analyze a single line for indentation patterns
   */
  private static analyzeLine(line: string, lineNumber: number): LineAnalysis {
    const trimmed = line.trim();
    const leadingSpaces = line.length - line.trimStart().length;
    
    // Determine indent level (2 spaces = 1 level, but also account for 4 spaces)
    const indentLevel = Math.floor(leadingSpaces / 2);
    
    // Check if it&apos;s a list item
    const listItemPatterns = [
      /^\* /,      // * bullet
      /^- /,       // - bullet
      /^\+ /,      // + bullet
      /^\d+\. /,   // numbered list
      /^\w+\./     // lettered list
    ];
    
    const isListItem = listItemPatterns.some(pattern =&gt; pattern.test(trimmed));
    let bulletType: string | null = null;
    
    if (isListItem) {
      if (/^\* /.test(trimmed)) bulletType = &apos;asterisk&apos;;
      else if (/^- /.test(trimmed)) bulletType = &apos;dash&apos;;
      else if (/^\+ /.test(trimmed)) bulletType = &apos;plus&apos;;
      else if (/^\d+\. /.test(trimmed)) bulletType = &apos;numbered&apos;;
      else if (/^\w+\./.test(trimmed)) bulletType = &apos;lettered&apos;;
    }
    
    const isNested = leadingSpaces &gt; 0 &amp;&amp; isListItem;
    
    return {
      lineNumber,
      content: line,
      leadingSpaces,
      indentLevel,
      isListItem,
      isNested,
      bulletType
    };
  }
  
  /**
   * Detect if text contains properly nested markdown lists
   */
  static detectNestedLists(text: string): boolean {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Detecting nested lists`);
    
    const lines = text.split(&apos;\n&apos;);
    const listItems: { line: number; indent: number; content: string }[] = [];
    
    // Find all list items
    lines.forEach((line, index) =&gt; {
      const trimmed = line.trim();
      const leadingSpaces = line.length - line.trimStart().length;
      
      if (/^\* |^- |^\+ |^\d+\. |^\w+\./.test(trimmed)) {
        listItems.push({
          line: index + 1,
          indent: leadingSpaces,
          content: trimmed
        });
      }
    });
    
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Found ${listItems.length} list items`);
    
    // Check for nested patterns
    let hasNested = false;
    for (let i = 1; i &lt; listItems.length; i++) {
      const current = listItems[i];
      const previous = listItems[i - 1];
      
      if (current.indent &gt; previous.indent) {
        hasNested = true;
        console.log(`[${timestamp}] [INDENTATION ANALYZER] Nested structure detected:`, {
          parentLine: previous.line,
          parentIndent: previous.indent,
          parentContent: previous.content.substring(0, 30),
          childLine: current.line,
          childIndent: current.indent,
          childContent: current.content.substring(0, 30),
          indentDifference: current.indent - previous.indent
        });
      }
    }
    
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Nested list detection result: ${hasNested}`);
    return hasNested;
  }
  
  /**
   * Visualize indentation structure for debugging
   */
  static visualizeIndentation(text: string): string {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Creating indentation visualization`);
    
    const lines = text.split(&apos;\n&apos;);
    const visualization: string[] = [];
    
    lines.forEach((line, index) =&gt; {
      const trimmed = line.trim();
      const leadingSpaces = line.length - line.trimStart().length;
      const indentLevel = Math.floor(leadingSpaces / 2);
      
      // Create visual representation
      let visual = &apos;&apos;;
      for (let i = 0; i &lt; indentLevel; i++) {
        visual += &apos;‚îÇ  &apos;;
      }
      
      if (trimmed.startsWith(&apos;* &apos;)) {
        visual += &apos;‚îú‚îÄ‚îÄ * &apos; + trimmed.substring(2);
      } else if (trimmed.startsWith(&apos;- &apos;)) {
        visual += &apos;‚îú‚îÄ‚îÄ - &apos; + trimmed.substring(2);
      } else if (trimmed.length &gt; 0) {
        visual += &apos;‚îÇ   &apos; + trimmed;
      } else {
        visual += &apos;    (empty line)&apos;;
      }
      
      visualization.push(`${(index + 1).toString().padStart(3)}: ${visual}`);
    });
    
    const result = visualization.join(&apos;\n&apos;);
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Indentation visualization:\n${result}`);
    
    return result;
  }
  
  /**
   * Log markdown structure analysis
   */
  static logMarkdownStructure(text: string): void {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Starting markdown structure analysis`);
    
    // Basic counts
    const lineCount = text.split(&apos;\n&apos;).length;
    const bulletCount = (text.match(/^\* /gm) || []).length;
    const dashCount = (text.match(/^- /gm) || []).length;
    const numberedCount = (text.match(/^\d+\. /gm) || []).length;
    const newlineCount = (text.match(/\n/g) || []).length;
    
    // Indentation patterns
    const indentedLines = text.split(&apos;\n&apos;).filter(line =&gt; 
      line.length &gt; line.trimStart().length
    ).length;
    
    // Nested patterns
    const nestedPatterns = text.match(/^[ \t]+\* /gm) || [];
    const nestedBulletCount = nestedPatterns.length;
    
    console.log(`[${timestamp}] [INDENTATION ANALYZER] Markdown structure analysis:`, {
      totalLines: lineCount,
      bulletCount,
      dashCount,
      numberedCount,
      newlineCount,
      indentedLines,
      nestedBulletCount,
      hasNestedLists: nestedBulletCount &gt; 0,
      textPreview: text.substring(0, 200) + (text.length &gt; 200 ? &apos;...&apos; : &apos;&apos;),
      containsListMarkers: text.includes(&apos;* &apos;) || text.includes(&apos;- &apos;) || text.match(/^\d+\. /gm),
      startsWithBullet: text.trim().startsWith(&apos;* &apos;) || text.trim().startsWith(&apos;- &apos;) || text.trim().match(/^\d+\. /)
    });
    
    // Analyze specific nested patterns
    if (nestedBulletCount &gt; 0) {
      console.log(`[${timestamp}] [INDENTATION ANALYZER] Nested patterns found:`, {
        count: nestedBulletCount,
        samples: nestedPatterns.slice(0, 5).map(p =&gt; `&quot;${p.trim()}&quot;`),
        uniqueIndentLevels: [...new Set(nestedPatterns.map(p =&gt; p.length - p.trimStart().length))]
      });
    }
  }
}</file><file path="src/utils/index.ts">export * from &apos;./date&apos;;
export * from &apos;./constants&apos;;
export * from &apos;./file&apos;;
export * from &apos;./vector&apos;;</file><file path="src/utils/userIdDebugLogger.ts">/**
 * Debug logger for tracking userId edge cases and potential security issues
 * This helps identify race conditions, data leakage, and unauthorized access
 */

interface UserIdLogEntry {
  timestamp: string;
  type: &apos;AUTH_CHANGE&apos; | &apos;OPERATION_START&apos; | &apos;OPERATION_END&apos; | &apos;SERVICE_CALL&apos; | &apos;STORE_UPDATE&apos; | &apos;ERROR&apos;;
  component: string;
  userId: string | null | undefined;
  operationId?: string;
  details?: any;
  stackTrace?: string;
}

class UserIdDebugLogger {
  private logs: UserIdLogEntry[] = [];
  private maxLogs = 1000; // Keep last 1000 logs
  private isEnabled = process.env.NODE_ENV === &apos;development&apos; || 
                     (typeof window !== &apos;undefined&apos; &amp;&amp; window.localStorage.getItem(&apos;debug-userId&apos;) === &apos;true&apos;);

  log(entry: Omit&lt;UserIdLogEntry, &apos;timestamp&apos;&gt;) {
    if (!this.isEnabled) return;

    const logEntry: UserIdLogEntry = {
      timestamp: new Date().toISOString(),
      ...entry
    };

    this.logs.push(logEntry);
    
    // Keep only the last maxLogs entries
    if (this.logs.length &gt; this.maxLogs) {
      this.logs = this.logs.slice(-this.maxLogs);
    }

    // Log to console with color coding
    const colors = {
      AUTH_CHANGE: &apos;color: #FF6B6B; font-weight: bold&apos;,
      OPERATION_START: &apos;color: #4ECDC4; font-weight: bold&apos;,
      OPERATION_END: &apos;color: #45B7D1; font-weight: bold&apos;,
      SERVICE_CALL: &apos;color: #96CEB4; font-weight: bold&apos;,
      STORE_UPDATE: &apos;color: #FFEAA7; font-weight: bold&apos;,
      ERROR: &apos;color: #E17055; font-weight: bold; background: #FAB1A0; padding: 2px 4px&apos;
    };

    console.log(
      `%c[USERID-DEBUG] ${entry.type} | ${entry.component} | userId: ${entry.userId || &apos;NULL&apos;}`,
      colors[entry.type] || &apos;color: gray&apos;,
      entry
    );

    // Check for potential issues
    this.checkForIssues(logEntry);
  }

  private checkForIssues(entry: UserIdLogEntry) {
    // Check for null/undefined userId in operations that should have it
    if ((entry.type === &apos;OPERATION_START&apos; || entry.type === &apos;SERVICE_CALL&apos;) &amp;&amp; 
        (!entry.userId || entry.userId === &apos;undefined&apos;)) {
      console.error(
        `%c[USERID-SECURITY-ISSUE] Operation started without valid userId`,
        &apos;color: red; font-weight: bold; background: #FFE5E5; padding: 4px&apos;,
        entry
      );
    }

    // Check for race conditions
    if (entry.type === &apos;OPERATION_END&apos; &amp;&amp; entry.operationId) {
      const startEntry = this.logs.find(
        log =&gt; log.operationId === entry.operationId &amp;&amp; log.type === &apos;OPERATION_START&apos;
      );
      if (startEntry &amp;&amp; startEntry.userId !== entry.userId) {
        console.error(
          `%c[USERID-RACE-CONDITION] userId changed during operation!`,
          &apos;color: red; font-weight: bold; background: #FFE5E5; padding: 4px&apos;,
          { start: startEntry, end: entry }
        );
      }
    }

    // Check for auth changes during operations
    if (entry.type === &apos;AUTH_CHANGE&apos;) {
      const activeOperations = this.logs.filter(
        log =&gt; log.type === &apos;OPERATION_START&apos; &amp;&amp; 
               !this.logs.some(endLog =&gt; 
                 endLog.operationId === log.operationId &amp;&amp; endLog.type === &apos;OPERATION_END&apos;
               )
      );
      
      if (activeOperations.length &gt; 0) {
        console.warn(
          `%c[USERID-WARNING] Auth state changed while ${activeOperations.length} operations are active`,
          &apos;color: orange; font-weight: bold; background: #FFF3CD; padding: 4px&apos;,
          { authChange: entry, activeOperations }
        );
      }
    }
  }

  // Helper methods for specific logging scenarios
  logAuthChange(component: string, userId: string | null, event: string) {
    this.log({
      type: &apos;AUTH_CHANGE&apos;,
      component,
      userId,
      details: { event }
    });
  }

  logOperationStart(component: string, operation: string, userId: string | null, operationId?: string) {
    const id = operationId || `${operation}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.log({
      type: &apos;OPERATION_START&apos;,
      component,
      userId,
      operationId: id,
      details: { operation }
    });
    return id;
  }

  logOperationEnd(component: string, operationId: string, userId: string | null) {
    this.log({
      type: &apos;OPERATION_END&apos;,
      component,
      userId,
      operationId,
      details: { operationCompleted: true }
    });
  }

  logServiceCall(component: string, service: string, method: string, userId: string | null) {
    this.log({
      type: &apos;SERVICE_CALL&apos;,
      component: `${component}.${service}`,
      userId,
      details: { method }
    });
  }

  logStoreUpdate(store: string, userId: string | null, action: string) {
    this.log({
      type: &apos;STORE_UPDATE&apos;,
      component: store,
      userId,
      details: { action }
    });
  }

  logError(component: string, error: Error | string, userId: string | null) {
    this.log({
      type: &apos;ERROR&apos;,
      component,
      userId,
      details: { error: error instanceof Error ? error.message : error },
      stackTrace: error instanceof Error ? error.stack : undefined
    });
  }

  // Analysis methods
  getLogs(): UserIdLogEntry[] {
    return [...this.logs];
  }

  getRaceConditions(): Array&lt;{start: UserIdLogEntry, end: UserIdLogEntry}&gt; {
    const raceConditions: Array&lt;{start: UserIdLogEntry, end: UserIdLogEntry}&gt; = [];
    
    this.logs.forEach(endEntry =&gt; {
      if (endEntry.type === &apos;OPERATION_END&apos; &amp;&amp; endEntry.operationId) {
        const startEntry = this.logs.find(
          log =&gt; log.operationId === endEntry.operationId &amp;&amp; log.type === &apos;OPERATION_START&apos;
        );
        if (startEntry &amp;&amp; startEntry.userId !== endEntry.userId) {
          raceConditions.push({ start: startEntry, end: endEntry });
        }
      }
    });

    return raceConditions;
  }

  getUnauthorizedAccessAttempts(): UserIdLogEntry[] {
    return this.logs.filter(log =&gt; 
      (log.type === &apos;OPERATION_START&apos; || log.type === &apos;SERVICE_CALL&apos;) &amp;&amp; 
      (!log.userId || log.userId === &apos;undefined&apos; || log.userId === &apos;null&apos;)
    );
  }

  exportLogs(): string {
    return JSON.stringify({
      timestamp: new Date().toISOString(),
      logs: this.logs,
      analysis: {
        raceConditions: this.getRaceConditions(),
        unauthorizedAttempts: this.getUnauthorizedAccessAttempts(),
        totalLogs: this.logs.length
      }
    }, null, 2);
  }

  clearLogs() {
    this.logs = [];
  }
}

// Create singleton instance
export const userIdLogger = new UserIdDebugLogger();

// Helper function to generate operation IDs
export function generateOperationId(operation: string): string {
  return `${operation}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// Enable debug logging in development or with localStorage flag
if (typeof window !== &apos;undefined&apos;) {
  // Add global debug functions
  (window as any).userIdDebug = {
    getLogs: () =&gt; userIdLogger.getLogs(),
    getRaceConditions: () =&gt; userIdLogger.getRaceConditions(),
    getUnauthorizedAttempts: () =&gt; userIdLogger.getUnauthorizedAccessAttempts(),
    exportLogs: () =&gt; userIdLogger.exportLogs(),
    clearLogs: () =&gt; userIdLogger.clearLogs(),
    enable: () =&gt; window.localStorage.setItem(&apos;debug-userId&apos;, &apos;true&apos;),
    disable: () =&gt; window.localStorage.removeItem(&apos;debug-userId&apos;)
  };
  
  console.log(&apos;UserId Debug Logger initialized. Use window.userIdDebug to access logs.&apos;);
}</file><file path="src/utils/vector.ts">import type { EmbeddingChunk, VectorSearchResult } from &apos;@/types&apos;;

export class VectorUtils {
  /**
   * Calculate dot product of two vectors
   */
  static dotProduct(a: Float32Array, b: Float32Array): number {
    if (a.length !== b.length) {
      throw new Error(&apos;Vectors must be the same length&apos;);
    }
    
    let result = 0;
    for (let i = 0; i &lt; a.length; i++) {
      result += a[i] * b[i];
    }
    return result;
  }

  /**
   * Calculate Euclidean norm (magnitude) of a vector
   */
  static vectorNorm(vector: Float32Array): number {
    let sum = 0;
    for (let i = 0; i &lt; vector.length; i++) {
      sum += vector[i] * vector[i];
    }
    return Math.sqrt(sum);
  }

  /**
   * Calculate cosine similarity between two vectors
   */
  static cosineSimilarity(a: Float32Array, b: Float32Array): number {
    const dotProduct = VectorUtils.dotProduct(a, b);
    const normA = VectorUtils.vectorNorm(a);
    const normB = VectorUtils.vectorNorm(b);
    
    if (normA === 0 || normB === 0) {
      return 0;
    }
    
    return dotProduct / (normA * normB);
  }

  /**
   * Find top K most similar chunks to query vector
   */
  static findTopK(
    queryVector: Float32Array,
    chunks: EmbeddingChunk[],
    k: number,
    minSimilarity: number = 0.1
  ): VectorSearchResult[] {
    const matches: VectorSearchResult[] = [];
    
    for (const chunk of chunks) {
      const similarity = VectorUtils.cosineSimilarity(queryVector, chunk.embedding);
      
      if (similarity &gt;= minSimilarity) {
        matches.push({
          chunk,
          similarity,
          document: {
            id: chunk.documentId,
            title: &apos;&apos;, // Will be populated from document data
            fileName: &apos;&apos;, // Will be populated from document data
          }
        });
      }
    }
    
    // Sort by similarity (descending) and take top K
    return matches
      .sort((a, b) =&gt; b.similarity - a.similarity)
      .slice(0, k);
  }

  /**
   * Deduplicate matches by (document, page) to avoid redundant citations
   * When multiple chunks are from the same page, keeps the highest similarity one
   * and combines their content for better context
   */
  static deduplicateByPage(matches: VectorSearchResult[]): VectorSearchResult[] {
    const grouped = new Map&lt;string, VectorSearchResult[]&gt;();
    
    // Group matches by (document_id, page) key
    for (const match of matches) {
      const pageNum = match.chunk.metadata.pageNumber ?? -1; // -1 for null pages
      const key = `${match.chunk.documentId}_${pageNum}`;
      
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key)!.push(match);
    }
    
    // For each group, select the best match and combine content
    const deduplicated: VectorSearchResult[] = [];
    
    for (const group of grouped.values()) {
      if (group.length === 0) continue;
      
      // Sort by similarity and take the best one as representative
      group.sort((a, b) =&gt; b.similarity - a.similarity);
      const bestMatch = group[0];
      
      // If multiple chunks from same page, combine their content
      if (group.length &gt; 1) {
        const combinedContent = VectorUtils.combineUniqueContent(group);
        
        deduplicated.push({
          chunk: {
            ...bestMatch.chunk,
            content: combinedContent,
          },
          document: bestMatch.document,
          similarity: bestMatch.similarity,
        });
      } else {
        // Single chunk for this page, use as-is
        deduplicated.push(bestMatch);
      }
    }
    
    // Sort by similarity to maintain relevance order
    return deduplicated.sort((a, b) =&gt; b.similarity - a.similarity);
  }

  /**
   * Combine unique content from multiple chunks
   */
  private static combineUniqueContent(matches: VectorSearchResult[]): string {
    const uniqueContents = new Set&lt;string&gt;();
    const combinedParts: string[] = [];
    
    for (const match of matches) {
      const content = match.chunk.content.trim();
      if (!uniqueContents.has(content)) {
        combinedParts.push(content);
        uniqueContents.add(content);
      }
    }
    
    return combinedParts.join(&apos;\n\n&apos;);
  }

  /**
   * Convert regular array to Float32Array for better performance
   */
  static toFloat32Array(array: number[]): Float32Array {
    return new Float32Array(array);
  }

  /**
   * Convert Float32Array back to regular array
   */
  static fromFloat32Array(float32Array: Float32Array): number[] {
    return Array.from(float32Array);
  }

  /**
   * Batch cosine similarity calculation for performance
   * This would be ideal for WebAssembly implementation
   */
  static async batchCosineSimilarity(
    query: Float32Array,
    vectors: Float32Array[]
  ): Promise&lt;number[]&gt; {
    // Simple implementation - in production, this would use WebAssembly
    return vectors.map(vector =&gt; VectorUtils.cosineSimilarity(query, vector));
  }

  /**
   * Validate vector format
   */
  static validateVector(vector: Float32Array): boolean {
    return (
      vector instanceof Float32Array &amp;&amp;
      vector.length &gt; 0 &amp;&amp;
      vector.every(val =&gt; !isNaN(val) &amp;&amp; isFinite(val))
    );
  }

  /**
   * Generate a random vector for testing
   */
  static generateRandomVector(dimensions: number): Float32Array {
    const vector = new Float32Array(dimensions);
    for (let i = 0; i &lt; dimensions; i++) {
      vector[i] = Math.random() * 2 - 1; // Random value between -1 and 1
    }
    return vector;
  }
}</file><file path="README.md"># Meddy - Chat with Documents Privately (Web Version)

A web-based RAG (Retrieval-Augmented Generation) chat application that allows you to privately chat with your documents using Google&apos;s Gemini AI.

## Features

- üöÄ **Private &amp; Local**: All documents processed and stored locally in your browser
- üí¨ **Real-time Chat**: Streaming responses with source citations
- üìÑ **Document Management**: Import pre-processed document packages
- üé® **Dark Theme**: Beautiful dark interface matching Flutter app
- üì± **Mobile-First**: Responsive design that works on all devices
- üîç **Vector Search**: Fast semantic search through your documents
- ‚ö° **Performance**: Optimized for large document collections

## Quick Start

### Prerequisites

- Node.js 18+ 
- Modern web browser with IndexedDB support

### Installation

1. **Clone and install dependencies**:
   ```bash
   cd rag-web
   npm install
   ```

2. **Set up environment**:
   ```bash
   cp .env.local.example .env.local
   # Edit .env.local with your Gemini API key
   ```

3. **Run development server**:
   ```bash
   npm run dev
   ```

4. **Open your browser** and navigate to `http://localhost:3000`

### Getting Gemini API Key

1. Visit [Google AI Studio](https://ai.google.dev)
2. Sign in with your Google account
3. Create a new API key
4. Copy the key and add it to your `.env.local` file

## Usage

### 1. Create a Session
- Click &quot;New Session&quot; on the home page
- Give your session a name and optional description
- Add a custom system prompt if desired

### 2. Import Documents
- Navigate to your session
- Go to the &quot;Documents&quot; tab
- Click &quot;Import Packages&quot; and select pre-processed JSON files
- Wait for processing to complete

### 3. Start Chatting
- Switch to the &quot;Chat&quot; tab
- Ask questions about your documents
- Get real-time responses with source citations

## Document Format

The app accepts pre-processed JSON packages with the following structure:

```json
{
  &quot;format_version&quot;: &quot;1.0&quot;,
  &quot;export_metadata&quot;: { ... },
  &quot;document_metadata&quot;: { ... },
  &quot;chunks&quot;: [
    {
      &quot;id&quot;: &quot;chunk_id&quot;,
      &quot;text&quot;: &quot;chunk content&quot;,
      &quot;embedding&quot;: [0.1, 0.2, ...],
      &quot;metadata&quot;: { ... }
    }
  ],
  &quot;export_stats&quot;: { ... }
}
```

## Architecture

### Technology Stack
- **Frontend**: Next.js 14 + React 18 + TypeScript
- **Styling**: Tailwind CSS with custom dark theme
- **State**: Zustand with persistence
- **Storage**: IndexedDB with Dexie wrapper
- **AI**: Google Gemini API for embeddings and chat
- **Search**: Custom vector similarity search

### Key Features
- **Vector Search**: Fast semantic search through document embeddings
- **Streaming Chat**: Real-time response generation
- **Citations**: Automatic source attribution with page numbers
- **Offline-First**: Works without internet after initial setup
- **PWA Ready**: Installable as a desktop/mobile app

## Development

### Project Structure

```
src/
‚îú‚îÄ‚îÄ app/              # Next.js pages
‚îú‚îÄ‚îÄ components/        # React components
‚îú‚îÄ‚îÄ hooks/            # Custom React hooks
‚îú‚îÄ‚îÄ services/         # Business logic
‚îú‚îÄ‚îÄ store/            # Zustand state management
‚îú‚îÄ‚îÄ types/            # TypeScript definitions
‚îú‚îÄ‚îÄ utils/            # Utility functions
‚îî‚îÄ‚îÄ styles/           # CSS and styling
```

### Available Scripts

```bash
npm run dev          # Start development server
npm run build        # Build for production
npm run start        # Start production server
npm run lint         # Run ESLint
npm run type-check   # Type checking only
npm run format       # Format code with Prettier
```

## Browser Support

- Chrome 88+
- Firefox 90+
- Safari 14+
- Edge 88+

## Privacy &amp; Security

- ‚úÖ All data stored locally in IndexedDB
- ‚úÖ No data sent to external servers (except Gemini API)
- ‚úÖ API key encrypted in local storage
- ‚úÖ No analytics or tracking
- ‚úÖ Open source and auditable

## Performance

- üöÄ Optimized vector operations with Float32Array
- üìä Efficient pagination for large document sets
- ‚ö° WebAssembly support for heavy computations
- üóÑÔ∏è Smart caching and indexing strategies

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests if applicable
5. Submit a pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Support

For issues, questions, or feature requests, please open an issue on the GitHub repository.</file><file path="tailwind.config.js">/** @type {import(&apos;tailwindcss&apos;).Config} */
module.exports = {
  content: [
    &apos;./src/pages/**/*.{js,ts,jsx,tsx,mdx}&apos;,
    &apos;./src/components/**/*.{js,ts,jsx,tsx,mdx}&apos;,
    &apos;./src/app/**/*.{js,ts,jsx,tsx,mdx}&apos;,
  ],
  darkMode: &apos;class&apos;,
  theme: {
    extend: {
      colors: {
        // Matching Flutter app&apos;s dark theme colors
        slate: {
          950: &apos;#020617&apos;,
          900: &apos;#0F172A&apos;,
          800: &apos;#1E293B&apos;,
          700: &apos;#334155&apos;,
          600: &apos;#475569&apos;,
          500: &apos;#64748B&apos;,
          400: &apos;#94A3B8&apos;,
          300: &apos;#CBD5E1&apos;,
          200: &apos;#E2E8F0&apos;,
          100: &apos;#F1F5F9&apos;,
        },
        blue: {
          500: &apos;#3B82F6&apos;,
          600: &apos;#2563EB&apos;,
          400: &apos;#60A5FA&apos;,
        },
        red: {
          500: &apos;#EF4444&apos;,
        },
        green: {
          500: &apos;#10B981&apos;,
        },
        yellow: {
          500: &apos;#F59E0B&apos;,
        },
      },
      fontFamily: {
        sans: [&apos;Inter&apos;, &apos;system-ui&apos;, &apos;sans-serif&apos;],
      },
      animation: {
        &apos;fade-in&apos;: &apos;fadeIn 0.5s ease-in-out&apos;,
        &apos;slide-up&apos;: &apos;slideUp 0.3s ease-out&apos;,
        &apos;pulse-slow&apos;: &apos;pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite&apos;,
      },
      keyframes: {
        fadeIn: {
          &apos;0%&apos;: { opacity: &apos;0&apos; },
          &apos;100%&apos;: { opacity: &apos;1&apos; },
        },
        slideUp: {
          &apos;0%&apos;: { transform: &apos;translateY(10px)&apos;, opacity: &apos;0&apos; },
          &apos;100%&apos;: { transform: &apos;translateY(0)&apos;, opacity: &apos;1&apos; },
        },
      },
      spacing: {
        &apos;18&apos;: &apos;4.5rem&apos;,
        &apos;88&apos;: &apos;22rem&apos;,
      },
      maxWidth: {
        &apos;8xl&apos;: &apos;88rem&apos;,
      },
      typography: {
        DEFAULT: {
          css: {
            maxWidth: &apos;none&apos;,
          },
        },
      },
    },
  },
  plugins: [
    require(&apos;@tailwindcss/forms&apos;),
    require(&apos;@tailwindcss/typography&apos;),
    require(&apos;@tailwindcss/aspect-ratio&apos;),
  ],
}</file><file path="tsconfig.json">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;es6&quot;],
    &quot;allowJs&quot;: true,
    &quot;skipLibCheck&quot;: true,
    &quot;strict&quot;: true,
    &quot;noEmit&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;module&quot;: &quot;esnext&quot;,
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;resolveJsonModule&quot;: true,
    &quot;isolatedModules&quot;: true,
    &quot;jsx&quot;: &quot;preserve&quot;,
    &quot;incremental&quot;: true,
    &quot;downlevelIteration&quot;: true,
    &quot;plugins&quot;: [
      {
        &quot;name&quot;: &quot;next&quot;
      }
    ],
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [&quot;./src/*&quot;],
      &quot;@/components/*&quot;: [&quot;./src/components/*&quot;],
      &quot;@/hooks/*&quot;: [&quot;./src/hooks/*&quot;],
      &quot;@/store/*&quot;: [&quot;./src/store/*&quot;],
      &quot;@/services/*&quot;: [&quot;./src/services/*&quot;],
      &quot;@/types/*&quot;: [&quot;./src/types/*&quot;],
      &quot;@/utils/*&quot;: [&quot;./src/utils/*&quot;],
      &quot;@/styles/*&quot;: [&quot;./src/styles/*&quot;]
    }
  },
  &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;, &quot;.next/types/**/*.ts&quot;],
  &quot;exclude&quot;: [&quot;node_modules&quot;]
}</file><file path="src/components/chat/ChatList.tsx">import React, { useEffect, useRef } from &apos;react&apos;;
import { MessageBubble } from &apos;./MessageBubble&apos;;
import { Loading } from &apos;../ui/Loading&apos;;
import { ResponseProgressBar } from &apos;../ui/ResponseProgressBar&apos;;
import { EmptyStates } from &apos;../common/EmptyState&apos;;
import { useChatStore } from &apos;../../store&apos;;
import { Message, MessageSender } from &apos;../../types&apos;;
import { isToday, isYesterday, ensureDate } from &apos;../../utils/date&apos;;

interface ChatListProps {
  sessionId: string;
  className?: string;
}

export const ChatList: React.FC&lt;ChatListProps&gt; = ({
  sessionId,
  className,
}) =&gt; {
  const { messages, loadMessages, isStreaming, streamingContent, streamingCitations, isReadingSources, progressPercentage, currentProgressStep } = useChatStore();
  const isLoading = false; // TODO: Add loading state to chat store
  const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null);
  const containerRef = useRef&lt;HTMLDivElement&gt;(null);

  // Load messages when session changes
  useEffect(() =&gt; {
    if (sessionId) {
      loadMessages(sessionId);
    }
  }, [sessionId, loadMessages]);

  // Auto-scroll to bottom when new messages arrive or streaming updates
  useEffect(() =&gt; {
    const scrollToBottom = () =&gt; {
      messagesEndRef.current?.scrollIntoView({ behavior: &apos;smooth&apos; });
    };

    // Small delay to ensure content is rendered
    const timeoutId = setTimeout(scrollToBottom, 100);
    return () =&gt; clearTimeout(timeoutId);
  }, [messages, streamingContent]);

  // Handle scroll events for loading more messages (pagination)
  const handleScroll = () =&gt; {
    const container = containerRef.current;
    if (container &amp;&amp; container.scrollTop === 0) {
      // At the top, could load more messages here
      // Future: Implement pagination for older messages
      console.log(&apos;Reached top - could load more messages&apos;);
    }
  };

  if (isLoading &amp;&amp; messages.length === 0) {
    return (
      &lt;div className={`flex items-center justify-center h-full ${className}`}&gt;
        &lt;Loading size=&quot;lg&quot; text=&quot;Loading messages...&quot; /&gt;
      &lt;/div&gt;
    );
  }

  if (messages.length === 0) {
    return (
      &lt;div className={`flex items-center justify-center h-full ${className}`}&gt;
        &lt;EmptyStates.NoMessages /&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div
      ref={containerRef}
      onScroll={handleScroll}
      className={`
        flex-1 overflow-y-auto px-3 sm:px-4 py-4 sm:py-6
        bg-gray-50 dark:bg-gray-900
        scrollbar-thin scrollbar-thumb-gray-300 dark:scrollbar-thumb-gray-600
        scrollbar-track-transparent
        touch-pan-y
        ${className}
      `}
    &gt;
      &lt;div className=&quot;max-w-4xl mx-auto space-y-1&quot;&gt;
        {/* Group messages by date */}
        {messages.map((message, index) =&gt; {
          const prevMessage = messages[index - 1];
          const showDateDivider = shouldShowDateDivider(message, prevMessage);
          
          return (
            &lt;React.Fragment key={message.id}&gt;
              {showDateDivider &amp;&amp; (
                &lt;DateDivider date={message.timestamp || new Date()} /&gt;
              )}
              &lt;MessageBubble message={message} /&gt;
            &lt;/React.Fragment&gt;
          );
        })}

        {/* Reading sources loading indicator */}
        {isReadingSources &amp;&amp; (
          &lt;div className=&quot;flex justify-start mb-3 sm:mb-4&quot;&gt;
            &lt;ResponseProgressBar
              progress={progressPercentage}
              currentStep={currentProgressStep}
            /&gt;
          &lt;/div&gt;
        )}
        
        {/* Streaming message - only show if not reading sources */}
        {isStreaming &amp;&amp; streamingContent &amp;&amp; !isReadingSources &amp;&amp; (
          &lt;MessageBubble
            message={{
              id: &apos;streaming&apos;,
              sessionId,
              content: streamingContent,
              role: MessageSender.ASSISTANT,
              timestamp: new Date(),
              citations: streamingCitations,
            }}
            isStreaming={true}
          /&gt;
        )}
        
        {/* Invisible element for scroll targeting */}
        &lt;div ref={messagesEndRef} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

// Helper component for date dividers
interface DateDividerProps {
  date: Date | string | undefined | null;
}

const DateDivider: React.FC&lt;DateDividerProps&gt; = ({ date }) =&gt; {
  const dateObj = ensureDate(date);

  return (
    &lt;div className=&quot;flex items-center justify-center my-3 sm:my-4&quot;&gt;
      &lt;div className=&quot;bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 text-xs px-2 sm:px-3 py-1 rounded-full&quot;&gt;
        {isToday(dateObj) ? &apos;Today&apos; : isYesterday(dateObj) ? &apos;Yesterday&apos; : dateObj.toLocaleDateString(&apos;en-US&apos;, {
          month: &apos;short&apos;,
          day: &apos;numeric&apos;,
          year: dateObj.getFullYear() !== new Date().getFullYear() ? &apos;numeric&apos; : undefined,
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

// Helper function to determine if we should show a date divider
const shouldShowDateDivider = (message: Message, prevMessage?: Message): boolean =&gt; {
  if (!prevMessage) return true;
  
  // Handle both Date and string timestamps using ensureDate
  const currentDate = ensureDate(message.timestamp);
  const prevDate = ensureDate(prevMessage.timestamp);
  
  // Show divider if messages are from different days
  return currentDate.toDateString() !== prevDate.toDateString();
};

// Streaming chat list component (for real-time updates)
export const StreamingChatList: React.FC&lt;{
  messages: Message[];
  streamingContent?: string;
  streamingCitations?: any[];
  className?: string;
}&gt; = ({ messages, streamingContent, streamingCitations, className }) =&gt; {
  const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null);

  // Auto-scroll to bottom when new messages arrive or streaming updates
  useEffect(() =&gt; {
    const scrollToBottom = () =&gt; {
      messagesEndRef.current?.scrollIntoView({ behavior: &apos;smooth&apos; });
    };

    const timeoutId = setTimeout(scrollToBottom, 100);
    return () =&gt; clearTimeout(timeoutId);
  }, [messages, streamingContent]);

  return (
    &lt;div
      className={`
        flex-1 overflow-y-auto px-3 sm:px-4 py-4 sm:py-6
        bg-gray-50 dark:bg-gray-900
        scrollbar-thin scrollbar-thumb-gray-300 dark:scrollbar-thumb-gray-600
        scrollbar-track-transparent
        touch-pan-y
        ${className}
      `}
    &gt;
      &lt;div className=&quot;max-w-4xl mx-auto space-y-1&quot;&gt;
        {/* Render existing messages */}
        {messages.map((message, index) =&gt; {
          const prevMessage = messages[index - 1];
          const showDateDivider = shouldShowDateDivider(message, prevMessage);
          
          return (
            &lt;React.Fragment key={message.id}&gt;
              {showDateDivider &amp;&amp; (
                &lt;DateDivider date={message.timestamp || new Date()} /&gt;
              )}
              &lt;MessageBubble message={message} /&gt;
            &lt;/React.Fragment&gt;
          );
        })}

        {/* Streaming message */}
        {streamingContent &amp;&amp; (
          &lt;MessageBubble
            message={{
              id: &apos;streaming&apos;,
              sessionId: &apos;&apos;,
              content: streamingContent,
              role: MessageSender.ASSISTANT,
              timestamp: new Date(),
              citations: streamingCitations,
            }}
            isStreaming={true}
          /&gt;
        )}
        
        {/* Invisible element for scroll targeting */}
        &lt;div ref={messagesEndRef} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="src/components/chat/MessageBubble.tsx">import React from &apos;react&apos;;
import ReactMarkdown from &apos;react-markdown&apos;;
import remarkGfm from &apos;remark-gfm&apos;;
import rehypeHighlight from &apos;rehype-highlight&apos;;
import { Message, Citation } from &apos;../../types&apos;;
import { CitationPanel } from &apos;./CitationPanel&apos;;
import { MessageSender } from &apos;../../types&apos;;
import { formatTime } from &apos;../../utils/date&apos;;
import { IndentationAnalyzer } from &apos;../../utils/indentationAnalyzer&apos;;
import clsx from &apos;clsx&apos;;

interface MessageBubbleProps {
  message: Message;
  isStreaming?: boolean;
  className?: string;
}

export const MessageBubble: React.FC&lt;MessageBubbleProps&gt; = ({
  message,
  isStreaming = false,
  className,
}) =&gt; {
  const isUser = message.role === &apos;user&apos;;
  
  // Process message content to add Vancouver style citation references
  const processMessageContent = (content: string, citations?: Citation[]) =&gt; {
    const timestamp = new Date().toISOString();
    
    if (!citations || citations.length === 0 || isUser) {
      console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE:`, &apos;Skipping content processing - no citations or user message&apos;);
      return content;
    }
    
    // Create a map of citation indices by page for reference
    const citationMap = new Map&lt;number, Citation&gt;();
    citations.forEach((citation, index) =&gt; {
      citationMap.set(index + 1, citation);
    });
    
    // Replace citation placeholders with Vancouver style references
    // This assumes the message content contains placeholders like [citation:X]
    let processedContent = content;
    
    // Replace [citation:X] patterns with [X] where X is the citation number
    processedContent = processedContent.replace(/\[citation:(\d+)\]/g, (match, num) =&gt; {
      const citationNum = parseInt(num);
      return citationMap.has(citationNum) ? `[${citationNum}]` : match;
    });
    
    // Also handle any remaining [citation] patterns by numbering them sequentially
    let citationCounter = 1;
    processedContent = processedContent.replace(/\[citation\]/g, () =&gt; {
      return `[${citationCounter++}]`;
    });
    
    return processedContent;
  };

  const processedContent = processMessageContent(message.content, message.citations);
  
  // Comprehensive logging of markdown content processing
  const timestamp = new Date().toISOString();
  console.log(`\n=== [${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE START ===`);
  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE:`, {
    isUser,
    messageId: message.id,
    originalContentLength: message.content.length,
    processedContentLength: processedContent.length,
    hasCitations: message.citations &amp;&amp; message.citations.length &gt; 0,
    citationCount: message.citations?.length || 0
  });
  
  // Analyze original content structure
  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: ANALYZING ORIGINAL CONTENT:`);
  IndentationAnalyzer.logMarkdownStructure(message.content);
  const originalAnalysis = IndentationAnalyzer.analyzeIndentation(message.content);
  
  // Analyze processed content structure
  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: ANALYZING PROCESSED CONTENT:`);
  IndentationAnalyzer.logMarkdownStructure(processedContent);
  const processedAnalysis = IndentationAnalyzer.analyzeIndentation(processedContent);
  
  // Check for nested structures
  const originalHasNested = IndentationAnalyzer.detectNestedLists(message.content);
  const processedHasNested = IndentationAnalyzer.detectNestedLists(processedContent);
  
  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: NESTED STRUCTURE ANALYSIS:`, {
    originalHasNested,
    processedHasNested,
    nestedStructuresPreserved: originalHasNested === processedHasNested,
    originalIndentedLines: originalAnalysis.indentedLines,
    processedIndentedLines: processedAnalysis.indentedLines,
    originalMaxIndent: originalAnalysis.maxIndentLevel,
    processedMaxIndent: processedAnalysis.maxIndentLevel
  });
  
  // Create visualization of content structure
  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: ORIGINAL CONTENT VISUALIZATION:`);
  IndentationAnalyzer.visualizeIndentation(message.content);
  
  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: PROCESSED CONTENT VISUALIZATION:`);
  IndentationAnalyzer.visualizeIndentation(processedContent);
  
  // Additional detailed analysis
  const hasNewlines = processedContent.includes(&apos;\n&apos;);
  const newlineCount = (processedContent.match(/\n/g) || []).length;
  const bulletCount = (processedContent.match(/^\* /gm) || []).length;
  const nestedBulletCount = (processedContent.match(/^[ \t]+\* /gm) || []).length;
  const firstFewLines = processedContent.split(&apos;\n&apos;).slice(0, 5);
  
  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: DETAILED ANALYSIS:`, {
    hasNewlines,
    newlineCount,
    bulletCount,
    nestedBulletCount,
    hasNestedBullets: nestedBulletCount &gt; 0,
    firstFewLines,
    rawCharCodes: Array.from(processedContent.substring(0, 100)).map(c =&gt; `${c}(${c.charCodeAt(0)})`).join(&apos; &apos;),
    containsListMarkers: processedContent.includes(&apos;* &apos;) || processedContent.includes(&apos;- &apos;) || processedContent.match(/^\d+\. /gm),
    startsWithBullet: processedContent.trim().startsWith(&apos;* &apos;) || processedContent.trim().startsWith(&apos;- &apos;) || processedContent.trim().match(/^\d+\. /)
  });

  return (
    &lt;div className={clsx(
      &apos;flex gap-2 sm:gap-3 mb-3 sm:mb-4&apos;,
      isUser ? &apos;justify-end&apos; : &apos;justify-start&apos;,
      className
    )}&gt;
      {/* Avatar */}
      {!isUser &amp;&amp; (
        &lt;div className=&quot;flex-shrink-0&quot;&gt;
          &lt;div className=&quot;w-7 h-7 sm:w-8 sm:h-8 bg-blue-500 rounded-full flex items-center justify-center&quot;&gt;
            &lt;svg
              className=&quot;w-4 h-4 sm:w-5 sm:h-5 text-white&quot;
              fill=&quot;none&quot;
              viewBox=&quot;0 0 24 24&quot;
              stroke=&quot;currentColor&quot;
            &gt;
              &lt;path
                strokeLinecap=&quot;round&quot;
                strokeLinejoin=&quot;round&quot;
                strokeWidth={2}
                d=&quot;M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z&quot;
              /&gt;
            &lt;/svg&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {/* Message Content */}
      &lt;div className={clsx(
        &apos;max-w-[85%] sm:max-w-xs lg:max-w-md xl:max-w-lg&apos;,
        isUser &amp;&amp; &apos;max-w-[85%] sm:max-w-xs lg:max-w-md&apos;
      )}&gt;
        &lt;div className={clsx(
          &apos;rounded-lg px-3 py-2 sm:px-4 sm:py-3&apos;,
          isUser
            ? &apos;bg-blue-500 text-white ml-auto&apos;
            : &apos;bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100 border border-gray-200 dark:border-gray-700&apos;
        )}&gt;
          {/* Message Text */}
          &lt;div className=&quot;prose prose-sm max-w-none dark:prose-invert&quot;&gt;
            &lt;ReactMarkdown
              remarkPlugins={[remarkGfm]}
              rehypePlugins={[rehypeHighlight]}
              components={{
                // Custom components for markdown rendering
                code: ({ node, className, children, ...props }: any) =&gt; {
                  const match = /language-(\w+)/.exec(className || &apos;&apos;);
                  return !props.inline &amp;&amp; match ? (
                    &lt;pre className={className}&gt;
                      &lt;code className={className} {...props}&gt;
                        {children}
                      &lt;/code&gt;
                    &lt;/pre&gt;
                  ) : (
                    &lt;code className={className} {...props}&gt;
                      {children}
                    &lt;/code&gt;
                  );
                },
                a: ({ href, children }) =&gt; (
                  &lt;a
                    href={href}
                    target=&quot;_blank&quot;
                    rel=&quot;noopener noreferrer&quot;
                    className=&quot;text-blue-500 hover:text-blue-600 underline&quot;
                  &gt;
                    {children}
                  &lt;/a&gt;
                ),
                // NEW: Custom handling for Unordered Lists to ensure indentation
                ul: ({ node, className, children, ...props }) =&gt; {
                  const timestamp = new Date().toISOString();
                  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: RENDERING UL COMPONENT:`, {
                    hasChildren: !!children,
                    childCount: React.Children.count(children),
                    className,
                    appliedClassName: &quot;pl-6 my-2 space-y-1 list-outside&quot; // REMOVED &quot;list-disc&quot; to allow CSS to handle nested bullet styles
                  });
                  return (
                    &lt;ul
                      className={clsx(&quot;pl-6 my-2 space-y-1 list-outside&quot;, className)} // REMOVED &quot;list-disc&quot; and INCREASED &quot;pl-5&quot; to &quot;pl-6&quot;
                      {...props}
                    &gt;
                      {children}
                    &lt;/ul&gt;
                  );
                },
                // NEW: Custom handling for List Items
                li: ({ node, className, children, ...props }) =&gt; {
                  const timestamp = new Date().toISOString();
                  const childText = React.Children.toArray(children).join(&apos;&apos;).substring(0, 50);
                  console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: RENDERING LI COMPONENT:`, {
                    childText: childText + (childText.length &gt;= 50 ? &apos;...&apos; : &apos;&apos;),
                    hasChildren: !!children,
                    childCount: React.Children.count(children),
                    className,
                    appliedClassName: &quot;pl-1 marker:text-gray-500 dark:marker:text-gray-400&quot;,
                    nodeProperties: node ? Object.keys(node) : &apos;no node&apos;
                  });
                  return (
                    &lt;li
                      className={clsx(&quot;pl-1 marker:text-gray-500 dark:marker:text-gray-400&quot;, className)}
                      {...props}
                    &gt;
                      {children}
                    &lt;/li&gt;
                  );
                },
                // Custom component to handle citation references
                span: ({ node, className, children, ...props }: any) =&gt; {
                  // Check if this is a citation reference
                  const text = typeof children === &apos;string&apos; ? children : &apos;&apos;;
                  const citationMatch = text.match(/^\[(\d+)\]$/);
                  
                  if (citationMatch &amp;&amp; !isUser) {
                    const citationNum = parseInt(citationMatch[1]);
                    return (
                      &lt;span
                        className={`citation-ref ${className || &apos;&apos;}`}
                        title={`Citation ${citationNum}`}
                        {...props}
                      &gt;
                        {citationNum}
                      &lt;/span&gt;
                    );
                  }
                  
                  return (
                    &lt;span className={className} {...props}&gt;
                      {children}
                    &lt;/span&gt;
                  );
                },
              }}
            &gt;
              {processedContent}
            &lt;/ReactMarkdown&gt;
            
            {/* Log after ReactMarkdown rendering */}
            {(() =&gt; {
              const timestamp = new Date().toISOString();
              console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: REACTMARKDOWN RENDERING COMPLETE`);
              console.log(`[${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE: CUSTOM COMPONENTS APPLIED:`, {
                ulComponentApplied: true,
                liComponentApplied: true,
                citationComponentApplied: true,
                codeComponentApplied: true,
                linkComponentApplied: true
              });
              console.log(`=== [${timestamp}] [INDENTATION DEBUG] MESSAGEBUBBLE END ===\n`);
              return null;
            })()}
            
            {isStreaming &amp;&amp; (
              &lt;span className=&quot;inline-block w-2 h-4 bg-gray-400 dark:bg-gray-600 animate-pulse ml-1&quot; /&gt;
            )}
          &lt;/div&gt;

          {/* Citations */}
          {message.citations &amp;&amp; message.citations.length &gt; 0 &amp;&amp; !isUser &amp;&amp; (
            &lt;div className=&quot;mt-3 pt-3 border-t border-gray-200 dark:border-gray-700&quot;&gt;
              &lt;CitationPanel citations={message.citations} /&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;

        {/* Timestamp */}
        &lt;div className={clsx(
          &apos;text-xs text-gray-500 dark:text-gray-400 mt-1&apos;,
          isUser ? &apos;text-right&apos; : &apos;text-left&apos;
        )}&gt;
          {formatTime(message.timestamp || new Date())}
        &lt;/div&gt;
      &lt;/div&gt;

      {/* User Avatar */}
      {isUser &amp;&amp; (
        &lt;div className=&quot;flex-shrink-0&quot;&gt;
          &lt;div className=&quot;w-7 h-7 sm:w-8 sm:h-8 bg-gray-500 rounded-full flex items-center justify-center&quot;&gt;
            &lt;svg
              className=&quot;w-4 h-4 sm:w-5 sm:h-5 text-white&quot;
              fill=&quot;none&quot;
              viewBox=&quot;0 0 24 24&quot;
              stroke=&quot;currentColor&quot;
            &gt;
              &lt;path
                strokeLinecap=&quot;round&quot;
                strokeLinejoin=&quot;round&quot;
                strokeWidth={2}
                d=&quot;M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z&quot;
              /&gt;
            &lt;/svg&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

// Streaming message bubble component
export const StreamingMessageBubble: React.FC&lt;{
  content: string;
  citations?: any[];
  className?: string;
}&gt; = ({ content, citations, className }) =&gt; {
  const streamingMessage: Message = {
    id: &apos;streaming&apos;,
    sessionId: &apos;&apos;,
    content,
    role: MessageSender.ASSISTANT,
    timestamp: new Date(),
    citations,
  };

  return (
    &lt;MessageBubble
      message={streamingMessage}
      isStreaming={true}
      className={className}
    /&gt;
  );
};</file><file path="src/components/chat/PhrasePills.tsx">import React, { useRef, useEffect, useState } from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

// Default phrases for the pills
const DEFAULT_PHRASES = [
  &quot;Give details about&quot;,
  &quot;Definition&quot;,
  &quot;Types / Classification&quot;,
  &quot;Causes&quot;,
  &quot;Risk factors&quot;,
  &quot;Pathogenesis&quot;,
  &quot;Features&quot;,
  &quot;Investigations&quot;,
  &quot;Treatment&quot;,
  &quot;Difference between&quot;
];

// TypeScript interfaces
export interface PhrasePillProps {
  phrase: string;
  isSelected?: boolean;
  onClick: () =&gt; void;
  onKeyDown?: (event: React.KeyboardEvent) =&gt; void;
  className?: string;
}

export interface PhrasePillsProps {
  phrases?: string[];
  onPhraseSelect: (phrase: string) =&gt; void;
  selectedPhrase?: string;
  className?: string;
  ariaLabel?: string;
}

// Individual Pill Component
const PhrasePill: React.FC&lt;PhrasePillProps&gt; = ({
  phrase,
  isSelected = false,
  onClick,
  onKeyDown,
  className,
}) =&gt; {
  const handleKeyDown = (event: React.KeyboardEvent) =&gt; {
    if (event.key === &apos;Enter&apos; || event.key === &apos; &apos;) {
      event.preventDefault();
      onClick();
    }
    onKeyDown?.(event);
  };

  return (
    &lt;button
      type=&quot;button&quot;
      role=&quot;button&quot;
      tabIndex={0}
      onClick={onClick}
      onMouseDown={(e) =&gt; e.preventDefault()}
      onKeyDown={handleKeyDown}
      aria-pressed={isSelected}
      aria-label={`Select phrase: ${phrase}`}
      className={clsx(
        // Base styles
        &apos;inline-flex items-center justify-center px-3 py-1.5 sm:px-4 sm:py-2&apos;,
        &apos;text-xs sm:text-sm font-medium rounded-full&apos;,
        &apos;transition-all duration-200 ease-in-out&apos;,
        &apos;touch-manipulation&apos;,
        &apos;min-h-[32px] sm:min-h-[36px]&apos;,

        // Grey background with white border and text
        &apos;bg-gray-600 text-white border border-white&apos;,

        // Hover and active states
        &apos;hover:bg-gray-500 hover:scale-105 active:scale-95&apos;,

        // Focus styles for accessibility
        &apos;focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-600&apos;,

        // Selected state
        isSelected &amp;&amp; &apos;bg-blue-500 border-blue-300 hover:bg-blue-600&apos;,

        // Mobile touch feedback
        &apos;-webkit-tap-highlight-color: rgba(255, 255, 255, 0.2)&apos;,

        className
      )}
    &gt;
      &lt;span className=&quot;truncate max-w-[120px] sm:max-w-[150px]&quot;&gt;{phrase}&lt;/span&gt;
    &lt;/button&gt;
  );
};

// Main PhrasePills Component
export const PhrasePills: React.FC&lt;PhrasePillsProps&gt; = ({
  phrases = DEFAULT_PHRASES,
  onPhraseSelect,
  selectedPhrase,
  className,
  ariaLabel = &quot;Quick phrase suggestions&quot;
}) =&gt; {
  const scrollContainerRef = useRef&lt;HTMLDivElement&gt;(null);
  const [canScrollLeft, setCanScrollLeft] = useState(false);
  const [canScrollRight, setCanScrollRight] = useState(true);

  // Check scroll position to update scroll buttons
  const checkScrollPosition = () =&gt; {
    const container = scrollContainerRef.current;
    if (container) {
      setCanScrollLeft(container.scrollLeft &gt; 0);
      setCanScrollRight(
        container.scrollLeft &lt; container.scrollWidth - container.clientWidth
      );
    }
  };

  // Handle scroll events
  const handleScroll = () =&gt; {
    checkScrollPosition();
  };

  // Scroll functions for desktop navigation
  const scrollLeft = () =&gt; {
    const container = scrollContainerRef.current;
    if (container) {
      container.scrollBy({ left: -200, behavior: &apos;smooth&apos; });
    }
  };

  const scrollRight = () =&gt; {
    const container = scrollContainerRef.current;
    if (container) {
      container.scrollBy({ left: 200, behavior: &apos;smooth&apos; });
    }
  };

  // Handle keyboard navigation
  const handleKeyDown = (event: React.KeyboardEvent) =&gt; {
    const container = scrollContainerRef.current;
    if (!container) return;

    switch (event.key) {
      case &apos;ArrowLeft&apos;:
        event.preventDefault();
        scrollLeft();
        break;
      case &apos;ArrowRight&apos;:
        event.preventDefault();
        scrollRight();
        break;
      case &apos;Home&apos;:
        event.preventDefault();
        container.scrollTo({ left: 0, behavior: &apos;smooth&apos; });
        break;
      case &apos;End&apos;:
        event.preventDefault();
        container.scrollTo({ left: container.scrollWidth, behavior: &apos;smooth&apos; });
        break;
    }
  };

  // Initialize scroll position check
  useEffect(() =&gt; {
    checkScrollPosition();

    // Add resize listener
    const handleResize = () =&gt; {
      checkScrollPosition();
    };

    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  }, [phrases]);

  return (
    &lt;div
      className={clsx(
        &apos;relative w-full&apos;,
        className
      )}
      role=&quot;region&quot;
      aria-label={ariaLabel}
    &gt;
      {/* Desktop scroll buttons */}
      &lt;div className=&quot;hidden sm:flex absolute left-0 top-0 bottom-0 z-10 items-center pointer-events-none&quot;&gt;
        {canScrollLeft &amp;&amp; (
          &lt;button
            type=&quot;button&quot;
            onClick={scrollLeft}
            aria-label=&quot;Scroll left&quot;
            className=&quot;pointer-events-auto bg-gray-800/80 text-white rounded-full p-1.5 shadow-lg border border-gray-600 hover:bg-gray-700 transition-all duration-200 ml-2&quot;
          &gt;
            &lt;svg
              className=&quot;w-4 h-4&quot;
              fill=&quot;none&quot;
              viewBox=&quot;0 0 24 24&quot;
              stroke=&quot;currentColor&quot;
            &gt;
              &lt;path
                strokeLinecap=&quot;round&quot;
                strokeLinejoin=&quot;round&quot;
                strokeWidth={2}
                d=&quot;M15 19l-7-7 7-7&quot;
              /&gt;
            &lt;/svg&gt;
          &lt;/button&gt;
        )}
      &lt;/div&gt;

      &lt;div className=&quot;hidden sm:flex absolute right-0 top-0 bottom-0 z-10 items-center pointer-events-none&quot;&gt;
        {canScrollRight &amp;&amp; (
          &lt;button
            type=&quot;button&quot;
            onClick={scrollRight}
            aria-label=&quot;Scroll right&quot;
            className=&quot;pointer-events-auto bg-gray-800/80 text-white rounded-full p-1.5 shadow-lg border border-gray-600 hover:bg-gray-700 transition-all duration-200 mr-2&quot;
          &gt;
            &lt;svg
              className=&quot;w-4 h-4&quot;
              fill=&quot;none&quot;
              viewBox=&quot;0 0 24 24&quot;
              stroke=&quot;currentColor&quot;
            &gt;
              &lt;path
                strokeLinecap=&quot;round&quot;
                strokeLinejoin=&quot;round&quot;
                strokeWidth={2}
                d=&quot;M9 5l7 7-7 7&quot;
              /&gt;
            &lt;/svg&gt;
          &lt;/button&gt;
        )}
      &lt;/div&gt;

      {/* Scrollable container */}
      &lt;div
        ref={scrollContainerRef}
        onScroll={handleScroll}
        onKeyDown={handleKeyDown}
        tabIndex={0}
        role=&quot;list&quot;
        aria-orientation=&quot;horizontal&quot;
        className={clsx(
          // Base container styles
          &apos;flex gap-2 sm:gap-3 overflow-x-auto scrollbar-thin&apos;,
          &apos;scrollbar-thumb-gray-600 scrollbar-track-transparent&apos;,
          &apos;px-3 sm:px-4 py-3&apos;,

          // Mobile touch optimization
          &apos;touch-pan-x -webkit-overflow-scrolling: touch&apos;,
          &apos;snap-x snap-mandatory&apos;,

          // Prevent text selection while scrolling
          &apos;select-none&apos;,

          // Hide scrollbar on mobile for cleaner look
          &apos;sm:scrollbar-thin&apos;,
          &apos;[&amp;::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]&apos;,
          &apos;sm:[&amp;::-webkit-scrollbar]:h-2 sm:[&amp;::-webkit-scrollbar-thumb]:rounded-full&apos;,
          &apos;sm:[&amp;::-webkit-scrollbar-thumb]:bg-gray-600&apos;,
          &apos;sm:[&amp;::-webkit-scrollbar-track]:bg-transparent&apos;
        )}
        style={{
          // Custom scrollbar styles for mobile
          scrollbarWidth: &apos;none&apos;,
          msOverflowStyle: &apos;none&apos;
        }}
      &gt;
        {phrases.map((phrase, index) =&gt; (
          &lt;div
            key={`${phrase}-${index}`}
            className=&quot;flex-shrink-0 snap-start&quot;
            role=&quot;listitem&quot;
          &gt;
            &lt;PhrasePill
              phrase={phrase}
              isSelected={selectedPhrase === phrase}
              onClick={() =&gt; onPhraseSelect(phrase)}
            /&gt;
          &lt;/div&gt;
        ))}

        {/* Add some spacing at the end for better scroll experience */}
        &lt;div className=&quot;w-4 sm:w-8 flex-shrink-0&quot; /&gt;
      &lt;/div&gt;

      {/* Gradient fade indicators for desktop */}
      &lt;div className=&quot;hidden sm:block absolute left-0 top-0 bottom-0 w-8 bg-gradient-to-r from-gray-900 to-transparent pointer-events-none&quot; /&gt;
      &lt;div className=&quot;hidden sm:block absolute right-0 top-0 bottom-0 w-8 bg-gradient-to-l from-gray-900 to-transparent pointer-events-none&quot; /&gt;
    &lt;/div&gt;
  );
};

export default PhrasePills;</file><file path="src/components/session/CreateSessionDialog.tsx">import React, { useState } from &apos;react&apos;;
import { Modal } from &apos;../ui/Modal&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { Input } from &apos;../ui/Input&apos;;
import { useSessionStore } from &apos;../../store&apos;;
import { useRouter } from &apos;next/navigation&apos;;

interface CreateSessionDialogProps {
  isOpen: boolean;
  onClose: () =&gt; void;
  onCreate?: (session: any) =&gt; void;
}

export const CreateSessionDialog: React.FC&lt;CreateSessionDialogProps&gt; = ({
  isOpen,
  onClose,
  onCreate,
}) =&gt; {
  const [name, setName] = useState(&apos;&apos;);
  const [description, setDescription] = useState(&apos;&apos;);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(&apos;&apos;);

  const { createSession } = useSessionStore();
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) =&gt; {
    e.preventDefault();

    if (!name.trim()) {
      setError(&apos;Session name is required&apos;);
      return;
    }

    setIsLoading(true);
    setError(&apos;&apos;);

    try {
      const newSession = await createSession({
        name: name.trim(),
        description: description.trim() || undefined,
      });

      if (onCreate) {
        onCreate(newSession);
      } else {
        router.push(`/session/${newSession.id}`);
      }

      // Reset form
      setName(&apos;&apos;);
      setDescription(&apos;&apos;);
      onClose();
    } catch (error) {
      setError(error instanceof Error ? error.message : &apos;Failed to create session&apos;);
    } finally {
      setIsLoading(false);
    }
  };

  const handleClose = () =&gt; {
    if (!isLoading) {
      setName(&apos;&apos;);
      setDescription(&apos;&apos;);
      setError(&apos;&apos;);
      onClose();
    }
  };

  return (
    &lt;Modal
      isOpen={isOpen}
      onClose={handleClose}
      size=&quot;md&quot;
    &gt;
      &lt;form onSubmit={handleSubmit} className=&quot;space-y-4&quot;&gt;
        &lt;div&gt;
          &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;
            Create New Chat
          &lt;/h2&gt;
        &lt;/div&gt;

        {/* Session Name */}
        &lt;div&gt;
          &lt;Input
            label=&quot;Subject Name&quot;
            placeholder=&quot;Subject name like : MEDICINE, SURGERY etc&quot;
            value={name}
            onChange={(e) =&gt; setName(e.target.value)}
            required
            disabled={isLoading}
            autoFocus
          /&gt;
        &lt;/div&gt;

        {/* Description */}
        &lt;div&gt;
          &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;
            Description (optional)
          &lt;/label&gt;
          &lt;textarea
            value={description}
            onChange={(e) =&gt; setDescription(e.target.value)}
            placeholder=&quot;Brief description of this chat&apos;s purpose&quot;
            rows={3}
            disabled={isLoading}
            className={`
              w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg
              bg-white dark:bg-gray-800
              text-gray-900 dark:text-gray-100
              placeholder-gray-500 dark:placeholder-gray-400
              focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent
              disabled:opacity-50 disabled:cursor-not-allowed
              transition-colors duration-200
            `}
          /&gt;
        &lt;/div&gt;


        {/* Error Message */}
        {error &amp;&amp; (
          &lt;div className=&quot;p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg&quot;&gt;
            &lt;p className=&quot;text-sm text-red-600 dark:text-red-400&quot;&gt;{error}&lt;/p&gt;
          &lt;/div&gt;
        )}

        {/* Actions */}
        &lt;div className=&quot;flex gap-3 pt-4&quot;&gt;
          &lt;Button
            type=&quot;button&quot;
            variant=&quot;outline&quot;
            onClick={handleClose}
            disabled={isLoading}
            className=&quot;flex-1&quot;
          &gt;
            Cancel
          &lt;/Button&gt;

          &lt;Button
            type=&quot;submit&quot;
            loading={isLoading}
            disabled={!name.trim()}
            className=&quot;flex-1&quot;
          &gt;
            Create Chat
          &lt;/Button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/Modal&gt;
  );
};

// Hook for managing create session dialog
export const useCreateSessionDialog = () =&gt; {
  const [isOpen, setIsOpen] = useState(false);

  const openDialog = () =&gt; setIsOpen(true);
  const closeDialog = () =&gt; setIsOpen(false);

  const CreateSessionDialogComponent = () =&gt; (
    &lt;CreateSessionDialog
      isOpen={isOpen}
      onClose={closeDialog}
    /&gt;
  );

  return {
    isOpen,
    openDialog,
    closeDialog,
    CreateSessionDialog: CreateSessionDialogComponent,
  };
};</file><file path="src/components/ui/Button.tsx">import React from &apos;react&apos;;
import clsx from &apos;clsx&apos;;

interface ButtonProps extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {
  variant?: &apos;primary&apos; | &apos;secondary&apos; | &apos;outline&apos; | &apos;ghost&apos; | &apos;danger&apos;;
  size?: &apos;sm&apos; | &apos;md&apos; | &apos;lg&apos;;
  loading?: boolean;
  children: React.ReactNode;
}

export const Button: React.FC&lt;ButtonProps&gt; = ({
  variant = &apos;primary&apos;,
  size = &apos;md&apos;,
  loading = false,
  className,
  children,
  disabled,
  ...props
}) =&gt; {
  const baseClasses = &apos;inline-flex items-center justify-center font-medium rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2&apos;;
  
  const variantClasses = {
    primary: &apos;bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500 disabled:bg-blue-300 disabled:text-white&apos;,
    secondary: &apos;bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500 disabled:bg-gray-300 disabled:text-white&apos;,
    outline: &apos;border border-gray-300 text-gray-700 bg-white hover:bg-gray-50 focus:ring-blue-500 disabled:bg-gray-50 disabled:text-gray-700&apos;,
    ghost: &apos;text-gray-700 focus:ring-gray-500 disabled:text-gray-400&apos;,
    danger: &apos;bg-red-600 text-white hover:bg-red-700 focus:ring-red-500 disabled:bg-red-300 disabled:text-white&apos;,
  };
  
  const sizeClasses = {
    sm: &apos;px-3 py-1 text-sm&apos;,
    md: &apos;px-4 py-2 text-sm&apos;,
    lg: &apos;px-6 py-3 text-base&apos;,
  };

  return (
    &lt;button
      className={clsx(
        baseClasses,
        variantClasses[variant],
        sizeClasses[size],
        (disabled || loading) &amp;&amp; &apos;opacity-50 cursor-not-allowed&apos;,
        className
      )}
      disabled={disabled || loading}
      {...props}
    &gt;
      {loading &amp;&amp; (
        &lt;svg
          className=&quot;animate-spin -ml-1 mr-2 h-4 w-4&quot;
          xmlns=&quot;http://www.w3.org/2000/svg&quot;
          fill=&quot;none&quot;
          viewBox=&quot;0 0 24 24&quot;
        &gt;
          &lt;circle
            className=&quot;opacity-25&quot;
            cx=&quot;12&quot;
            cy=&quot;12&quot;
            r=&quot;10&quot;
            stroke=&quot;currentColor&quot;
            strokeWidth=&quot;4&quot;
          /&gt;
          &lt;path
            className=&quot;opacity-75&quot;
            fill=&quot;currentColor&quot;
            d=&quot;M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z&quot;
          /&gt;
        &lt;/svg&gt;
      )}
      {children}
    &lt;/button&gt;
  );
};</file><file path="src/components/ui/Modal.tsx">import React, { useEffect, useRef } from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;
import clsx from &apos;clsx&apos;;

interface ModalProps {
  isOpen: boolean;
  onClose: () =&gt; void;
  title?: string;
  children: React.ReactNode;
  size?: &apos;sm&apos; | &apos;md&apos; | &apos;lg&apos; | &apos;xl&apos;;
  showCloseButton?: boolean;
  closeOnBackdropClick?: boolean;
}

// Synchronous function to get or create the portal container - SSR-safe
function getOrCreatePortalContainer(): HTMLDivElement | null {
  // Check if we&apos;re in a browser environment
  if (typeof window === &apos;undefined&apos; || typeof document === &apos;undefined&apos;) {
    console.log(&apos;üîç Modal: SSR detected, skipping portal container creation&apos;);
    return null;
  }
  
  // Check if container already exists to prevent duplicates
  let container = document.querySelector(&apos;[data-modal-portal=&quot;true&quot;]&apos;) as HTMLDivElement;
  
  if (!container) {
    container = document.createElement(&apos;div&apos;);
    container.setAttribute(&apos;data-modal-portal&apos;, &apos;true&apos;);
    // Remove pointer-events: none to allow interaction with modal content
    container.style.cssText = &apos;position: fixed; top: 0; left: 0; z-index: 9999;&apos;;
    document.body.appendChild(container);
    console.log(&apos;‚úÖ Modal: New portal container created and appended to body&apos;);
  } else {
    console.log(&apos;üîç Modal: Using existing portal container&apos;);
  }
  
  return container;
}

export const Modal: React.FC&lt;ModalProps&gt; = ({
  isOpen,
  onClose,
  title,
  children,
  size = &apos;md&apos;,
  showCloseButton = true,
  closeOnBackdropClick = true,
}) =&gt; {
  const modalRef = useRef&lt;HTMLDivElement&gt;(null);
  const isRenderedRef = useRef(false);
  
  // Create a ref for the portal container that&apos;s initialized immediately
  const portalContainerRef = useRef&lt;HTMLDivElement | null&gt;(null);
  
  // Initialize portal container synchronously on first render (SSR-safe)
  if (!portalContainerRef.current) {
    portalContainerRef.current = getOrCreatePortalContainer();
    if (portalContainerRef.current) {
      console.log(&apos;‚úÖ Modal: Portal container initialized synchronously&apos;, {
        container: portalContainerRef.current,
        bodyChildren: typeof document !== &apos;undefined&apos; ? document.body.children.length : &apos;N/A (SSR)&apos;,
        containerStyles: portalContainerRef.current.style.cssText
      });
    }
  }

  // Cleanup effect for portal container
  useEffect(() =&gt; {
    return () =&gt; {
      console.log(&apos;üîç Modal: Cleanup effect triggered&apos;);
      // Don&apos;t remove the container on unmount as it might be used by other modals
      // Instead, just clear our reference
      portalContainerRef.current = null;
    };
  }, []);

  useEffect(() =&gt; {
    console.log(&apos;üîç Modal: isOpen changed&apos;, { isOpen, isRendered: isRenderedRef.current });
    const handleEscape = (event: KeyboardEvent) =&gt; {
      if (event.key === &apos;Escape&apos; &amp;&amp; isOpen) {
        onClose();
      }
    };

    if (isOpen) {
      if (typeof document !== &apos;undefined&apos;) {
        document.addEventListener(&apos;keydown&apos;, handleEscape);
        document.body.style.overflow = &apos;hidden&apos;;
        isRenderedRef.current = true;
        
        // Debug: Log body styles (SSR-safe)
        console.log(&apos;üîç Modal: Body styles after setting overflow:hidden&apos;, {
          overflow: document.body.style.overflow,
          computedOverflow: typeof window !== &apos;undefined&apos; ? window.getComputedStyle(document.body).overflow : &apos;N/A (SSR)&apos;
        });
      }
    } else {
      isRenderedRef.current = false;
    }

    return () =&gt; {
      if (typeof document !== &apos;undefined&apos;) {
        document.removeEventListener(&apos;keydown&apos;, handleEscape);
        document.body.style.overflow = &apos;unset&apos;;
      }
    };
  }, [isOpen, onClose]);

  // Debug modal content after it&apos;s mounted
  useEffect(() =&gt; {
    if (isOpen &amp;&amp; modalRef.current &amp;&amp; typeof window !== &apos;undefined&apos;) {
      console.log(&apos;üîç Modal: Modal content node mounted&apos;, {
        node: modalRef.current,
        className: modalRef.current.className,
        computedStyle: window.getComputedStyle(modalRef.current).cssText,
        offsetWidth: modalRef.current.offsetWidth,
        offsetHeight: modalRef.current.offsetHeight,
        offsetParent: modalRef.current.offsetParent,
        zIndex: window.getComputedStyle(modalRef.current).zIndex,
        visibility: window.getComputedStyle(modalRef.current).visibility,
        display: window.getComputedStyle(modalRef.current).display,
        opacity: window.getComputedStyle(modalRef.current).opacity,
        position: window.getComputedStyle(modalRef.current).position
      });
    }
  }, [isOpen]);

  const handleBackdropClick = (event: React.MouseEvent) =&gt; {
    if (event.target === event.currentTarget &amp;&amp; closeOnBackdropClick) {
      onClose();
    }
  };

  if (!isOpen) {
    console.log(&apos;üîç Modal: isOpen is false, returning null&apos;);
    return null;
  }

  console.log(&apos;üîç Modal: About to render modal content&apos;, {
    size,
    hasTitle: !!title,
    showCloseButton,
    closeOnBackdropClick,
    timestamp: new Date().toISOString()
  });

  const sizeClasses = {
    sm: &apos;max-w-md&apos;,
    md: &apos;max-w-lg&apos;,
    lg: &apos;max-w-2xl&apos;,
    xl: &apos;max-w-4xl&apos;,
  };

  const modalContent = (
    &lt;div
      className=&quot;fixed inset-0 z-50 overflow-y-auto&quot;
      ref={(node) =&gt; {
        if (node &amp;&amp; typeof window !== &apos;undefined&apos;) {
          console.log(&apos;üîç Modal: Modal root node created&apos;, {
            node,
            className: node.className,
            computedStyle: window.getComputedStyle(node).cssText
          });
        }
      }}
    &gt;
      &lt;div className=&quot;flex min-h-full items-center justify-center p-4&quot;&gt;
        {/* Backdrop */}
        &lt;div
          className=&quot;fixed inset-0 bg-black bg-opacity-50 transition-opacity&quot;
          onClick={handleBackdropClick}
          ref={(node) =&gt; {
            if (node &amp;&amp; typeof window !== &apos;undefined&apos;) {
              console.log(&apos;üîç Modal: Backdrop node created&apos;, {
                node,
                className: node.className,
                computedStyle: window.getComputedStyle(node).cssText
              });
            }
          }}
        /&gt;
        
        {/* Modal */}
        &lt;div
          ref={modalRef}
          className={clsx(
            &apos;relative w-full transform rounded-lg bg-white dark:bg-gray-800 text-left shadow-xl transition-all&apos;,
            sizeClasses[size]
          )}
        &gt;
          {/* Header */}
          {(title || showCloseButton) &amp;&amp; (
            &lt;div className=&quot;flex items-center justify-between border-b border-gray-200 dark:border-gray-700 px-6 py-4&quot;&gt;
              {title &amp;&amp; (
                &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;
                  {title}
                &lt;/h3&gt;
              )}
              
              {showCloseButton &amp;&amp; (
                &lt;button
                  onClick={onClose}
                  className=&quot;rounded-md text-gray-400 hover:text-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:hover:text-gray-300&quot;
                &gt;
                  &lt;svg
                    className=&quot;h-6 w-6&quot;
                    fill=&quot;none&quot;
                    viewBox=&quot;0 0 24 24&quot;
                    stroke=&quot;currentColor&quot;
                  &gt;
                    &lt;path
                      strokeLinecap=&quot;round&quot;
                      strokeLinejoin=&quot;round&quot;
                      strokeWidth={2}
                      d=&quot;M6 18L18 6M6 6l12 12&quot;
                    /&gt;
                  &lt;/svg&gt;
                &lt;/button&gt;
              )}
            &lt;/div&gt;
          )}
          
          {/* Body */}
          &lt;div className=&quot;px-6 py-4&quot;&gt;
            {children}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );

  console.log(&apos;üîç Modal: About to render via portal&apos;, {
    hasPortalContainer: !!portalContainerRef.current,
    portalContainer: portalContainerRef.current,
    portalContainerChildren: portalContainerRef.current?.childNodes.length || 0,
    isOpen,
    isRendered: isRenderedRef.current,
    timestamp: new Date().toISOString()
  });

  // Only render if we have a valid portal container and modal is open
  if (!portalContainerRef.current || !isOpen) {
    console.log(&apos;üîç Modal: Not rendering - missing container or not open&apos;, {
      hasContainer: !!portalContainerRef.current,
      isOpen,
      isRendered: isRenderedRef.current,
      timestamp: new Date().toISOString()
    });
    return null;
  }

  // Use portal to render at document.body level (SSR-safe)
  const renderStartTime = Date.now();
  const portalResult = ReactDOM.createPortal(modalContent, portalContainerRef.current);
  const renderEndTime = Date.now();
  
  console.log(&apos;üîç Modal: Portal render completed&apos;, {
    portalResult: !!portalResult,
    portalContainerChildrenAfter: portalContainerRef.current?.childNodes.length,
    renderDuration: renderEndTime - renderStartTime,
    timestamp: new Date().toISOString()
  });

  // Debug: Check if modal is actually in DOM after render (SSR-safe)
  if (typeof window !== &apos;undefined&apos;) {
    setTimeout(() =&gt; {
      if (portalContainerRef.current &amp;&amp; isRenderedRef.current) {
        const modalElements = portalContainerRef.current.querySelectorAll(&apos;[class*=&quot;fixed&quot;], [class*=&quot;modal&quot;]&apos;);
        console.log(&apos;üîç Modal: DOM check after render&apos;, {
          modalElements: modalElements.length,
          portalContainerHTML: portalContainerRef.current.innerHTML.substring(0, 200) + &apos;...&apos;,
          portalContainerVisible: portalContainerRef.current.offsetParent !== null,
          portalContainerStyles: window.getComputedStyle(portalContainerRef.current).cssText,
          isRendered: isRenderedRef.current,
          timestamp: new Date().toISOString()
        });
      } else {
        console.log(&apos;üîç Modal: DOM check skipped - no container or not rendered&apos;, {
          hasContainer: !!portalContainerRef.current,
          isRendered: isRenderedRef.current,
          timestamp: new Date().toISOString()
        });
      }
    }, 100);
  }

  return portalResult;
};

interface ModalFooterProps {
  children: React.ReactNode;
  className?: string;
}

export const ModalFooter: React.FC&lt;ModalFooterProps&gt; = ({
  children,
  className,
}) =&gt; {
  return (
    &lt;div className={clsx(&apos;border-t border-gray-200 dark:border-gray-700 px-6 py-4&apos;, className)}&gt;
      &lt;div className=&quot;flex justify-end space-x-3&quot;&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</file><file path="src/services/indexedDB/db.ts">import Dexie, { Table } from &apos;dexie&apos;;

// Define EntityTable type locally if not exported from dexie
type EntityTable&lt;T&gt; = Table&lt;T&gt;;
import type {
  Session,
  Message,
  Document,
  EmbeddingChunk,
  AppSettings,
} from &apos;@/types&apos;;

export class RAGDatabase extends Dexie {
  // Tables
  sessions!: EntityTable&lt;Session&gt;;
  messages!: EntityTable&lt;Message&gt;;
  documents!: EntityTable&lt;Document&gt;;
  embeddings!: EntityTable&lt;EmbeddingChunk&gt;;
  settings!: EntityTable&lt;AppSettings&gt;;

  constructor() {
    super(&apos;RAGDatabase&apos;);

    this.version(1).stores({
      sessions: &apos;&amp;id, name, description, systemPrompt, createdAt, updatedAt, documentCount&apos;,
      messages: &apos;&amp;id, sessionId, role, content, timestamp, citationsJson&apos;,
      documents: &apos;&amp;id, sessionId, filename, fileSize, status, pageCount, processedAt, createdAt, enabled, originalPath, storedPath, mimeType, checksum, title, author, language, ingestError&apos;,
      embeddings: &apos;&amp;id, documentId, sessionId, chunkIndex, content, source, page, embedding, tokenCount, embeddingNorm, createdAt&apos;,
      settings: &apos;&amp;id, geminiModel, topK, apiKey&apos;,
    });

    this.version(2).stores({
      sessions: &apos;&amp;id, name, description, systemPrompt, createdAt, updatedAt, documentCount&apos;,
      messages: &apos;&amp;id, sessionId, role, content, timestamp, citationsJson&apos;,
      documents: &apos;&amp;id, sessionId, filename, fileSize, status, pageCount, processedAt, createdAt, enabled, originalPath, storedPath, mimeType, checksum, title, author, language, ingestError&apos;,
      embeddings: &apos;&amp;id, documentId, sessionId, chunkIndex, content, source, page, embedding, tokenCount, embeddingNorm, createdAt&apos;,
      settings: &apos;&amp;id, geminiApiKey, temperature, maxTokens, similarityThreshold, chunkSize, chunkOverlap, theme, fontSize, showSources, autoSave, dataRetention, enableAnalytics, crashReporting, debugMode, logLevel&apos;,
    });

    // Version 3: Add support for pageNumbers in embeddings metadata
    this.version(3).stores({
      sessions: &apos;&amp;id, name, description, systemPrompt, createdAt, updatedAt, documentCount&apos;,
      messages: &apos;&amp;id, sessionId, role, content, timestamp, citationsJson&apos;,
      documents: &apos;&amp;id, sessionId, filename, fileSize, status, pageCount, processedAt, createdAt, enabled, originalPath, storedPath, mimeType, checksum, title, author, language, ingestError&apos;,
      embeddings: &apos;&amp;id, documentId, sessionId, chunkIndex, content, source, page, embedding, tokenCount, embeddingNorm, createdAt&apos;,
      settings: &apos;&amp;id, geminiApiKey, temperature, maxTokens, similarityThreshold, chunkSize, chunkOverlap, theme, fontSize, showSources, autoSave, dataRetention, enableAnalytics, crashReporting, debugMode, logLevel&apos;,
    }).upgrade(tx =&gt; {
      // Migration for existing embeddings to ensure backward compatibility
      return tx.table(&apos;embeddings&apos;).toCollection().modify((embedding: any) =&gt; {
        // Ensure metadata exists and has proper structure
        if (!embedding.metadata) {
          embedding.metadata = {};
        }

        // If pageNumbers doesn&apos;t exist but pageNumber does, create pageNumbers array
        if (!embedding.metadata.pageNumbers &amp;&amp; embedding.metadata.pageNumber) {
          embedding.metadata.pageNumbers = [embedding.metadata.pageNumber];
        }
      });
    });

    // Version 4: Add userId to all tables
    this.version(4).stores({
      sessions: &apos;&amp;id, userId, name, description, systemPrompt, createdAt, updatedAt, documentCount&apos;,
      messages: &apos;&amp;id, sessionId, role, content, timestamp, citationsJson&apos;, // Messages are linked to session, which has userId
      documents: &apos;&amp;id, userId, sessionId, filename, fileSize, status, pageCount, processedAt, createdAt, enabled, originalPath, storedPath, mimeType, checksum, title, author, language, ingestError&apos;,
      embeddings: &apos;&amp;id, documentId, sessionId, chunkIndex, content, source, page, embedding, tokenCount, embeddingNorm, createdAt&apos;, // Embeddings linked to document/session
      settings: &apos;&amp;id, userId, geminiApiKey, temperature, maxTokens, similarityThreshold, chunkSize, chunkOverlap, theme, fontSize, showSources, autoSave, dataRetention, enableAnalytics, crashReporting, debugMode, logLevel&apos;,
    });

    // NEW: Version 5 to add &apos;model&apos; to settings
    this.version(5).stores({
      sessions: &apos;&amp;id, userId, name, description, systemPrompt, createdAt, updatedAt, documentCount&apos;,
      messages: &apos;&amp;id, sessionId, role, content, timestamp, citationsJson&apos;,
      documents: &apos;&amp;id, userId, sessionId, filename, fileSize, status, pageCount, processedAt, createdAt, enabled, originalPath, storedPath, mimeType, checksum, title, author, language, ingestError&apos;,
      embeddings: &apos;&amp;id, documentId, sessionId, chunkIndex, content, source, page, embedding, tokenCount, embeddingNorm, createdAt&apos;,
      settings: &apos;&amp;id, userId, geminiApiKey, model, temperature, maxTokens, similarityThreshold, chunkSize, chunkOverlap, theme, fontSize, showSources, autoSave, dataRetention, enableAnalytics, crashReporting, debugMode, logLevel&apos;,
    }).upgrade(tx =&gt; {
      // Upgrade existing settings to have a default model
      return tx.table(&apos;settings&apos;).toCollection().modify(setting =&gt; {
        if (!setting.model) {
          setting.model = &apos;gemini-2.5-flash-lite&apos;;
        }
      });
    });
  }
}

// Only create database instance on client side
export const db = typeof window !== &apos;undefined&apos; ? new RAGDatabase() : null;

// Helper functions for database operations
export const initDB = async (): Promise&lt;void&gt; =&gt; {
  if (!db) return;
  try {
    await db.open();
    console.log(&apos;Database opened successfully&apos;);
  } catch (error) {
    console.error(&apos;Failed to open database:&apos;, error);
    throw error;
  }
};

// Export database instance for use throughout the app
export default db;</file><file path="src/services/indexedDB/settingsService.ts">import { db } from &apos;./db&apos;;
import type { AppSettings, SettingsUpdate } from &apos;@/types&apos;;
import { userIdLogger } from &apos;@/utils/userIdDebugLogger&apos;;

export class SettingsService {
  private getSettingsId(userId: string): string {
    return `app-settings-${userId}`;
  }

  /**
   * Get app settings for a user
   */
  async getSettings(userId: string): Promise&lt;AppSettings | undefined&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;getSettings&apos;, &apos;read&apos;, userId);
    
    if (!db) return undefined;
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.getSettings&apos;, new Error(&apos;Attempt to get settings without userId&apos;), userId);
      return undefined;
    }
    
    const id = this.getSettingsId(userId);
    const settings = await db.settings.get(id);
    console.log(&apos;[SETTINGS GET]&apos;, `Retrieved settings for user: ${userId}`);
    return settings;
  }

  /**
   * Get default settings
   */
  getDefaultSettings(userId: string): AppSettings {
    const defaultSettings: AppSettings = {
      id: this.getSettingsId(userId),
      userId,
      geminiApiKey: &apos;&apos;,
      model: &apos;gemini-2.5-flash-lite&apos;,
      temperature: 0.7,
      maxTokens: 4096,
      similarityThreshold: 0.7,
      chunkSize: 1000,
      chunkOverlap: 200,
      theme: &apos;dark&apos; as const,
      fontSize: &apos;medium&apos; as const,
      showSources: true,
      autoSave: true,
      dataRetention: &apos;never&apos; as const,
      enableAnalytics: false,
      crashReporting: false,
      debugMode: false,
      logLevel: &apos;error&apos; as const,
    };

    return defaultSettings;
  }

  /**
   * Create or update settings
   */
  async updateSettings(updates: SettingsUpdate, userId: string): Promise&lt;AppSettings&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;updateSettings&apos;, &apos;update&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.updateSettings&apos;, new Error(&apos;Attempt to update settings without userId&apos;), userId);
      throw new Error(&apos;userId is required to update settings&apos;);
    }
    
    const existing = await this.getSettings(userId);
    const settings = existing ? { ...existing, ...updates } : { ...this.getDefaultSettings(userId), ...updates };

    // Ensure IDs match
    settings.id = this.getSettingsId(userId);
    settings.userId = userId;

    if (!db) throw new Error(&apos;Database not available&apos;);
    await db.settings.put(settings);
    return settings;
  }

  /**
   * Update API key
   */
  /**
   * Update API key
   */
  async updateApiKey(geminiApiKey: string, userId: string): Promise&lt;AppSettings&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;updateApiKey&apos;, &apos;update&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.updateApiKey&apos;, new Error(&apos;Attempt to update API key without userId&apos;), userId);
      throw new Error(&apos;userId is required to update API key&apos;);
    }
    
    return await this.updateSettings({ geminiApiKey }, userId);
  }



  /**
   * Update generation settings
   */
  /**
   * Update generation settings
   */
  async updateGenerationSettings(
    maxTokens: number,
    temperature: number,
    userId: string
  ): Promise&lt;AppSettings&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;updateGenerationSettings&apos;, &apos;update&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.updateGenerationSettings&apos;, new Error(&apos;Attempt to update generation settings without userId&apos;), userId);
      throw new Error(&apos;userId is required to update generation settings&apos;);
    }
    
    return await this.updateSettings({ maxTokens, temperature }, userId);
  }

  /**
   * Update UI settings
   */
  /**
   * Update UI settings
   */
  async updateUISettings(theme: &apos;dark&apos; | &apos;light&apos;, fontSize: &apos;small&apos; | &apos;medium&apos; | &apos;large&apos;, userId: string): Promise&lt;AppSettings&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;updateUISettings&apos;, &apos;update&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.updateUISettings&apos;, new Error(&apos;Attempt to update UI settings without userId&apos;), userId);
      throw new Error(&apos;userId is required to update UI settings&apos;);
    }
    
    return await this.updateSettings({ theme, fontSize }, userId);
  }

  /**
   * Toggle sources display
   */
  /**
   * Toggle sources display
   */
  async toggleShowSources(userId: string): Promise&lt;AppSettings&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;toggleShowSources&apos;, &apos;update&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.toggleShowSources&apos;, new Error(&apos;Attempt to toggle show sources without userId&apos;), userId);
      throw new Error(&apos;userId is required to toggle show sources&apos;);
    }
    
    const existing = await this.getSettings(userId);
    const showSources = existing ? !existing.showSources : true;
    return await this.updateSettings({ showSources }, userId);
  }

  /**
   * Reset settings to defaults
   */
  /**
   * Reset settings to defaults
   */
  async resetSettings(userId: string): Promise&lt;AppSettings&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;resetSettings&apos;, &apos;update&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.resetSettings&apos;, new Error(&apos;Attempt to reset settings without userId&apos;), userId);
      throw new Error(&apos;userId is required to reset settings&apos;);
    }
    
    if (!db) throw new Error(&apos;Database not available&apos;);
    const defaultSettings = this.getDefaultSettings(userId);
    await db.settings.put(defaultSettings);
    return defaultSettings;
  }

  /**
   * Check if API key is configured
   */
  /**
   * Check if API key is configured
   */
  async hasApiKey(userId: string): Promise&lt;boolean&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;hasApiKey&apos;, &apos;read&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.hasApiKey&apos;, new Error(&apos;Attempt to check API key without userId&apos;), userId);
      return false;
    }
    
    const settings = await this.getSettings(userId);
    return !!(settings?.geminiApiKey &amp;&amp; settings.geminiApiKey.trim().length &gt; 0);
  }

  /**
   * Get API key (masked for display)
   */
  /**
   * Get API key (masked for display)
   */
  async getMaskedApiKey(userId: string): Promise&lt;string&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;getMaskedApiKey&apos;, &apos;read&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.getMaskedApiKey&apos;, new Error(&apos;Attempt to get masked API key without userId&apos;), userId);
      return &apos;&apos;;
    }
    
    const settings = await this.getSettings(userId);
    if (!settings?.geminiApiKey) return &apos;&apos;;

    const key = settings.geminiApiKey;
    if (key.length &lt;= 10) return key;

    return key.substring(0, 7) + &apos;...&apos; + key.substring(key.length - 3);
  }

  /**
   * Validate API key format
   */
  validateApiKey(geminiApiKey: string): boolean {
    // Basic Gemini API key validation
    const geminiKeyPattern = /^AIza[0-9A-Za-z_-]{35}$/;
    return geminiKeyPattern.test(geminiApiKey);
  }

  /**
   * Export settings
   */
  /**
   * Export settings
   */
  async exportSettings(userId: string): Promise&lt;string&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;exportSettings&apos;, &apos;read&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.exportSettings&apos;, new Error(&apos;Attempt to export settings without userId&apos;), userId);
      throw new Error(&apos;userId is required to export settings&apos;);
    }
    
    const settings = await this.getSettings(userId);
    if (!settings) throw new Error(&apos;No settings to export&apos;);

    // Create exportable settings (without sensitive data)
    const exportable = {
      temperature: settings.temperature,
      maxTokens: settings.maxTokens,
      similarityThreshold: settings.similarityThreshold,
      chunkSize: settings.chunkSize,
      chunkOverlap: settings.chunkOverlap,
      theme: settings.theme,
      fontSize: settings.fontSize,
      showSources: settings.showSources,
      autoSave: settings.autoSave,
      dataRetention: settings.dataRetention,
      enableAnalytics: settings.enableAnalytics,
      crashReporting: settings.crashReporting,
      debugMode: settings.debugMode,
      logLevel: settings.logLevel,
    };

    return JSON.stringify(exportable, null, 2);
  }

  /**
   * Import settings
   */
  async importSettings(settingsJson: string, userId: string): Promise&lt;AppSettings&gt; {
    userIdLogger.logServiceCall(&apos;settingsService&apos;, &apos;importSettings&apos;, &apos;update&apos;, userId);
    
    // Validate userId
    if (!userId) {
      userIdLogger.logError(&apos;settingsService.importSettings&apos;, new Error(&apos;Attempt to import settings without userId&apos;), userId);
      throw new Error(&apos;userId is required to import settings&apos;);
    }
    
    try {
      const imported = JSON.parse(settingsJson);

      // Validate imported settings
      const validUpdates: SettingsUpdate = {};

      if (typeof imported.similarityThreshold === &apos;number&apos; &amp;&amp; imported.similarityThreshold &gt;= 0 &amp;&amp; imported.similarityThreshold &lt;= 1) {
        validUpdates.similarityThreshold = imported.similarityThreshold;
      }
      if (typeof imported.chunkSize === &apos;number&apos; &amp;&amp; imported.chunkSize &gt; 0) {
        validUpdates.chunkSize = imported.chunkSize;
      }
      if (typeof imported.chunkOverlap === &apos;number&apos; &amp;&amp; imported.chunkOverlap &gt;= 0) {
        validUpdates.chunkOverlap = imported.chunkOverlap;
      }
      if (typeof imported.maxTokens === &apos;number&apos; &amp;&amp; imported.maxTokens &gt; 0) {
        validUpdates.maxTokens = imported.maxTokens;
      }
      if (typeof imported.temperature === &apos;number&apos; &amp;&amp; imported.temperature &gt;= 0 &amp;&amp; imported.temperature &lt;= 2) {
        validUpdates.temperature = imported.temperature;
      }
      if (typeof imported.showSources === &apos;boolean&apos;) {
        validUpdates.showSources = imported.showSources;
      }
      if (typeof imported.autoSave === &apos;boolean&apos;) {
        validUpdates.autoSave = imported.autoSave;
      }
      if (typeof imported.dataRetention === &apos;string&apos;) {
        validUpdates.dataRetention = imported.dataRetention;
      }
      if (typeof imported.enableAnalytics === &apos;boolean&apos;) {
        validUpdates.enableAnalytics = imported.enableAnalytics;
      }
      if (typeof imported.crashReporting === &apos;boolean&apos;) {
        validUpdates.crashReporting = imported.crashReporting;
      }
      if (typeof imported.debugMode === &apos;boolean&apos;) {
        validUpdates.debugMode = imported.debugMode;
      }
      if (typeof imported.logLevel === &apos;string&apos;) {
        validUpdates.logLevel = imported.logLevel;
      }

      return await this.updateSettings(validUpdates, userId);
    } catch (error) {
      throw new Error(&apos;Invalid settings format&apos;);
    }
  }
}

export const settingsService = new SettingsService();</file><file path="src/services/rag/responseFormatter.ts">/**
 * Response Formatter Service
 * Uses LLM to convert paragraph-style responses to bullet point format while preserving citations
 */

import { GeminiService } from &apos;../gemini/geminiService&apos;;
import type { AppSettings } from &apos;@/types/settings&apos;;
import { IndentationAnalyzer } from &apos;@/utils/indentationAnalyzer&apos;;

export interface FormattedSection {
  title: string;
  bulletPoints: string[];
  citations: number[];
}

export class ResponseFormatter {
  /**
   * Convert paragraph response to bullet point format using LLM
   * Preserves citations and moves them to end of bullet points
   */
  static async formatToBulletPoints(
    response: string,
    settings: AppSettings
  ): Promise&lt;string&gt; {
    const timestamp = new Date().toISOString();
    console.log(`\n=== [${timestamp}] [INDENTATION DEBUG] LLM RESPONSE FORMATTER START ===`);
    console.log(`[${timestamp}] [INDENTATION DEBUG] ORIGINAL RESPONSE:`, response.substring(0, 200) + (response.length &gt; 200 ? &apos;...&apos; : &apos;&apos;));
    console.log(`[${timestamp}] [INDENTATION DEBUG] ORIGINAL LENGTH:`, `${response.length} characters`);
    
    // Analyze original response for indentation patterns
    console.log(`[${timestamp}] [INDENTATION DEBUG] ANALYZING ORIGINAL RESPONSE STRUCTURE:`);
    IndentationAnalyzer.logMarkdownStructure(response);
    const originalAnalysis = IndentationAnalyzer.analyzeIndentation(response);
    console.log(`[${timestamp}] [INDENTATION DEBUG] ORIGINAL RESPONSE HAS NESTED STRUCTURES:`, originalAnalysis.hasNestedStructures);
    
    if (!response || response.trim().length === 0) {
      console.log(`[${timestamp}] [INDENTATION DEBUG] FORMATTING SKIPPED:`, &apos;Empty response, returning as-is&apos;);
      console.log(`=== [${timestamp}] [INDENTATION DEBUG] LLM RESPONSE FORMATTER END ===\n`);
      return response;
    }

    // Use main API key for formatting
    const formattingApiKey = settings.geminiApiKey;
    
    console.log(`[${timestamp}] [INDENTATION DEBUG] LLM FORMATTER:`, &apos;Using main API key for formatting:&apos;, settings.geminiApiKey ? `YES (${settings.geminiApiKey.substring(0, 10)}...)` : &apos;NO&apos;);
    
    if (!formattingApiKey) {
      console.log(`[${timestamp}] [INDENTATION DEBUG] FORMATTING SKIPPED:`, &apos;No API key available, returning original response&apos;);
      console.log(`=== [${timestamp}] [INDENTATION DEBUG] LLM RESPONSE FORMATTER END ===\n`);
      return response;
    }

    try {
      console.log(`[${timestamp}] [INDENTATION DEBUG] LLM FORMATTING:`, &apos;Using LLM to convert to bullet points...&apos;);
      console.log(`[${timestamp}] [INDENTATION DEBUG] LLM FORMATTING:`, `Calling Gemini service with main API key`);
      
      const formattingPrompt = this.buildFormattingPrompt(response);
      console.log(`[${timestamp}] [INDENTATION DEBUG] FORMATTING PROMPT:`, formattingPrompt.substring(0, 300) + &apos;...&apos;);
      console.log(`[${timestamp}] [INDENTATION DEBUG] PROMPT ANALYSIS:`, {
        promptLength: formattingPrompt.length,
        containsNestedInstructions: formattingPrompt.includes(&apos;NESTED&apos;),
        containsIndentInstructions: formattingPrompt.includes(&apos;indent&apos;),
        containsBulletInstructions: formattingPrompt.includes(&apos;*&apos;),
        containsExampleFormatting: formattingPrompt.includes(&apos;EXAMPLE TRANSFORMATION&apos;)
      });
      
      // Create a separate instance for formatting to avoid conflicts
      const formattingGeminiService = new GeminiService();
      formattingGeminiService.initialize(formattingApiKey, &apos;gemini-2.5-flash-lite&apos;);
      
      const formattedResponse = await formattingGeminiService.generateResponse(
        formattingPrompt,
        &apos;&apos;, // No context needed for formatting
        &apos;&apos;, // No system prompt needed for formatting
        {
          temperature: 0.3, // Lower temperature for consistent formatting
          maxTokens: Math.min(response.length * 2, 4000), // Allow for expansion but cap it
        }
      );
      
      console.log(`[${timestamp}] [INDENTATION DEBUG] LLM FORMATTING:`, &apos;Gemini service response received, length:&apos;, formattedResponse.length);
      
      // Comprehensive analysis of formatted response
      console.log(`[${timestamp}] [INDENTATION DEBUG] ANALYZING FORMATTED RESPONSE STRUCTURE:`);
      IndentationAnalyzer.logMarkdownStructure(formattedResponse);
      const formattedAnalysis = IndentationAnalyzer.analyzeIndentation(formattedResponse);
      
      // Check for nested structures detection
      const hasNestedStructures = IndentationAnalyzer.detectNestedLists(formattedResponse);
      console.log(`[${timestamp}] [INDENTATION DEBUG] NESTED STRUCTURES DETECTED IN FORMATTED RESPONSE:`, hasNestedStructures);
      
      // Create visualization of indentation
      console.log(`[${timestamp}] [INDENTATION DEBUG] FORMATTED RESPONSE INDENTATION VISUALIZATION:`);
      IndentationAnalyzer.visualizeIndentation(formattedResponse);
      
      // Additional detailed analysis
      const hasNewlines = formattedResponse.includes(&apos;\n&apos;);
      const bulletCount = (formattedResponse.match(/^\* /gm) || []).length;
      const newlineCount = (formattedResponse.match(/\n/g) || []).length;
      const nestedBulletCount = (formattedResponse.match(/^[ \t]+\* /gm) || []).length;
      
      console.log(`[${timestamp}] [INDENTATION DEBUG] FORMATTING ANALYSIS:`, {
        hasNewlines,
        bulletCount,
        newlineCount,
        nestedBulletCount,
        firstBulletIndex: formattedResponse.indexOf(&apos;* &apos;),
        containsListMarkers: formattedResponse.includes(&apos;* &apos;),
        startsWithBullet: formattedResponse.trim().startsWith(&apos;* &apos;),
        hasIndentation: formattedAnalysis.indentedLines &gt; 0,
        maxIndentLevel: formattedAnalysis.maxIndentLevel,
        responsePreview: formattedResponse.substring(0, 300) + (formattedResponse.length &gt; 300 ? &apos;...&apos; : &apos;&apos;),
        rawCharCodes: Array.from(formattedResponse.substring(0, 100)).map(c =&gt; `${c}(${c.charCodeAt(0)})`).join(&apos; &apos;)
      });
      
      // Compare original vs formatted
      console.log(`[${timestamp}] [INDENTATION DEBUG] ORIGINAL vs FORMATTED COMPARISON:`, {
        originalHadNested: originalAnalysis.hasNestedStructures,
        formattedHasNested: formattedAnalysis.hasNestedStructures,
        originalIndentedLines: originalAnalysis.indentedLines,
        formattedIndentedLines: formattedAnalysis.indentedLines,
        originalMaxIndent: originalAnalysis.maxIndentLevel,
        formattedMaxIndent: formattedAnalysis.maxIndentLevel,
        improvement: formattedAnalysis.maxIndentLevel &gt; originalAnalysis.maxIndentLevel ? &apos;YES - Added nesting&apos; : &apos;NO - No improvement&apos;
      });
      
      console.log(`[${timestamp}] [INDENTATION DEBUG] LLM FORMATTING COMPLETE:`, `Formatted response: ${formattedResponse.length} characters`);
      console.log(`[${timestamp}] [INDENTATION DEBUG] FORMATTED PREVIEW:`, formattedResponse.substring(0, 200) + (formattedResponse.length &gt; 200 ? &apos;...&apos; : &apos;&apos;));
      console.log(`=== [${timestamp}] [INDENTATION DEBUG] LLM RESPONSE FORMATTER END ===\n`);
      
      return formattedResponse;
      
    } catch (error) {
      console.error(`[${timestamp}] [INDENTATION DEBUG] LLM FORMATTING ERROR:`, &apos;Failed to format with LLM:&apos;, error);
      console.log(`[${timestamp}] [INDENTATION DEBUG] FALLBACK:`, &apos;Returning original response due to formatting error&apos;);
      console.log(`=== [${timestamp}] [INDENTATION DEBUG] LLM RESPONSE FORMATTER END ===\n`);
      return response;
    }
  }

  /**
   * Build the formatting prompt for the LLM
   */
  private static buildFormattingPrompt(response: string): string {
    return `You are a response formatting specialist. Your task is to convert paragraph-style responses to clear, structured, NESTED bullet point lists while preserving all citations.

CRITICAL FORMATTING RULES:
1. Use standard Markdown bullet points: * for top level, and indent 2-4 spaces with * for sub-levels.
2. DETECT HIERARCHY: If a sentence acts as a header (e.g., &quot;Early Surgery:&quot;, &quot;Treatments include:&quot;), the items following it MUST be indented.
3. Format:
   * Main Category or Timeframe
     * Sub-point with citation [1]
     * Another sub-point [2]
4. Preserve ALL citations in their original positions.
5. Move citations to the END of the specific bullet point they support.
6. Create logical section headers using bold format with checkmark emoji: ‚úÖ **[Section Title]:**
7. Do not add, remove, or change any factual information.

EXAMPLE TRANSFORMATION:

INPUT:
&quot;Surgical management includes early surgery within 2 weeks involving limbal stem cell transplantation [1] and amniotic membrane grafts [2]. Late surgery after 6 months involves symblepharon release [3] and keratoplasty [1].&quot;

OUTPUT:
‚úÖ **Surgical Management:**
* Early Surgery (within 2 weeks):
    * Limbal stem cell transplantation [1]
    * Amniotic membrane grafts [2]
* Late Surgery (after 6 months):
    * Release of conjunctival bands (symblepharon release) [3]
    * Keratoplasty [1]

YOUR TASK:
Convert the following response to a nested bullet point format following the rules above:

${response}`;
  }

  /**
   * Legacy rule-based method (kept as fallback)
   */
  static async formatToBulletPointsLegacy(response: string): Promise&lt;string&gt; {
    console.log(&apos;[LEGACY FORMATTING]&apos;, &apos;Using rule-based formatting as fallback&apos;);
    
    if (!response || response.trim().length === 0) {
      return response;
    }

    // Extract all citations first to preserve them
    const citations = this.extractCitations(response);
    const responseWithoutCitations = this.removeCitations(response);
    
    // Split response into logical sections
    const sections = this.identifySections(responseWithoutCitations);
    
    // Format each section with bullet points
    const formattedSections = sections.map(section =&gt; 
      this.formatSection(section, citations)
    );
    
    // Combine all sections
    return formattedSections.join(&apos;\n\n&apos;);
  }

  /**
   * Extract citation references from text
   */
  private static extractCitations(text: string): Array&lt;{index: number, position: number}&gt; {
    const citationPattern = /\[(\d+)\]/g;
    const citations: Array&lt;{index: number, position: number}&gt; = [];
    let match;

    while ((match = citationPattern.exec(text)) !== null) {
      citations.push({
        index: parseInt(match[1], 10),
        position: match.index
      });
    }

    return citations;
  }

  /**
   * Remove citations from text for processing
   */
  private static removeCitations(text: string): string {
    return text.replace(/\[\d+\]/g, &apos;&apos;);
  }

  /**
   * Identify logical sections in the response
   */
  private static identifySections(text: string): Array&lt;{title: string, content: string}&gt; {
    console.log(&apos;[SECTION ANALYSIS]&apos;, `Analyzing text of ${text.length} characters`);
    const sections: Array&lt;{title: string, content: string}&gt; = [];
    
    // Split by double newlines or major sentence breaks
    const paragraphs = text.split(/\n\s*\n/);
    console.log(&apos;[PARAGRAPH SPLIT]&apos;, `Found ${paragraphs.length} paragraphs`);
    
    for (let i = 0; i &lt; paragraphs.length; i++) {
      const paragraph = paragraphs[i];
      const trimmed = paragraph.trim();
      if (trimmed.length === 0) {
        console.log(`[PARAGRAPH ${i}]`, &apos;Empty paragraph, skipping&apos;);
        continue;
      }
      
      console.log(`[PARAGRAPH ${i}]`, `Content: &quot;${trimmed.substring(0, 80)}${trimmed.length &gt; 80 ? &apos;...&apos; : &apos;&apos;}&quot;`);
      
      // Check if this looks like a header or main topic
      const isHeader = this.isHeader(trimmed);
      console.log(`[PARAGRAPH ${i}]`, `Is header: ${isHeader}`);
      
      if (isHeader || sections.length === 0) {
        const title = isHeader ? this.cleanHeader(trimmed) : &apos;Main Points&apos;;
        const content = isHeader ? &apos;&apos; : trimmed;
        sections.push({ title, content });
        console.log(`[SECTION CREATED]`, `Title: &quot;${title}&quot;, Content length: ${content.length}`);
      } else {
        // Add to last section
        const lastSection = sections[sections.length - 1];
        lastSection.content += (lastSection.content ? &apos; &apos; : &apos;&apos;) + trimmed;
        console.log(`[SECTION UPDATED]`, `Added to &quot;${lastSection.title}&quot;, new length: ${lastSection.content.length}`);
      }
    }
    
    console.log(&apos;[SECTION ANALYSIS COMPLETE]&apos;, `Created ${sections.length} sections`);
    return sections;
  }

  /**
   * Check if text looks like a header
   */
  private static isHeader(text: string): boolean {
    // Headers are typically shorter, may end with colon, or contain keywords
    const headerKeywords = [
      &apos;criteria&apos;, &apos;factors&apos;, &apos;features&apos;, &apos;symptoms&apos;, &apos;treatment&apos;, 
      &apos;diagnosis&apos;, &apos;management&apos;, &apos;assessment&apos;, &apos;findings&apos;, &apos;results&apos;
    ];
    
    const isShort = text.length &lt; 100;
    const endsWithColon = text.trim().endsWith(&apos;:&apos;);
    const hasKeyword = headerKeywords.some(keyword =&gt; 
      text.toLowerCase().includes(keyword)
    );
    
    return isShort &amp;&amp; (endsWithColon || hasKeyword);
  }

  /**
   * Clean header text
   */
  private static cleanHeader(header: string): string {
    return header
      .replace(/[:Ôºö]$/, &apos;&apos;) // Remove trailing colons
      .replace(/^\*\s*/, &apos;&apos;) // Remove leading bullets
      .trim();
  }

  /**
   * Format a section into bullet points with citations
   */
  private static formatSection(
    section: {title: string, content: string}, 
    citations: Array&lt;{index: number, position: number}&gt;
  ): string {
    console.log(`[SECTION FORMATTING]`, `Formatting section: &quot;${section.title}&quot; with ${section.content.length} chars`);
    
    const bulletPoints = this.createBulletPoints(section.content);
    console.log(`[SECTION FORMATTING]`, `Created ${bulletPoints.length} bullet points for section`);
    
    // Add citations to bullet points
    const bulletPointsWithCitations = bulletPoints.map((point, index) =&gt; {
      const pointCitations = this.getCitationsForPoint(point, section.content, citations);
      console.log(`[BULLET ${index + 1}]`, `Point: &quot;${point.substring(0, 60)}${point.length &gt; 60 ? &apos;...&apos; : &apos;&apos;}&quot;`);
      console.log(`[BULLET ${index + 1}]`, `Citations found: ${pointCitations.length &gt; 0 ? pointCitations.map(c =&gt; `[${c}]`).join(&apos;, &apos;) : &apos;None&apos;}`);
      
      const citationText = pointCitations.length &gt; 0 
        ? &apos; &apos; + pointCitations.map(c =&gt; `[${c}]`).join(&apos;, &apos;)
        : &apos;&apos;;
      return `* ${point}${citationText}`;
    });

    // Format section
    let formatted = `‚úÖ **${section.title}:**\n`;
    formatted += bulletPointsWithCitations.join(&apos;\n&apos;);
    
    console.log(`[SECTION FORMATTED]`, `Section formatted with ${bulletPointsWithCitations.length} bullet points`);
    return formatted;
  }

  /**
   * Create bullet points from content
   */
  private static createBulletPoints(content: string): string[] {
    console.log(&apos;[BULLET CREATION]&apos;, `Creating bullet points from ${content.length} characters of content`);
    
    // Split by sentences or logical clauses
    const sentences = this.splitIntoSentences(content);
    console.log(&apos;[SENTENCE SPLIT]&apos;, `Found ${sentences.length} sentences:`, sentences.map((s, i) =&gt; `${i + 1}. &quot;${s.substring(0, 50)}${s.length &gt; 50 ? &apos;...&apos; : &apos;&apos;}&quot;`));
    
    const bulletPoints: string[] = [];
    let currentPoint = &apos;&apos;;
    
    for (let i = 0; i &lt; sentences.length; i++) {
      const sentence = sentences[i];
      const trimmed = sentence.trim();
      if (trimmed.length === 0) {
        console.log(`[SENTENCE ${i}]`, &apos;Empty sentence, skipping&apos;);
        continue;
      }
      
      console.log(`[SENTENCE ${i}]`, `Processing: &quot;${trimmed}&quot;`);
      
      // If adding this sentence makes the point too long, start a new point
      if (currentPoint &amp;&amp; currentPoint.length + trimmed.length &gt; 200) {
        bulletPoints.push(currentPoint.trim());
        console.log(`[BULLET CREATED]`, `Bullet ${bulletPoints.length}: &quot;${currentPoint.trim()}&quot;`);
        currentPoint = trimmed;
      } else {
        currentPoint += (currentPoint ? &apos; &apos; : &apos;&apos;) + trimmed;
        console.log(`[BULLET BUILDING]`, `Current point length: ${currentPoint.length}`);
      }
    }
    
    if (currentPoint.trim()) {
      bulletPoints.push(currentPoint.trim());
      console.log(`[FINAL BULLET]`, `Final bullet: &quot;${currentPoint.trim()}&quot;`);
    }
    
    console.log(&apos;[BULLET CREATION COMPLETE]&apos;, `Created ${bulletPoints.length} bullet points`);
    return bulletPoints;
  }

  /**
   * Split text into sentences
   */
  private static splitIntoSentences(text: string): string[] {
    // Split by sentence-ending punctuation but preserve newlines for list formatting
    return text.split(/(?&lt;=[.!?])\s+/).filter(s =&gt; s.trim().length &gt; 0);
  }

  /**
   * Get citations that belong to a specific bullet point
   */
  private static getCitationsForPoint(
    point: string, 
    originalContent: string, 
    citations: Array&lt;{index: number, position: number}&gt;
  ): number[] {
    // Find citations that appear within the range of this point in original content
    const pointStart = originalContent.indexOf(point);
    const pointEnd = pointStart + point.length;
    
    return citations
      .filter(cit =&gt; cit.position &gt;= pointStart &amp;&amp; cit.position &lt; pointEnd)
      .map(cit =&gt; cit.index)
      .filter((index, pos, arr) =&gt; arr.indexOf(index) === pos); // Remove duplicates
  }
}</file><file path="src/services/rag/vectorSearch.ts">import type { EmbeddingChunk, VectorSearchResult } from &apos;@/types/embedding&apos;;
import type { PageGroup } from &apos;@/types/citation&apos;;
import { getIndexedDBServices } from &apos;../indexedDB&apos;;
import { cosineSimilarity, calculateVectorNorm } from &apos;@/utils/vectorUtils&apos;;

export class VectorSearchService {
  private embeddingService = getIndexedDBServices().embeddingService;

  async searchSimilar(
    queryEmbedding: Float32Array,
    sessionId: string,
    options: {
      maxResults?: number;
      similarityThreshold?: number;
      documentIds?: string[];
      userId?: string;
    } = {}
  ): Promise&lt;VectorSearchResult[]&gt; {
    try {
      const {
        maxResults = 8,
        similarityThreshold = 0.7,
        documentIds
      } = options;

      // Get embeddings for enabled documents only
      let embeddings: EmbeddingChunk[];
      
      if (documentIds &amp;&amp; documentIds.length &gt; 0) {
        embeddings = await this.getEmbeddingsByDocumentIds(documentIds);
      } else {
        embeddings = await this.embeddingService.getEnabledEmbeddingsBySession(sessionId, options.userId);
      }

      // Calculate similarities using optimized cosine similarity
      const results: VectorSearchResult[] = [];
      
      for (const embedding of embeddings) {
        // Use pre-computed norm if available
        const embeddingNorm = embedding.metadata?.embeddingNorm || calculateVectorNorm(embedding.embedding);
        const similarity = cosineSimilarity(queryEmbedding, embedding.embedding);
        
        if (similarity &gt;= similarityThreshold) {
          // Get document info - pass userId for ownership verification
          const document = await this.getDocumentInfo(embedding.documentId, options.userId);
          
          if (document) {
            results.push({
              chunk: embedding,
              similarity,
              document: {
                id: document.id,
                title: document.title || document.filename,
                fileName: document.filename,
              },
            });
          }
        }
      }

      // Apply page deduplication
      const deduplicatedResults = this.deduplicateByPage(results);

      // Sort by similarity (descending) and limit results
      return deduplicatedResults
        .sort((a, b) =&gt; b.similarity - a.similarity)
        .slice(0, maxResults);
    } catch (error) {
      console.error(&apos;Error in vector search:&apos;, error);
      throw new Error(&apos;Failed to perform vector search&apos;);
    }
  }

  private async getEmbeddingsByDocumentIds(documentIds: string[]): Promise&lt;EmbeddingChunk[]&gt; {
    const embeddings: EmbeddingChunk[] = [];
    
    for (const documentId of documentIds) {
      const documentEmbeddings = await this.embeddingService.getEmbeddingsByDocument(documentId);
      embeddings.push(...documentEmbeddings);
    }
    
    return embeddings;
  }

  private async getDocumentInfo(documentId: string, userId?: string) {
    const documentService = getIndexedDBServices().documentService;
    return await documentService.getDocument(documentId, userId);
  }

  /**
   * Combine chunks from the same page instead of discarding them
   * This ensures all information from a page is available to the LLM
   * while maintaining clean citation display
   */
  private deduplicateByPage(results: VectorSearchResult[]): VectorSearchResult[] {
    return this.combineChunksByPage(results);
  }

  /**
   * Combine chunks from the same page while preserving all information
   * Creates a single combined chunk with all content from the same page
   */
  private combineChunksByPage(results: VectorSearchResult[]): VectorSearchResult[] {
    console.log(&apos;\n=== CHUNK COMBINATION DEBUG START ===&apos;);
    console.log(&apos;[COMBINE INPUT]&apos;, `Processing ${results.length} chunks for combination`);
    
    const pageMap = new Map&lt;string, VectorSearchResult[]&gt;();

    // Group chunks by document and page
    for (const result of results) {
      const pageNumber = this.getEffectivePageNumber(result);
      const pageKey = `${result.document.id}_${pageNumber || &apos;unknown&apos;}`;
      
      console.log(&apos;[CHUNK ANALYSIS]&apos;, {
        chunkId: result.chunk.id,
        documentId: result.document.id,
        documentTitle: result.document.title,
        similarity: result.similarity,
        pageField: result.chunk.page,
        metadataPageNumber: result.chunk.metadata?.pageNumber,
        effectivePageNumber: pageNumber,
        pageKey,
        contentPreview: result.chunk.content.substring(0, 100) + &apos;...&apos;
      });
      
      if (!pageMap.has(pageKey)) {
        pageMap.set(pageKey, []);
      }
      pageMap.get(pageKey)!.push(result);
    }

    console.log(&apos;[PAGE GROUPING]&apos;, `Created ${pageMap.size} page groups:`);
    for (const [pageKey, chunks] of pageMap) {
      console.log(&apos;[PAGE GROUP]&apos;, {
        pageKey,
        chunkCount: chunks.length,
        chunks: chunks.map(c =&gt; ({
          id: c.chunk.id,
          similarity: c.similarity,
          page: this.getEffectivePageNumber(c),
          allPageNumbers: this.getAllPageNumbers(c)
        }))
      });
    }

    // Combine chunks for each page
    const combinedResults: VectorSearchResult[] = [];
    for (const [pageKey, chunks] of pageMap) {
      if (chunks.length === 1) {
        console.log(&apos;[SINGLE CHUNK]&apos;, `No combination needed for ${pageKey}`);
        combinedResults.push(chunks[0]);
      } else {
        console.log(&apos;[MULTI CHUNK]&apos;, `Combining ${chunks.length} chunks for ${pageKey}`);
        combinedResults.push(this.createCombinedChunk(chunks));
      }
    }

    console.log(&apos;[COMBINATION RESULT]&apos;, `Combined into ${combinedResults.length} chunks`);
    for (const result of combinedResults) {
      console.log(&apos;[FINAL CHUNK]&apos;, {
        id: result.chunk.id,
        documentTitle: result.document.title,
        similarity: result.similarity,
        finalPage: this.getEffectivePageNumber(result),
        allPages: this.getAllPageNumbers(result),
        isCombined: result.chunk.metadata?.isCombined,
        originalChunkCount: result.chunk.metadata?.originalChunkCount,
        pageNumbers: result.chunk.metadata?.pageNumbers,
        contentPreview: result.chunk.content.substring(0, 100) + &apos;...&apos;
      });
    }
    console.log(&apos;=== CHUNK COMBINATION DEBUG END ===\n&apos;);

    return combinedResults;
  }

  /**
   * Create a combined chunk from multiple chunks on the same page
   * Preserves the highest similarity score and combines all content
   */
  private createCombinedChunk(chunks: VectorSearchResult[]): VectorSearchResult {
    console.log(&apos;\n=== CREATE COMBINED CHUNK DEBUG START ===&apos;);
    console.log(&apos;[COMBINE INPUT]&apos;, `Combining ${chunks.length} chunks`);
    
    // Sort by similarity to find the highest scoring chunk
    const sortedChunks = [...chunks].sort((a, b) =&gt; b.similarity - a.similarity);
    const highestScoringChunk = sortedChunks[0];
    
    console.log(&apos;[SIMILARITY RANKING]&apos;, &apos;Chunks sorted by similarity:&apos;);
    sortedChunks.forEach((chunk, index) =&gt; {
      console.log(`[RANK ${index + 1}]`, {
        chunkId: chunk.chunk.id,
        similarity: chunk.similarity,
        pageField: chunk.chunk.page,
        metadataPageNumber: chunk.chunk.metadata?.pageNumber,
        effectivePage: this.getEffectivePageNumber(chunk),
        contentPreview: chunk.chunk.content.substring(0, 80) + &apos;...&apos;
      });
    });
    
    console.log(&apos;[HIGHEST SCORING]&apos;, {
      chunkId: highestScoringChunk.chunk.id,
      similarity: highestScoringChunk.similarity,
      pageField: highestScoringChunk.chunk.page,
      metadataPageNumber: highestScoringChunk.chunk.metadata?.pageNumber,
      effectivePage: this.getEffectivePageNumber(highestScoringChunk),
      selectedAsBase: true
    });
    
    // Collect all unique page numbers from the chunks
    const allPageNumbers = new Set&lt;number&gt;();
    chunks.forEach(chunk =&gt; {
      const effectivePage = this.getEffectivePageNumber(chunk);
      if (effectivePage !== undefined) {
        allPageNumbers.add(effectivePage);
      }
    });
    
    const sortedPageNumbers = Array.from(allPageNumbers).sort((a, b) =&gt; a - b);
    console.log(&apos;[PAGE COLLECTION]&apos;, {
      allUniquePages: sortedPageNumbers,
      pageCount: sortedPageNumbers.length,
      pageRange: sortedPageNumbers.length &gt; 1 ? `${sortedPageNumbers[0]}-${sortedPageNumbers[sortedPageNumbers.length - 1]}` : `${sortedPageNumbers[0]}`
    });
    
    // Combine content from all chunks with clear separators
    const combinedContent = chunks
      .sort((a, b) =&gt; a.chunk.chunkIndex - b.chunk.chunkIndex) // Maintain original order
      .map(chunk =&gt; chunk.chunk.content)
      .join(&apos;\n---\n&apos;);
    
    // Create combined chunk IDs for reference
    const combinedChunkIds = chunks.map(c =&gt; c.chunk.id);
    
    // Create a new combined chunk with all page numbers preserved
    const combinedChunk: EmbeddingChunk = {
      ...highestScoringChunk.chunk,
      id: `combined_${highestScoringChunk.chunk.id}`, // New ID for combined chunk
      content: combinedContent,
      metadata: {
        ...highestScoringChunk.chunk.metadata,
        pageNumbers: sortedPageNumbers, // Store all page numbers
        combinedChunkIds, // Store original chunk IDs for reference
        isCombined: true,
        originalChunkCount: chunks.length,
      },
    };

    console.log(&apos;[COMBINED CHUNK CREATED]&apos;, {
      newId: combinedChunk.id,
      inheritedPage: combinedChunk.page,
      inheritedMetadataPage: combinedChunk.metadata?.pageNumber,
      storedPageNumbers: combinedChunk.metadata?.pageNumbers,
      isCombined: combinedChunk.metadata?.isCombined,
      originalChunkCount: combinedChunk.metadata?.originalChunkCount,
      allOriginalPages: chunks.map(c =&gt; this.getEffectivePageNumber(c)),
      uniquePagesPreserved: sortedPageNumbers,
      contentLength: combinedContent.length
    });
    console.log(&apos;=== CREATE COMBINED CHUNK DEBUG END ===\n&apos;);

    // Return the combined result with highest similarity
    return {
      chunk: combinedChunk,
      similarity: highestScoringChunk.similarity,
      document: highestScoringChunk.document,
    };
  }

  /**
   * Get effective page number with proper priority handling
   * For combined chunks, returns the first page number from the pageNumbers array
   * Priority: 1. metadata.pageNumbers (for combined chunks), 2. chunk.page (direct field), 3. metadata.pageNumber, 4. content extraction
   */
  private getEffectivePageNumber(result: VectorSearchResult): number | undefined {
    // Priority 1: For combined chunks, use the first page number from pageNumbers array
    if (result.chunk.metadata?.pageNumbers &amp;&amp; result.chunk.metadata.pageNumbers.length &gt; 0) {
      console.log(&apos;[EFFECTIVE PAGE]&apos;, `Using first page from pageNumbers array: ${result.chunk.metadata.pageNumbers[0]} for combined chunk`);
      return result.chunk.metadata.pageNumbers[0];
    }
    
    // Priority 2: Direct page field from chunk
    if (result.chunk.page &amp;&amp; result.chunk.page &gt; 0) {
      return result.chunk.page;
    }
    
    // Priority 3: Metadata pageNumber
    if (result.chunk.metadata?.pageNumber &amp;&amp; result.chunk.metadata.pageNumber &gt; 0) {
      return result.chunk.metadata.pageNumber;
    }
    
    // Priority 4: Try to extract from content (similar to citation service)
    const content = result.chunk.content;
    const pagePatterns = [
      /page\s+(\d+)/i,
      /p\.?\s*(\d+)/i,
      /Á¨¨(\d+)È°µ/,
      /page\s+(\d+)\s+of/i,
    ];

    for (const pattern of pagePatterns) {
      const match = content.match(pattern);
      if (match &amp;&amp; match[1]) {
        const extractedPage = parseInt(match[1], 10);
        if (extractedPage &gt; 0) {
          return extractedPage;
        }
      }
    }
    
    return undefined;
  }

  /**
   * Get all page numbers from a chunk (for combined chunks)
   * Returns an array of page numbers or undefined if no pages found
   */
  private getAllPageNumbers(result: VectorSearchResult): number[] | undefined {
    // For combined chunks, return the pageNumbers array
    if (result.chunk.metadata?.pageNumbers &amp;&amp; result.chunk.metadata.pageNumbers.length &gt; 0) {
      return result.chunk.metadata.pageNumbers;
    }
    
    // For single chunks, try to get the effective page number
    const effectivePage = this.getEffectivePageNumber(result);
    if (effectivePage !== undefined) {
      return [effectivePage];
    }
    
    return undefined;
  }

  async searchHybrid(
    queryEmbedding: Float32Array,
    sessionId: string,
    queryText: string,
    options: {
      maxResults?: number;
      similarityThreshold?: number;
      textWeight?: number;
      vectorWeight?: number;
      userId?: string;
    } = {}
  ): Promise&lt;VectorSearchResult[]&gt; {
    try {
      const {
        maxResults = 8,
        similarityThreshold = 0.7,
        textWeight = 0.3,
        vectorWeight = 0.7
      } = options;

      // Get vector search results
      const vectorResults = await this.searchSimilar(queryEmbedding, sessionId, {
        maxResults: maxResults * 2, // Get more to allow for text search
        similarityThreshold: similarityThreshold * 0.8, // Lower threshold for hybrid
      });

      // Get text search results (simple keyword matching for now)
      const textResults = await this.textSearch(queryText, sessionId, maxResults * 2, options.userId);

      // Combine and score results
      const combinedResults = new Map&lt;string, VectorSearchResult&gt;();

      // Add vector results
      vectorResults.forEach(result =&gt; {
        const key = result.chunk.id;
        combinedResults.set(key, {
          ...result,
          similarity: result.similarity * vectorWeight,
        });
      });

      // Add text results
      textResults.forEach(result =&gt; {
        const key = result.chunk.id;
        const existing = combinedResults.get(key);
        
        if (existing) {
          // Combine scores
          existing.similarity = Math.min(1, existing.similarity + result.similarity * textWeight);
        } else {
          combinedResults.set(key, {
            ...result,
            similarity: result.similarity * textWeight,
          });
        }
      });

      // Sort and return top results
      return Array.from(combinedResults.values())
        .sort((a, b) =&gt; b.similarity - a.similarity)
        .slice(0, maxResults);
    } catch (error) {
      console.error(&apos;Error in hybrid search:&apos;, error);
      throw new Error(&apos;Failed to perform hybrid search&apos;);
    }
  }

  private async textSearch(
    query: string,
    sessionId: string,
    maxResults: number,
    userId?: string
  ): Promise&lt;VectorSearchResult[]&gt; {
    try {
      const embeddings = await this.embeddingService.getEnabledEmbeddingsBySession(sessionId, userId);
      const queryLower = query.toLowerCase();
      const results: VectorSearchResult[] = [];

      for (const embedding of embeddings) {
        const contentLower = embedding.content.toLowerCase();
        
        // Advanced text scoring
        const score = this.calculateTextScore(queryLower, contentLower);

        if (score &gt; 0) {
          // Get document info - pass userId for ownership verification
          const document = await this.getDocumentInfo(embedding.documentId, userId);
          
          if (document) {
            results.push({
              chunk: embedding,
              similarity: score,
              document: {
                id: document.id,
                title: document.title || document.filename,
                fileName: document.filename,
              },
            });
          }
        }
      }

      return results
        .sort((a, b) =&gt; b.similarity - a.similarity)
        .slice(0, maxResults);
    } catch (error) {
      console.error(&apos;Error in text search:&apos;, error);
      return [];
    }
  }

  /**
   * Calculate advanced text similarity score
   */
  private calculateTextScore(query: string, content: string): number {
    const queryWords = query.split(/\s+/).filter(word =&gt; word.length &gt; 2); // Filter out very short words
    const contentWords = content.split(/\s+/);
    
    let score = 0;
    let exactPhraseMatches = 0;
    let partialMatches = 0;
    let wordProximityScore = 0;

    // Exact phrase matching (highest weight)
    if (content.includes(query)) {
      exactPhraseMatches += 1;
      score += 2.0;
    }

    // Individual word matching with proximity consideration
    for (let i = 0; i &lt; queryWords.length; i++) {
      const queryWord = queryWords[i];
      
      // Find all positions of this word in content
      const positions: number[] = [];
      for (let j = 0; j &lt; contentWords.length; j++) {
        if (contentWords[j].includes(queryWord)) {
          positions.push(j);
        }
      }

      if (positions.length &gt; 0) {
        partialMatches += 1;
        score += 0.5;

        // Bonus for word appearing multiple times
        if (positions.length &gt; 1) {
          score += 0.2 * Math.min(positions.length - 1, 3);
        }

        // Proximity bonus for consecutive words
        if (i &lt; queryWords.length - 1) {
          const nextQueryWord = queryWords[i + 1];
          for (const pos of positions) {
            if (pos + 1 &lt; contentWords.length &amp;&amp;
                contentWords[pos + 1].includes(nextQueryWord)) {
              wordProximityScore += 0.3;
            }
          }
        }
      }
    }

    // Normalize scores
    const wordMatchRatio = partialMatches / queryWords.length;
    const normalizedScore = Math.min(1.0, score / queryWords.length);

    // Combine different scoring factors
    return Math.min(1.0, normalizedScore * 0.6 + wordProximityScore * 0.3 + wordMatchRatio * 0.1);
  }

  /**
   * Enhanced hybrid search with dynamic weighting
   */
  async searchHybridEnhanced(
    queryEmbedding: Float32Array,
    sessionId: string,
    queryText: string,
    options: {
      maxResults?: number;
      similarityThreshold?: number;
      textWeight?: number;
      vectorWeight?: number;
      useDynamicWeighting?: boolean;
      userId?: string;
    } = {}
  ): Promise&lt;VectorSearchResult[]&gt; {
    try {
      const {
        maxResults = 8,
        similarityThreshold = 0.7,
        textWeight = 0.3,
        vectorWeight = 0.7,
        useDynamicWeighting = true
      } = options;

      // Get vector search results
      const vectorResults = await this.searchSimilar(queryEmbedding, sessionId, {
        maxResults: maxResults * 2,
        similarityThreshold: similarityThreshold * 0.8,
      });

      // Get text search results
      const textResults = await this.textSearch(queryText, sessionId, maxResults * 2, options.userId);

      // Dynamic weighting based on query characteristics
      let finalTextWeight = textWeight;
      let finalVectorWeight = vectorWeight;

      if (useDynamicWeighting) {
        const queryAnalysis = this.analyzeQuery(queryText);
        
        // Adjust weights based on query type
        if (queryAnalysis.isSpecificQuery) {
          finalVectorWeight = Math.min(0.9, vectorWeight + 0.2);
          finalTextWeight = Math.max(0.1, textWeight - 0.2);
        } else if (queryAnalysis.isBroadQuery) {
          finalTextWeight = Math.min(0.6, textWeight + 0.2);
          finalVectorWeight = Math.max(0.4, vectorWeight - 0.2);
        }
      }

      // Combine and score results using reciprocal rank fusion
      const combinedResults = this.reciprocalRankFusion(
        vectorResults,
        textResults,
        finalVectorWeight,
        finalTextWeight
      );

      return combinedResults.slice(0, maxResults);
    } catch (error) {
      console.error(&apos;Error in enhanced hybrid search:&apos;, error);
      throw new Error(&apos;Failed to perform enhanced hybrid search&apos;);
    }
  }

  /**
   * Analyze query characteristics for dynamic weighting
   */
  private analyzeQuery(query: string): {
    isSpecificQuery: boolean;
    isBroadQuery: boolean;
    wordCount: number;
    hasQuotes: boolean;
  } {
    const words = query.split(/\s+/).filter(w =&gt; w.length &gt; 0);
    const wordCount = words.length;
    const hasQuotes = query.includes(&apos;&quot;&apos;) || query.includes(&quot;&apos;&quot;);
    
    // Specific query indicators
    const specificIndicators = [
      /\b\d+\b/, // Numbers
      /\b[A-Z]{2,}\b/, // Acronyms
      /\b\w*@\w*\.\w+\b/, // Emails
      /\bhttps?:\/\/\S+\b/, // URLs
    ];
    
    const isSpecificQuery = hasQuotes ||
      wordCount &lt;= 3 ||
      specificIndicators.some(pattern =&gt; pattern.test(query));

    // Broad query indicators
    const broadWords = [&apos;what&apos;, &apos;how&apos;, &apos;why&apos;, &apos;when&apos;, &apos;where&apos;, &apos;explain&apos;, &apos;describe&apos;, &apos;tell me&apos;];
    const isBroadQuery = wordCount &gt; 5 ||
      broadWords.some(word =&gt; query.toLowerCase().includes(word));

    return {
      isSpecificQuery,
      isBroadQuery,
      wordCount,
      hasQuotes,
    };
  }

  /**
   * Reciprocal Rank Fusion for combining search results
   */
  private reciprocalRankFusion(
    vectorResults: VectorSearchResult[],
    textResults: VectorSearchResult[],
    vectorWeight: number,
    textWeight: number
  ): VectorSearchResult[] {
    const k = 60; // Fusion parameter (typically 60)
    const resultScores = new Map&lt;string, { result: VectorSearchResult; score: number }&gt;();

    // Process vector results
    vectorResults.forEach((result, index) =&gt; {
      const key = result.chunk.id;
      const rrScore = 1 / (k + index + 1);
      const existingScore = resultScores.get(key);
      
      if (existingScore) {
        existingScore.score += rrScore * vectorWeight;
      } else {
        resultScores.set(key, {
          result: { ...result, similarity: result.similarity * vectorWeight },
          score: rrScore * vectorWeight,
        });
      }
    });

    // Process text results
    textResults.forEach((result, index) =&gt; {
      const key = result.chunk.id;
      const rrScore = 1 / (k + index + 1);
      const existingScore = resultScores.get(key);
      
      if (existingScore) {
        existingScore.score += rrScore * textWeight;
        // Update the result with combined similarity
        existingScore.result.similarity = Math.min(1,
          existingScore.result.similarity + result.similarity * textWeight);
      } else {
        resultScores.set(key, {
          result: { ...result, similarity: result.similarity * textWeight },
          score: rrScore * textWeight,
        });
      }
    });

    // Sort by combined score and return results
    return Array.from(resultScores.values())
      .sort((a, b) =&gt; b.score - a.score)
      .map(item =&gt; item.result);
  }

  async findSimilarChunks(
    targetChunk: EmbeddingChunk,
    maxResults: number = 8,
    userId?: string
  ): Promise&lt;VectorSearchResult[]&gt; {
    try {
      // First check if the document is enabled before finding similar chunks
      const document = await this.getDocumentInfo(targetChunk.documentId, userId);
      if (!document || !document.enabled) {
        return [];
      }
      
      const embeddings = await this.embeddingService.getEmbeddingsByDocument(targetChunk.documentId);
      
      const results: VectorSearchResult[] = [];
      
      for (const embedding of embeddings) {
        if (embedding.id === targetChunk.id) {
          continue; // Skip the target chunk itself
        }
        
        const similarity = cosineSimilarity(targetChunk.embedding, embedding.embedding);
        
        if (similarity &gt; 0.5) { // Threshold for similarity
          const document = await this.getDocumentInfo(embedding.documentId, userId);
          
          if (document) {
            results.push({
              chunk: embedding,
              similarity,
              document: {
                id: document.id,
                title: document.title || document.filename,
                fileName: document.filename,
              },
            });
          }
        }
      }

      return results
        .sort((a, b) =&gt; b.similarity - a.similarity)
        .slice(0, maxResults);
    } catch (error) {
      console.error(&apos;Error finding similar chunks:&apos;, error);
      throw new Error(&apos;Failed to find similar chunks&apos;);
    }
  }

  /**
   * NEW: Search for similar chunks and group by page for simplified citation system
   * Returns page groups instead of individual chunks
   */
  async searchSimilarGroupedByPage(
    queryEmbedding: Float32Array,
    sessionId: string,
    options: {
      maxResults?: number;
      similarityThreshold?: number;
      documentIds?: string[];
      userId?: string;
    } = {}
  ): Promise&lt;PageGroup[]&gt; {
    try {
      const {
        maxResults = 8, // Reduced from 10 to 8 to reduce noise
        similarityThreshold = 0.7,
        documentIds
      } = options;

      console.log(&apos;\n=== SIMPLIFIED VECTOR SEARCH START ===&apos;);
      console.log(&apos;[SEARCH OPTIONS]&apos;, { maxResults, similarityThreshold, documentIds });

      // Get regular search results first
      const searchResults = await this.searchSimilar(queryEmbedding, sessionId, {
        maxResults,
        similarityThreshold,
        documentIds
      });

      console.log(&apos;[SEARCH RESULTS]&apos;, `Found ${searchResults.length} individual chunks`);

      // Group by page
      const pageGroups = this.groupResultsByPage(searchResults);
      
      console.log(&apos;[PAGE GROUPS]&apos;, `Created ${pageGroups.length} page groups`);
      pageGroups.forEach((group, index) =&gt; {
        console.log(`[PAGE GROUP ${index + 1}]`, {
          document: group.documentTitle,
          page: group.page,
          chunkCount: group.chunks.length,
          highestSimilarity: Math.max(...group.chunks.map(c =&gt; c.similarity))
        });
      });
      console.log(&apos;=== SIMPLIFIED VECTOR SEARCH END ===\n&apos;);

      return pageGroups;
    } catch (error) {
      console.error(&apos;Error in simplified vector search:&apos;, error);
      throw new Error(&apos;Failed to perform simplified vector search&apos;);
    }
  }

  /**
   * Group search results by page for simplified citation system
   */
  private groupResultsByPage(results: VectorSearchResult[]): PageGroup[] {
    const pageMap = new Map&lt;string, PageGroup&gt;();

    for (const result of results) {
      const pageNumber = this.getEffectivePageNumber(result);
      
      if (pageNumber !== undefined) {
        const pageKey = `${result.document.id}_${pageNumber}`;
        
        if (!pageMap.has(pageKey)) {
          pageMap.set(pageKey, {
            documentId: result.document.id,
            documentTitle: result.document.title || result.document.fileName,
            page: pageNumber,
            chunks: []
          });
        }
        
        const pageGroup = pageMap.get(pageKey)!;
        pageGroup.chunks.push({
          id: result.chunk.id,
          content: result.chunk.content,
          similarity: result.similarity
        });
      }
    }
    
    // Sort page groups by highest similarity and then by document/page
    return Array.from(pageMap.values())
      .sort((a, b) =&gt; {
        const maxSimA = Math.max(...a.chunks.map(c =&gt; c.similarity));
        const maxSimB = Math.max(...b.chunks.map(c =&gt; c.similarity));
        
        if (maxSimB !== maxSimA) {
          return maxSimB - maxSimA; // Higher similarity first
        }
        
        // Then sort by document title and page number
        const docCompare = a.documentTitle.localeCompare(b.documentTitle);
        if (docCompare !== 0) {
          return docCompare;
        }
        
        return a.page - b.page;
      });
  }

  /**
   * Convert page groups back to vector search results for compatibility
   * This maintains backward compatibility with existing code
   */
  pageGroupsToVectorResults(pageGroups: PageGroup[]): VectorSearchResult[] {
    const results: VectorSearchResult[] = [];
    
    for (const pageGroup of pageGroups) {
      // For each page group, create a combined result
      // Use the highest scoring chunk as the base
      const sortedChunks = [...pageGroup.chunks].sort((a, b) =&gt; b.similarity - a.similarity);
      const highestScoringChunk = sortedChunks[0];
      
      // Create a mock VectorSearchResult for the page group
      // This is a simplified representation for compatibility
      const combinedResult: VectorSearchResult = {
        chunk: {
          id: `page_${pageGroup.documentId}_${pageGroup.page}`,
          documentId: pageGroup.documentId,
          sessionId: &apos;&apos;, // Will be filled by caller if needed
          chunkIndex: 0,
          content: pageGroup.chunks
            .sort((a, b) =&gt; a.content.localeCompare(b.content))
            .map(chunk =&gt; chunk.content)
            .join(&apos;\n---\n&apos;),
          embedding: new Float32Array(0), // Empty embedding since this is combined
          tokenCount: 0,
          embeddingNorm: 0,
          metadata: {
            isCombined: true,
            originalChunkCount: pageGroup.chunks.length,
            combinedChunkIds: pageGroup.chunks.map(c =&gt; c.id),
            pageNumber: pageGroup.page,
            pageNumbers: [pageGroup.page],
            chunkIndex: 0,
            startPosition: 0,
            endPosition: 0,
            tokenCount: 0
          },
          createdAt: new Date()
        },
        similarity: highestScoringChunk.similarity,
        document: {
          id: pageGroup.documentId,
          title: pageGroup.documentTitle,
          fileName: pageGroup.documentTitle
        }
      };
      
      results.push(combinedResult);
    }
    
    return results;
  }
}

// Singleton instance
export const vectorSearchService = new VectorSearchService();</file><file path="src/store/documentStore.ts">import { create } from &apos;zustand&apos;;
import { devtools, persist } from &apos;zustand/middleware&apos;;
import type { DocumentStore } from &apos;./types&apos;;
import { Document, DocumentUpdate, DocumentProgress } from &apos;@/types/document&apos;;
import { getIndexedDBServices } from &apos;../services/indexedDB&apos;;
import { userIdLogger } from &apos;../utils/userIdDebugLogger&apos;;

// Helper function to get services (client-side only)
const getDocumentService = () =&gt; {
  if (typeof window !== &apos;undefined&apos;) {
    const services = getIndexedDBServices();
    return services.documentService;
  }
  return null;
};

export const useDocumentStore = create&lt;DocumentStore&gt;()(
  devtools(
    persist(
      (set, get) =&gt; ({
        // State
        documents: [],
        progressMap: {},
        isUploading: false,
        error: null,
        userId: null,

        // Actions
        setUserId: (userId: string | null) =&gt; {
          userIdLogger.logStoreUpdate(&apos;DocumentStore&apos;, userId, &apos;setUserId&apos;);
          set({ userId });
        },

        clearDocuments: () =&gt; {
          userIdLogger.logStoreUpdate(&apos;DocumentStore&apos;, null, &apos;clearDocuments&apos;);
          set({ documents: [], progressMap: {}, error: null, userId: null });
        },

        loadDocuments: async (sessionId: string) =&gt; {
          // Only run on client side
          if (typeof window === &apos;undefined&apos;) {
            console.warn(&apos;[DOCUMENT STORE] Skipping loadDocuments during SSR&apos;);
            return;
          }
          
          const { userId } = get();
          
          try {
            console.log(&apos;üîç DOCUMENT STORE DEBUG: Starting loadDocuments for session:&apos;, sessionId);
            const documentService = getDocumentService();
            if (!documentService) {
              console.error(&apos;üîç DOCUMENT STORE DEBUG: Document service not available&apos;);
              throw new Error(&apos;Document service not available&apos;);
            }

            if (!userId) {
              const errorMsg = &apos;User ID not found. Please log in.&apos;;
              console.error(&apos;üîç DOCUMENT STORE DEBUG: User ID not found&apos;);
              userIdLogger.logError(&apos;DocumentStore.loadDocuments&apos;, errorMsg, null);
              set({ error: errorMsg });
              return;
            }

            const operationId = userIdLogger.logOperationStart(&apos;DocumentStore&apos;, &apos;loadDocuments&apos;, userId);

            console.log(&apos;üîç DOCUMENT STORE DEBUG: Calling getDocumentsBySession&apos;);
            console.log(&apos;üîç DUPLICATE DEBUG: Loading documents from IndexedDB at:&apos;, new Date().toISOString());
            userIdLogger.logServiceCall(&apos;DocumentStore&apos;, &apos;documentService&apos;, &apos;getDocumentsBySession&apos;, userId);
            const documents = await documentService.getDocumentsBySession(sessionId, userId);

            console.log(&apos;üîç DOCUMENT STORE DEBUG: Documents retrieved from database:&apos;, {
              sessionId,
              count: documents.length,
              documents: documents.map(doc =&gt; ({
                id: doc.id,
                filename: doc.filename,
                enabled: doc.enabled,
                status: doc.status,
                processedAt: doc.processedAt
              }))
            });

            console.log(&apos;üîç DOCUMENT STORE DEBUG: About to update store state&apos;);
            console.log(&apos;üîç DUPLICATE DEBUG: Updating document store state at:&apos;, new Date().toISOString());
            
            userIdLogger.logOperationEnd(&apos;DocumentStore&apos;, operationId, userId);
            set({ documents });

            console.log(&apos;üîç DOCUMENT STORE DEBUG: Store state updated, verifying...&apos;);
            const currentState = get();
            console.log(&apos;üîç DUPLICATE DEBUG: Document store state updated at:&apos;, new Date().toISOString());
            console.log(&apos;üîç DOCUMENT STORE DEBUG: Current store state:&apos;, {
              documentCount: currentState.documents.length,
              documents: currentState.documents.map(doc =&gt; ({
                id: doc.id,
                filename: doc.filename,
                enabled: doc.enabled,
                status: doc.status,
                processedAt: doc.processedAt
              }))
            });

            console.log(&apos;[DOCUMENT STORE] Loaded documents:&apos;, {
              sessionId,
              count: documents.length,
              documents: documents.map(doc =&gt; ({
                id: doc.id,
                filename: doc.filename,
                enabled: doc.enabled,
                status: doc.status,
                processedAt: doc.processedAt
              }))
            });
          } catch (error) {
            userIdLogger.logError(&apos;DocumentStore.loadDocuments&apos;, error instanceof Error ? error : String(error), userId);
            console.error(&apos;üîç DOCUMENT STORE DEBUG: Failed to load documents:&apos;, error);
            console.error(&apos;[DOCUMENT STORE] Failed to load documents:&apos;, error);
            set({
              error: error instanceof Error ? error.message : &apos;Failed to load documents&apos;,
            });
          }
        },

        uploadDocuments: async (sessionId: string, files: File[]) =&gt; {
          // Only run on client side
          if (typeof window === &apos;undefined&apos;) {
            console.warn(&apos;[DOCUMENT STORE] Skipping uploadDocuments during SSR&apos;);
            throw new Error(&apos;Cannot upload documents during SSR&apos;);
          }
          
          const { userId } = get();
          if (!userId) {
            const errorMsg = &apos;User ID not found. Please log in.&apos;;
            userIdLogger.logError(&apos;DocumentStore.uploadDocuments&apos;, errorMsg, null);
            set({ error: errorMsg });
            return;
          }

          set({ isUploading: true, error: null });

          try {
            const documentService = getDocumentService();
            if (!documentService) {
              throw new Error(&apos;Document service not available&apos;);
            }

            for (const file of files) {
              // Create document entry
              const document = await documentService.createDocument({
                sessionId,
                filename: file.name,
                fileSize: file.size,
                mimeType: file.type,
              }, userId);

              // Set initial progress
              set(state =&gt; ({
                progressMap: {
                  ...state.progressMap,
                  [document.id]: {
                    status: &apos;pending&apos;,
                    progress: 0,
                  },
                },
              }));

              // TODO: Implement actual file processing
              // For now, simulate processing
              setTimeout(() =&gt; {
                set(state =&gt; ({
                  progressMap: {
                    ...state.progressMap,
                    [document.id]: {
                      status: &apos;completed&apos;,
                      progress: 100,
                    },
                  },
                }));

                // Update document status
                const docService = getDocumentService();
                if (docService) {
                  docService.updateDocument(document.id, {
                    status: &apos;completed&apos;,
                    processedAt: new Date(),
                  }, userId);
                }
              }, 2000);
            }

            set({ isUploading: false });
          } catch (error) {
            set({
              isUploading: false,
              error: error instanceof Error ? error.message : &apos;Failed to upload documents&apos;,
            });
          }
        },

        updateDocument: async (id: string, data: DocumentUpdate) =&gt; {
          try {
            const documentService = getDocumentService();
            if (!documentService) {
              throw new Error(&apos;Document service not available&apos;);
            }
            const { userId } = get();
            if (!userId) {
              const errorMsg = &apos;User ID not found. Please log in.&apos;;
              userIdLogger.logError(&apos;DocumentStore.updateDocument&apos;, errorMsg, null);
              set({ error: errorMsg });
              return;
            }
            
            const operationId = userIdLogger.logOperationStart(&apos;DocumentStore&apos;, &apos;updateDocument&apos;, userId);
            userIdLogger.logServiceCall(&apos;DocumentStore&apos;, &apos;documentService&apos;, &apos;updateDocument&apos;, userId);
            await documentService.updateDocument(id, data, userId);
            userIdLogger.logOperationEnd(&apos;DocumentStore&apos;, operationId, userId);

            set(state =&gt; ({
              documents: state.documents.map(doc =&gt;
                doc.id === id ? { ...doc, ...data } : doc
              ),
            }));
          } catch (error) {
            set({
              error: error instanceof Error ? error.message : &apos;Failed to update document&apos;,
            });
          }
        },

        toggleDocumentEnabled: async (id: string) =&gt; {
          try {
            const documentService = getDocumentService();
            if (!documentService) {
              throw new Error(&apos;Document service not available&apos;);
            }

            // Get current document to toggle its enabled status
            const currentDoc = get().documents.find(doc =&gt; doc.id === id);
            if (!currentDoc) {
              throw new Error(&apos;Document not found&apos;);
            }

            const { userId } = get();
            if (!userId) {
              const errorMsg = &apos;User ID not found. Please log in.&apos;;
              userIdLogger.logError(&apos;DocumentStore.toggleDocumentEnabled&apos;, errorMsg, null);
              set({ error: errorMsg });
              return;
            }
            
            const operationId = userIdLogger.logOperationStart(&apos;DocumentStore&apos;, &apos;toggleDocumentEnabled&apos;, userId);
            const newEnabledStatus = !currentDoc.enabled;
            userIdLogger.logServiceCall(&apos;DocumentStore&apos;, &apos;documentService&apos;, &apos;toggleDocumentEnabled&apos;, userId);
            await documentService.toggleDocumentEnabled(id, userId);
            userIdLogger.logOperationEnd(&apos;DocumentStore&apos;, operationId, userId);

            set(state =&gt; ({
              documents: state.documents.map(doc =&gt;
                doc.id === id ? { ...doc, enabled: newEnabledStatus } : doc
              ),
            }));
          } catch (error) {
            set({
              error: error instanceof Error ? error.message : &apos;Failed to toggle document enabled status&apos;,
            });
          }
        },

        deleteDocument: async (id: string) =&gt; {
          try {
            console.log(&apos;üóëÔ∏è DocumentStore: Starting deleteDocument with ID:&apos;, id);
            
            const documentService = getDocumentService();
            if (!documentService) {
              console.error(&apos;‚ùå DocumentStore: Document service not available&apos;);
              throw new Error(&apos;Document service not available&apos;);
            }

            const { userId } = get();
            if (!userId) {
              const errorMsg = &apos;User ID not found. Please log in.&apos;;
              console.error(&apos;‚ùå DocumentStore: User ID not found&apos;);
              userIdLogger.logError(&apos;DocumentStore.deleteDocument&apos;, errorMsg, null);
              set({ error: errorMsg });
              return;
            }
            
            const operationId = userIdLogger.logOperationStart(&apos;DocumentStore&apos;, &apos;deleteDocument&apos;, userId);
            console.log(&apos;üóëÔ∏è DocumentStore: About to call documentService.deleteDocument&apos;);
            
            // First, perform the IndexedDB deletion
            userIdLogger.logServiceCall(&apos;DocumentStore&apos;, &apos;documentService&apos;, &apos;deleteDocument&apos;, userId);
            await documentService.deleteDocument(id, userId);
            console.log(&apos;‚úÖ DocumentStore: Successfully deleted document from IndexedDB:&apos;, id);
            userIdLogger.logOperationEnd(&apos;DocumentStore&apos;, operationId, userId);

            // Update the state after successful IndexedDB deletion
            console.log(&apos;üóëÔ∏è DocumentStore: Updating store state to remove document&apos;);
            set(state =&gt; {
              const newProgressMap = { ...state.progressMap };
              delete newProgressMap[id];
              return {
                documents: state.documents.filter(doc =&gt; doc.id !== id),
                progressMap: newProgressMap
              };
            });
            console.log(&apos;‚úÖ DocumentStore: Document deletion process completed successfully&apos;);
          } catch (error) {
            console.error(&apos;‚ùå DocumentStore: Failed to delete document:&apos;, {
              id,
              error: error instanceof Error ? error.message : error,
              stack: error instanceof Error ? error.stack : undefined
            });
            // Set error state to be handled by UI components
            const errorMessage = error instanceof Error ? error.message : &apos;Failed to delete document&apos;;
            set({ error: errorMessage });
            // Re-throw the error so the calling component can handle it
            throw error;
          }
        },

        setProgress: (documentId: string, progress: DocumentProgress) =&gt; {
          set(state =&gt; ({
            progressMap: {
              ...state.progressMap,
              [documentId]: progress,
            },
          }));
        },

        clearProgress: (documentId: string) =&gt; {
          set(state =&gt; {
            const newProgressMap = { ...state.progressMap };
            delete newProgressMap[documentId];
            return { progressMap: newProgressMap };
          });
        },

        setUploading: (isUploading: boolean) =&gt; {
          set({ isUploading });
        },

        setError: (error: string | null) =&gt; {
          set({ error });
        },
      }),
      {
        name: &apos;document-store&apos;,
        partialize: (state) =&gt; ({
          documents: state.documents,
          userId: state.userId,
        }),
      }
    )
  )
);</file><file path="src/store/types.ts">import type { Session, SessionCreate, SessionUpdate } from &apos;@/types&apos;;
import type { Message, ChatStreamEvent } from &apos;@/types&apos;;
import type { Document, DocumentUpdate, DocumentProgress } from &apos;@/types&apos;;
import type { AppSettings, SettingsUpdate } from &apos;@/types&apos;;

export interface SessionStore {
  // State
  sessions: Session[];
  currentSession: Session | null;
  currentSessionId: string | null;
  isLoading: boolean;
  error: string | null;
  userId: string | null;

  // Actions
  loadSessions: (userId: string) =&gt; Promise&lt;void&gt;;
  createSession: (data: SessionCreate) =&gt; Promise&lt;Session&gt;;
  updateSession: (id: string, data: SessionUpdate) =&gt; Promise&lt;void&gt;;
  deleteSession: (id: string) =&gt; Promise&lt;void&gt;;
  setCurrentSession: (session: Session | null) =&gt; void;
  setCurrentSessionId: (id: string | null) =&gt; Promise&lt;void&gt;;
  setError: (error: string | null) =&gt; void;
  setUserId: (userId: string | null) =&gt; void;
  clearSessions: () =&gt; void;
}

export interface ChatStore {
  // State
  messages: Message[];
  isStreaming: boolean;
  streamingContent: string;
  streamingCitations: any[];
  error: string | null;
  isLoading: boolean;
  isReadingSources: boolean;
  progressPercentage: number;
  currentProgressStep: string;

  // Actions
  loadMessages: (sessionId: string) =&gt; Promise&lt;void&gt;;
  sendMessage: (sessionId: string, content: string) =&gt; Promise&lt;void&gt;;
  clearHistory: (sessionId: string) =&gt; Promise&lt;void&gt;;
  setStreamingState: (isStreaming: boolean, content?: string, citations?: any[]) =&gt; void;
  addMessage: (message: Message) =&gt; void;
  setError: (error: string | null) =&gt; void;
  setReadingSourcesState: (isReadingSources: boolean) =&gt; void;
  setProgressState: (percentage: number, step: string) =&gt; void;
}

export interface DocumentStore {
  // State
  documents: Document[];
  progressMap: Record&lt;string, DocumentProgress&gt;;
  isUploading: boolean;
  error: string | null;
  userId: string | null;

  // Actions
  loadDocuments: (sessionId: string) =&gt; Promise&lt;void&gt;;
  uploadDocuments: (sessionId: string, files: File[]) =&gt; Promise&lt;void&gt;;
  updateDocument: (id: string, data: DocumentUpdate) =&gt; Promise&lt;void&gt;;
  toggleDocumentEnabled: (id: string) =&gt; Promise&lt;void&gt;;
  deleteDocument: (id: string) =&gt; Promise&lt;void&gt;;
  setProgress: (documentId: string, progress: DocumentProgress) =&gt; void;
  clearProgress: (documentId: string) =&gt; void;
  setUploading: (isUploading: boolean) =&gt; void;
  setError: (error: string | null) =&gt; void;
  setUserId: (userId: string | null) =&gt; void;
  clearDocuments: () =&gt; void;
}

export interface SettingsStore {
  settings: AppSettings | null;
  isLoading: boolean;
  error: string | null;
  userId: string | null;

  loadSettings: (userId: string) =&gt; Promise&lt;void&gt;;
  updateSettings: (data: SettingsUpdate) =&gt; Promise&lt;void&gt;;
  resetSettings: () =&gt; Promise&lt;void&gt;;
  validateApiKey: (apiKey: string) =&gt; Promise&lt;string | null&gt;;
  setLoading: (isLoading: boolean) =&gt; void;
  setError: (error: string | null) =&gt; void;
  setUserId: (userId: string | null) =&gt; void;
  clearSettings: () =&gt; void;
}

export interface AppStore extends SessionStore, ChatStore, DocumentStore, SettingsStore { }</file><file path="src/types/document.ts">// Document types for RAG chat application

export interface Document {
  id: string;
  userId: string;
  sessionId: string;
  filename: string;
  fileSize: number;
  status: &apos;pending&apos; | &apos;processing&apos; | &apos;completed&apos; | &apos;failed&apos;;
  pageCount?: number;
  processedAt?: Date;
  createdAt: Date;
  enabled: boolean;
  originalPath?: string;
  storedPath?: string;
  mimeType?: string;
  checksum?: string;
  title?: string;
  author?: string;
  language?: string;
  ingestError?: string;
}

export interface DocumentCreate {
  id?: string; // Optional ID for JSON imports
  sessionId: string;
  filename: string;
  fileSize: number;
  pageCount?: number;
  processedAt?: Date;
  originalPath?: string;
  storedPath?: string;
  mimeType?: string;
  checksum?: string;
  title?: string;
  author?: string;
  language?: string;
  ingestError?: string;
}

export interface DocumentUpdate {
  sessionId?: string;
  status?: Document[&apos;status&apos;];
  pageCount?: number;
  processedAt?: Date;
  enabled?: boolean;
  originalPath?: string;
  storedPath?: string;
  mimeType?: string;
  checksum?: string;
  title?: string;
  author?: string;
  language?: string;
  ingestError?: string;
}

export interface DocumentProgress {
  status: &apos;pending&apos; | &apos;processing&apos; | &apos;completed&apos; | &apos;failed&apos;;
  progress: number; // 0-100
  message?: string;
  error?: string;
}</file><file path="src/types/settings.ts">// Settings types for RAG chat application

export interface AppSettings {
  id?: string; // Primary key for IndexedDB
  userId: string;

  // API Configuration
  geminiApiKey: string;
  apiEndpoint?: string;
  model: string;

  // Chat Settings
  temperature: number;
  maxTokens: number;

  // RAG Settings
  similarityThreshold: number;
  chunkSize: number;
  chunkOverlap: number;

  // UI Settings
  theme: &apos;dark&apos; | &apos;light&apos;;
  fontSize: &apos;small&apos; | &apos;medium&apos; | &apos;large&apos;;
  showSources: boolean;
  autoSave: boolean;

  // Privacy Settings
  dataRetention: &apos;1week&apos; | &apos;1month&apos; | &apos;3months&apos; | &apos;never&apos;;
  enableAnalytics: boolean;
  crashReporting: boolean;

  // Advanced Settings
  debugMode: boolean;
  logLevel: &apos;error&apos; | &apos;warn&apos; | &apos;info&apos; | &apos;debug&apos;;
}

export interface SettingsUpdate {
  geminiApiKey?: string;
  apiEndpoint?: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  similarityThreshold?: number;
  chunkSize?: number;
  chunkOverlap?: number;
  theme?: &apos;dark&apos; | &apos;light&apos;;
  fontSize?: &apos;small&apos; | &apos;medium&apos; | &apos;large&apos;;
  showSources?: boolean;
  autoSave?: boolean;
  dataRetention?: &apos;1week&apos; | &apos;1month&apos; | &apos;3months&apos; | &apos;never&apos;;
  enableAnalytics?: boolean;
  crashReporting?: boolean;
  debugMode?: boolean;
  logLevel?: &apos;error&apos; | &apos;warn&apos; | &apos;info&apos; | &apos;debug&apos;;
}

export interface ApiKeyValidationResult {
  isValid: boolean;
  error?: {
    type: &apos;INVALID_KEY&apos; | &apos;NETWORK_ERROR&apos; | &apos;QUOTA_EXCEEDED&apos; | &apos;PERMISSION_DENIED&apos; | &apos;UNKNOWN_ERROR&apos;;
    message: string;
    details?: any;
  };
  responseTime?: number;
}</file><file path="src/utils/constants.ts">export const APP_CONFIG = {
  name: process.env.NEXT_PUBLIC_APP_NAME || &apos;Meddy&apos;,
  version: process.env.NEXT_PUBLIC_APP_VERSION || &apos;1.0.0&apos;,
  description: &apos;Chat with your documents privately&apos;,
};

export const API_CONFIG = {
  gemini: {
    embeddingModel: &apos;text-embedding-004&apos;,
    defaultModel: &apos;gemini-2.0-flash-exp&apos;,
    maxTokens: 8192,
    temperature: 0.7,
    maxRetries: 3,
    retryDelay: 1000,
  },
  rateLimits: {
    requestsPerMinute: 60,
    rateLimitWindow: 60000, // 1 minute in ms
  },
};

export const DB_CONFIG = {
  name: &apos;RAGDatabase&apos;,
  version: 1,
  stores: {
    sessions: &apos;sessions&apos;,
    messages: &apos;messages&apos;,
    documents: &apos;documents&apos;,
    embeddings: &apos;embeddings&apos;,
    settings: &apos;settings&apos;,
  },
};

export const UI_CONFIG = {
  messages: {
    maxHistoryLength: 6,
    maxInputLength: 10000,
    streamingDelay: 100,
  },
  documents: {
    maxFileSize: 50 * 1024 * 1024, // 50MB
    supportedFormats: [&apos;.json&apos;],
    batchSize: 10,
  },
  search: {
    defaultTopK: 4,
    minSimilarity: 0.1,
    maxResults: 8,
  },
};

export const STORAGE_KEYS = {
  apiKey: &apos;gemini_api_key&apos;,
  settings: &apos;app_settings&apos;,
  currentSession: &apos;current_session_id&apos;,
};

export const ROUTES = {
  home: &apos;/&apos;,
  onboarding: &apos;/onboarding&apos;,
  session: (id: string) =&gt; `/session/${id}`,
  settings: &apos;/settings&apos;,
};

export const ERROR_MESSAGES = {
  apiKeyMissing: &apos;API key is missing. Please add it in settings.&apos;,
  apiKeyInvalid: &apos;Invalid API key. Please check your settings.&apos;,
  networkError: &apos;Network error. Please check your connection.&apos;,
  documentUploadFailed: &apos;Failed to upload document. Please try again.&apos;,
  chatFailed: &apos;Failed to send message. Please try again.&apos;,
  noDocuments: &apos;No documents found. Please import documents first.&apos;,
  noRelevantChunks: &apos;No relevant information found in your documents.&apos;,
  quotaExceeded: &apos;Storage quota exceeded. Please delete some documents.&apos;,
};

export const SUCCESS_MESSAGES = {
  sessionCreated: &apos;Session created successfully.&apos;,
  sessionUpdated: &apos;Session updated successfully.&apos;,
  sessionDeleted: &apos;Session deleted successfully.&apos;,
  documentUploaded: &apos;Document uploaded successfully.&apos;,
  documentDeleted: &apos;Document deleted successfully.&apos;,
  settingsSaved: &apos;Settings saved successfully.&apos;,
  apiKeyValidated: &apos;API key validated successfully.&apos;,
};

export const DATE_FORMATS = {
  short: &apos;MMM d, yyyy&apos;,
  long: &apos;MMMM d, yyyy \&apos;at\&apos; h:mm a&apos;,
  timeOnly: &apos;h:mm a&apos;,
  relative: {
    justNow: &apos;Just now&apos;,
    minutesAgo: (m: number) =&gt; `${m}m ago`,
    hoursAgo: (h: number) =&gt; `${h}h ago`,
    daysAgo: (d: number) =&gt; `${d}d ago`,
  },
};

export const THEME_COLORS = {
  slate: {
    950: &apos;#020617&apos;,
    900: &apos;#0F172A&apos;,
    800: &apos;#1E293B&apos;,
    700: &apos;#334155&apos;,
    600: &apos;#475569&apos;,
    500: &apos;#64748B&apos;,
    400: &apos;#94A3B8&apos;,
    300: &apos;#CBD5E1&apos;,
    200: &apos;#E2E8F0&apos;,
    100: &apos;#F1F5F9&apos;,
  },
  blue: {
    500: &apos;#3B82F6&apos;,
    600: &apos;#2563EB&apos;,
    400: &apos;#60A5FA&apos;,
  },
  red: {
    500: &apos;#EF4444&apos;,
  },
  green: {
    500: &apos;#10B981&apos;,
  },
  yellow: {
    500: &apos;#F59E0B&apos;,
  },
};</file><file path="src/utils/vectorUtils.ts">/**
 * Utility functions for efficient vector storage and operations
 * Based on Flutter app&apos;s vector storage optimizations
 */

/**
 * Convert Float32Array to bytes for efficient storage
 * This reduces storage size and maintains precision
 */
export function float32ToBytes(float32Array: Float32Array): ArrayBuffer {
  // Handle both ArrayBuffer and SharedArrayBuffer
  const buffer = float32Array.buffer;
  if (buffer instanceof ArrayBuffer) {
    return buffer.slice(0);
  } else {
    // Convert SharedArrayBuffer to ArrayBuffer
    return new ArrayBuffer(buffer.byteLength);
  }
}

/**
 * Convert bytes back to Float32Array
 */
export function bytesToFloat32Array(buffer: ArrayBuffer): Float32Array {
  return new Float32Array(buffer);
}

/**
 * Calculate vector norm (L2 norm) for normalization
 */
export function calculateVectorNorm(vector: Float32Array): number {
  let sum = 0;
  for (let i = 0; i &lt; vector.length; i++) {
    sum += vector[i] * vector[i];
  }
  return Math.sqrt(sum);
}

/**
 * Normalize vector to unit length
 */
export function normalizeVector(vector: Float32Array): Float32Array {
  const norm = calculateVectorNorm(vector);
  if (norm === 0) {
    return vector; // Avoid division by zero
  }

  const normalized = new Float32Array(vector.length);
  for (let i = 0; i &lt; vector.length; i++) {
    normalized[i] = vector[i] / norm;
  }

  return normalized;
}

/**
 * Calculate cosine similarity between two vectors
 * Optimized for performance
 */
export function cosineSimilarity(a: Float32Array, b: Float32Array): number {
  if (a.length !== b.length) {
    throw new Error(&apos;Vector dimensions must match&apos;);
  }

  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  // Single loop for better performance
  for (let i = 0; i &lt; a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);

  if (normA === 0 || normB === 0) {
    return 0;
  }

  return dotProduct / (normA * normB);
}

/**
 * Calculate dot product of two vectors
 */
export function dotProduct(a: Float32Array, b: Float32Array): number {
  if (a.length !== b.length) {
    throw new Error(&apos;Vector dimensions must match&apos;);
  }

  let result = 0;
  for (let i = 0; i &lt; a.length; i++) {
    result += a[i] * b[i];
  }

  return result;
}

/**
 * Calculate Euclidean distance between two vectors
 */
export function euclideanDistance(a: Float32Array, b: Float32Array): number {
  if (a.length !== b.length) {
    throw new Error(&apos;Vector dimensions must match&apos;);
  }

  let sum = 0;
  for (let i = 0; i &lt; a.length; i++) {
    const diff = a[i] - b[i];
    sum += diff * diff;
  }

  return Math.sqrt(sum);
}

/**
 * Calculate Manhattan distance between two vectors
 */
export function manhattanDistance(a: Float32Array, b: Float32Array): number {
  if (a.length !== b.length) {
    throw new Error(&apos;Vector dimensions must match&apos;);
  }

  let sum = 0;
  for (let i = 0; i &lt; a.length; i++) {
    sum += Math.abs(a[i] - b[i]);
  }

  return sum;
}

/**
 * Validate vector dimensions and values
 */
export function validateVector(vector: Float32Array, expectedDimensions?: number): boolean {
  // Check dimensions
  if (expectedDimensions &amp;&amp; vector.length !== expectedDimensions) {
    return false;
  }

  // Check for invalid values
  for (let i = 0; i &lt; vector.length; i++) {
    const value = vector[i];
    if (!isFinite(value) || isNaN(value)) {
      return false;
    }
  }

  // Check if vector is all zeros (invalid for embeddings)
  const norm = calculateVectorNorm(vector);
  return norm &gt; 0;
}

/**
 * Compress vector for storage (optional optimization)
 * Uses simple quantization to reduce storage size
 */
export function compressVector(vector: Float32Array, precision: number = 4): Int16Array {
  const compressed = new Int16Array(vector.length);
  const scale = Math.pow(10, precision);

  for (let i = 0; i &lt; vector.length; i++) {
    compressed[i] = Math.round(vector[i] * scale);
  }

  return compressed;
}

/**
 * Decompress vector from compressed format
 */
export function decompressVector(compressed: Int16Array, precision: number = 4): Float32Array {
  const decompressed = new Float32Array(compressed.length);
  const scale = Math.pow(10, precision);

  for (let i = 0; i &lt; compressed.length; i++) {
    decompressed[i] = compressed[i] / scale;
  }

  return decompressed;
}

/**
 * Calculate vector statistics for debugging
 */
export function getVectorStats(vector: Float32Array): {
  min: number;
  max: number;
  mean: number;
  std: number;
  norm: number;
} {
  let min = Infinity;
  let max = -Infinity;
  let sum = 0;
  let sumSquares = 0;

  for (let i = 0; i &lt; vector.length; i++) {
    const value = vector[i];
    min = Math.min(min, value);
    max = Math.max(max, value);
    sum += value;
    sumSquares += value * value;
  }

  const mean = sum / vector.length;
  const variance = (sumSquares / vector.length) - (mean * mean);
  const std = Math.sqrt(Math.max(0, variance));
  const norm = Math.sqrt(sumSquares);

  return { min, max, mean, std, norm };
}

/**
 * Batch cosine similarity calculation for multiple vectors
 * Optimized for performance in vector search
 */
export function batchCosineSimilarity(
  query: Float32Array,
  vectors: Float32Array[]
): number[] {
  const queryNorm = calculateVectorNorm(query);
  if (queryNorm === 0) {
    return new Array(vectors.length).fill(0);
  }

  const similarities: number[] = [];

  for (const vector of vectors) {
    if (vector.length !== query.length) {
      similarities.push(0);
      continue;
    }

    const vectorNorm = calculateVectorNorm(vector);
    if (vectorNorm === 0) {
      similarities.push(0);
      continue;
    }

    const similarity = dotProduct(query, vector) / (queryNorm * vectorNorm);
    similarities.push(similarity);
  }

  return similarities;
}

/**
 * Create vector index for faster search (simple implementation)
 * In production, consider using specialized vector databases
 */
export interface VectorIndex {
  vectors: Float32Array[];
  norms: number[];
  metadata: any[];
}

export function createVectorIndex(): VectorIndex {
  return {
    vectors: [],
    norms: [],
    metadata: []
  };
}

export function addToVectorIndex(
  index: VectorIndex,
  vector: Float32Array,
  metadata: any
): void {
  index.vectors.push(vector);
  index.norms.push(calculateVectorNorm(vector));
  index.metadata.push(metadata);
}

export function searchVectorIndex(
  index: VectorIndex,
  query: Float32Array,
  maxResults: number = 8,
  similarityThreshold: number = 0.7
): Array&lt;{ vector: Float32Array; similarity: number; metadata: any }&gt; {
  const queryNorm = calculateVectorNorm(query);
  if (queryNorm === 0) {
    return [];
  }

  const results: Array&lt;{ vector: Float32Array; similarity: number; metadata: any }&gt; = [];

  for (let i = 0; i &lt; index.vectors.length; i++) {
    const vector = index.vectors[i];
    const vectorNorm = index.norms[i];

    if (vectorNorm === 0) {
      continue;
    }

    const similarity = dotProduct(query, vector) / (queryNorm * vectorNorm);

    if (similarity &gt;= similarityThreshold) {
      results.push({
        vector,
        similarity,
        metadata: index.metadata[i]
      });
    }
  }

  // Sort by similarity (descending) and limit results
  return results
    .sort((a, b) =&gt; b.similarity - a.similarity)
    .slice(0, maxResults);
}</file><file path="package.json">{
  &quot;name&quot;: &quot;rag-web&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Meddy - Chat with your documents privately on Web&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;next dev&quot;,
    &quot;build&quot;: &quot;next build&quot;,
    &quot;start&quot;: &quot;next start&quot;,
    &quot;lint&quot;: &quot;next lint&quot;,
    &quot;type-check&quot;: &quot;tsc --noEmit&quot;,
    &quot;format&quot;: &quot;prettier --write .&quot;,
    &quot;test-modal&quot;: &quot;node test-modal-terminal.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@google/genai&quot;: &quot;^0.2.0&quot;,
    &quot;@headlessui/react&quot;: &quot;^1.7.0&quot;,
    &quot;@heroicons/react&quot;: &quot;^2.0.0&quot;,
    &quot;@hookform/resolvers&quot;: &quot;^3.3.0&quot;,
    &quot;@supabase/ssr&quot;: &quot;^0.7.0&quot;,
    &quot;@supabase/supabase-js&quot;: &quot;^2.83.0&quot;,
    &quot;@tailwindcss/aspect-ratio&quot;: &quot;^0.4.2&quot;,
    &quot;@tailwindcss/forms&quot;: &quot;^0.5.10&quot;,
    &quot;@tailwindcss/typography&quot;: &quot;^0.5.19&quot;,
    &quot;clsx&quot;: &quot;^2.0.0&quot;,
    &quot;date-fns&quot;: &quot;^2.30.0&quot;,
    &quot;dexie&quot;: &quot;^3.2.0&quot;,
    &quot;dexie-react-hooks&quot;: &quot;^1.1.0&quot;,
    &quot;file-saver&quot;: &quot;^2.0.0&quot;,
    &quot;lodash-es&quot;: &quot;^4.17.0&quot;,
    &quot;next&quot;: &quot;^14.0.0&quot;,
    &quot;process&quot;: &quot;^0.11.10&quot;,
    &quot;react&quot;: &quot;^18.0.0&quot;,
    &quot;react-dom&quot;: &quot;^18.0.0&quot;,
    &quot;react-hook-form&quot;: &quot;^7.47.0&quot;,
    &quot;react-markdown&quot;: &quot;^9.0.0&quot;,
    &quot;rehype-highlight&quot;: &quot;^7.0.0&quot;,
    &quot;remark-gfm&quot;: &quot;^4.0.0&quot;,
    &quot;tailwindcss&quot;: &quot;^3.3.0&quot;,
    &quot;typescript&quot;: &quot;^5.0.0&quot;,
    &quot;uuid&quot;: &quot;^9.0.0&quot;,
    &quot;zod&quot;: &quot;^3.22.0&quot;,
    &quot;zustand&quot;: &quot;^4.4.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@types/file-saver&quot;: &quot;^2.0.0&quot;,
    &quot;@types/lodash-es&quot;: &quot;^4.17.0&quot;,
    &quot;@types/node&quot;: &quot;^20.0.0&quot;,
    &quot;@types/react&quot;: &quot;^18.0.0&quot;,
    &quot;@types/react-dom&quot;: &quot;^18.0.0&quot;,
    &quot;@types/uuid&quot;: &quot;^9.0.0&quot;,
    &quot;autoprefixer&quot;: &quot;^10.0.0&quot;,
    &quot;eslint&quot;: &quot;^8.0.0&quot;,
    &quot;eslint-config-next&quot;: &quot;^14.0.0&quot;,
    &quot;postcss&quot;: &quot;^8.0.0&quot;,
    &quot;prettier&quot;: &quot;^3.0.0&quot;,
    &quot;prettier-plugin-tailwindcss&quot;: &quot;^0.5.0&quot;,
    &quot;puppeteer&quot;: &quot;^24.30.0&quot;
  }
}</file><file path="src/app/page.tsx">&apos;use client&apos;;

import React, { useEffect, useState } from &apos;react&apos;;

export const dynamic = &apos;force-dynamic&apos;;
import { useSessionStore, useDocumentStore } from &apos;../store&apos;;
import { SessionList } from &apos;../components/session&apos;;
import { Button } from &apos;../components/ui&apos;;
import { CreateSessionDialog } from &apos;../components/session&apos;;
import { EmptyState } from &apos;../components/common&apos;;
import { SimpleHeader } from &apos;../components/layout&apos;;
import { useRouter } from &apos;next/navigation&apos;;
import type { Session } from &apos;../types&apos;;

export default function HomePage() {
  const router = useRouter();
  const { sessions, loadSessions, createSession, isLoading, currentSessionId, setCurrentSession, userId } = useSessionStore();
  const { loadDocuments } = useDocumentStore();
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isMounted, setIsMounted] = useState(false);

  // Prevent hydration mismatch
  useEffect(() =&gt; {
    setIsMounted(true);
  }, []);

  // Load sessions on mount (client-side only)
  useEffect(() =&gt; {
    if (isMounted &amp;&amp; userId) {
      loadSessions(userId);
    }
  }, [loadSessions, isMounted, userId]);

  const handleCreateSession = async (data: { name: string; description?: string; systemPrompt?: string }) =&gt; {
    try {
      const session = await createSession(data);
      setIsCreateDialogOpen(false);

      // Navigate to the new session
      router.push(`/session/${session.id}`);
    } catch (error) {
      console.error(&apos;Failed to create session:&apos;, error);
    }
  };

  const handleSessionSelect = (session: Session) =&gt; {
    setCurrentSession(session);
    router.push(`/session/${session.id}`);
  };

  return (
    &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col&quot;&gt;
      &lt;SimpleHeader /&gt;

      &lt;main className=&quot;flex-1 container mx-auto px-4 sm:px-6 py-6 sm:py-8 overflow-y-auto&quot;&gt;
        &lt;div className=&quot;mb-6 sm:mb-8&quot;&gt;
          &lt;div className=&quot;flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4&quot;&gt;
            &lt;div&gt;
              &lt;h1 className=&quot;text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white&quot;&gt;
                Your Conversations
              &lt;/h1&gt;
              &lt;p className=&quot;text-sm sm:text-base text-gray-600 dark:text-gray-300 mt-2&quot;&gt;
                Start a new conversation or continue an existing one
              &lt;/p&gt;
            &lt;/div&gt;

            &lt;Button
              onClick={() =&gt; setIsCreateDialogOpen(true)}
              className=&quot;flex items-center gap-2 w-full sm:w-auto justify-center&quot;
            &gt;
              &lt;svg
                className=&quot;w-4 h-4&quot;
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M12 4v16m8-8H4&quot;
                /&gt;
              &lt;/svg&gt;
              New Conversation
            &lt;/Button&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Sessions List */}
        {isMounted &amp;&amp; sessions.length === 0 &amp;&amp; !isLoading ? (
          &lt;EmptyState
            title=&quot;No conversations yet&quot;
            description=&quot;Start your first conversation to begin chatting with your documents&quot;
            icon={
              &lt;svg
                className=&quot;w-12 h-12 text-gray-400&quot;
                fill=&quot;none&quot;
                viewBox=&quot;0 0 24 24&quot;
                stroke=&quot;currentColor&quot;
              &gt;
                &lt;path
                  strokeLinecap=&quot;round&quot;
                  strokeLinejoin=&quot;round&quot;
                  strokeWidth={2}
                  d=&quot;M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z&quot;
                /&gt;
              &lt;/svg&gt;
            }
            action={
              &lt;Button
                onClick={() =&gt; setIsCreateDialogOpen(true)}
                size=&quot;lg&quot;
              &gt;
                Start Your First Conversation
              &lt;/Button&gt;
            }
          /&gt;
        ) : (
          &lt;SessionList
            onSessionSelect={handleSessionSelect}
            showCreateButton={false} // We have our own create button
          /&gt;
        )}
      &lt;/main&gt;

      {/* Create Session Dialog */}
      &lt;CreateSessionDialog
        isOpen={isCreateDialogOpen}
        onClose={() =&gt; setIsCreateDialogOpen(false)}
        onCreate={(session) =&gt; {
          router.push(`/session/${session.id}`);
        }}
      /&gt;
    &lt;/div&gt;
  );
}</file><file path="src/components/layout/Header.tsx">import React from &apos;react&apos;;
import Link from &apos;next/link&apos;;
import { useRouter } from &apos;next/navigation&apos;;
import { Button } from &apos;../ui/Button&apos;;
import { useSettingsStore } from &apos;../../store&apos;;

interface HeaderProps {
  title?: string;
  showBackButton?: boolean;
  actions?: React.ReactNode;
}

export const Header: React.FC&lt;HeaderProps&gt; = ({
  title,
  showBackButton = false,
  actions,
}) =&gt; {
  const router = useRouter();
  const { settings } = useSettingsStore();

  const handleBack = () =&gt; {
    router.back();
  };

  return (
    &lt;header className=&quot;bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700&quot;&gt;
      &lt;div className=&quot;max-w-7xl mx-auto px-3 sm:px-4 lg:px-8&quot;&gt;
        &lt;div className=&quot;flex items-center justify-between h-14 sm:h-16&quot;&gt;
          {/* Left side */}
          &lt;div className=&quot;flex items-center flex-1 min-w-0&quot;&gt;
            {showBackButton &amp;&amp; (
              &lt;Button
                variant=&quot;ghost&quot;
                size=&quot;sm&quot;
                onClick={handleBack}
                className=&quot;mr-2 sm:mr-3 p-2&quot;
              &gt;
                &lt;svg
                  className=&quot;h-4 w-4 sm:h-5 sm:w-5&quot;
                  fill=&quot;none&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  stroke=&quot;currentColor&quot;
                &gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M15 19l-7-7 7-7&quot;
                  /&gt;
                &lt;/svg&gt;
              &lt;/Button&gt;
            )}

            &lt;Link href=&quot;/&quot; className=&quot;flex items-center min-w-0&quot;&gt;
              &lt;div className=&quot;flex-shrink-0&quot;&gt;
                &lt;div className=&quot;h-10 w-10 sm:h-12 sm:w-12 bg-blue-500 rounded-lg flex items-center justify-center&quot;&gt;
                  &lt;svg
                    className=&quot;h-6 w-6 sm:h-8 sm:w-8 text-white&quot;
                    fill=&quot;none&quot;
                    viewBox=&quot;0 0 24 24&quot;
                    stroke=&quot;currentColor&quot;
                  &gt;
                    &lt;path
                      strokeLinecap=&quot;round&quot;
                      strokeLinejoin=&quot;round&quot;
                      strokeWidth={2}
                      d=&quot;M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z&quot;
                    /&gt;
                  &lt;/svg&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div className=&quot;ml-3 sm:ml-4 min-w-0&quot;&gt;
                &lt;h1 className=&quot;text-lg sm:text-xl font-semibold text-gray-900 dark:text-white truncate&quot;&gt;
                  {title || &apos;MEDDY&apos;}
                &lt;/h1&gt;
              &lt;/div&gt;
            &lt;/Link&gt;
          &lt;/div&gt;

          {/* Right side - Actions */}
          &lt;div className=&quot;flex items-center space-x-2 sm:space-x-3&quot;&gt;
            {actions}

            {/* Settings button */}
            &lt;Link href=&quot;/settings&quot;&gt;
              &lt;Button variant=&quot;ghost&quot; size=&quot;sm&quot; className=&quot;p-2&quot;&gt;
                &lt;svg
                  className=&quot;h-4 w-4 sm:h-5 sm:w-5 text-gray-700 dark:text-gray-200&quot;
                  fill=&quot;none&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  stroke=&quot;currentColor&quot;
                &gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z&quot;
                  /&gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M15 12a3 3 0 11-6 0 3 3 0 016 0z&quot;
                  /&gt;
                &lt;/svg&gt;
              &lt;/Button&gt;
            &lt;/Link&gt;

            {/* API Key Status Indicator - Hidden on mobile */}
            &lt;div className=&quot;hidden sm:flex items-center&quot;&gt;
              &lt;div className={`
                h-2 w-2 rounded-full mr-2
                ${settings?.geminiApiKey ? &apos;bg-green-500&apos; : &apos;bg-red-500&apos;}
              `} /&gt;
              &lt;span className=&quot;text-xs text-gray-600 dark:text-gray-300&quot;&gt;
                {settings?.geminiApiKey ? &apos;Connected&apos; : &apos;Not Connected&apos;}
              &lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/header&gt;
  );
};

// Simple header for home page
export const SimpleHeader: React.FC = () =&gt; {
  const { settings } = useSettingsStore();

  return (
    &lt;header className=&quot;bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700&quot;&gt;
      &lt;div className=&quot;max-w-7xl mx-auto px-3 sm:px-4 lg:px-8&quot;&gt;
        &lt;div className=&quot;flex items-center justify-between h-14 sm:h-16&quot;&gt;
          &lt;div className=&quot;flex items-center flex-1 min-w-0&quot;&gt;
            &lt;div className=&quot;flex-shrink-0&quot;&gt;
              &lt;div className=&quot;h-10 w-10 sm:h-12 sm:w-12 bg-blue-500 rounded-lg flex items-center justify-center&quot;&gt;
                &lt;svg
                  className=&quot;h-6 w-6 sm:h-8 sm:w-8 text-white&quot;
                  fill=&quot;none&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  stroke=&quot;currentColor&quot;
                &gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z&quot;
                  /&gt;
                &lt;/svg&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;ml-3 sm:ml-4 flex flex-col min-w-0&quot;&gt;
              &lt;h1 className=&quot;text-lg sm:text-xl font-semibold text-gray-900 dark:text-white truncate&quot;&gt;
                MEDDY
              &lt;/h1&gt;
              &lt;p className=&quot;text-xs sm:text-sm text-gray-600 dark:text-gray-300 truncate&quot;&gt;
                Made with ‚ù§Ô∏è by Prayas
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div className=&quot;flex items-center space-x-2 sm:space-x-3&quot;&gt;
            &lt;Link href=&quot;/settings&quot;&gt;
              &lt;Button variant=&quot;ghost&quot; size=&quot;sm&quot; className=&quot;p-2&quot;&gt;
                &lt;svg
                  className=&quot;h-4 w-4 sm:h-5 sm:w-5 text-gray-700 dark:text-gray-200&quot;
                  fill=&quot;none&quot;
                  viewBox=&quot;0 0 24 24&quot;
                  stroke=&quot;currentColor&quot;
                &gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z&quot;
                  /&gt;
                  &lt;path
                    strokeLinecap=&quot;round&quot;
                    strokeLinejoin=&quot;round&quot;
                    strokeWidth={2}
                    d=&quot;M15 12a3 3 0 11-6 0 3 3 0 016 0z&quot;
                  /&gt;
                &lt;/svg&gt;
              &lt;/Button&gt;
            &lt;/Link&gt;

            &lt;div className=&quot;hidden sm:flex items-center&quot;&gt;
              &lt;div className={`
                h-2 w-2 rounded-full mr-2
                ${settings?.geminiApiKey ? &apos;bg-green-500&apos; : &apos;bg-red-500&apos;}
              `} /&gt;
              &lt;span className=&quot;text-xs text-gray-600 dark:text-gray-300&quot;&gt;
                {settings?.geminiApiKey ? &apos;Connected&apos; : &apos;Setup Required&apos;}
              &lt;/span&gt;
            &lt;/div&gt;

            &lt;Button
              variant=&quot;ghost&quot;
              size=&quot;sm&quot;
              className=&quot;p-2 text-gray-600 dark:text-gray-300 hover:text-red-500 dark:hover:text-red-400&quot;
              onClick={async () =&gt; {
                try {
                  const { createClient } = await import(&apos;@/utils/supabase/client&apos;);
                  const supabase = createClient();
                  const { error } = await supabase.auth.signOut();
                  
                  if (error) {
                    console.error(&apos;Sign out error:&apos;, error);
                  }
                  
                  // Force redirect to login page after sign out
                  window.location.href = &apos;/login&apos;;
                } catch (error) {
                  console.error(&apos;Unexpected error during sign out:&apos;, error);
                  // Still redirect to login even if there&apos;s an error
                  window.location.href = &apos;/login&apos;;
                }
              }}
            &gt;
              &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; strokeWidth={1.5} stroke=&quot;currentColor&quot; className=&quot;w-5 h-5&quot;&gt;
                &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; d=&quot;M15.75 9V5.25A2.25 2.25 0 0013.5 3h-6a2.25 2.25 0 00-2.25 2.25v13.5A2.25 2.25 0 007.5 21h6a2.25 2.25 0 002.25-2.25V15M12 9l-3 3m0 0l3 3m-3-3h12.75&quot; /&gt;
              &lt;/svg&gt;
            &lt;/Button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/header&gt;
  );
};</file><file path="src/services/indexedDB/embeddingService.ts">import { db } from &apos;./db&apos;;
import type { EmbeddingChunk, EmbeddingChunkCreate } from &apos;@/types&apos;;
import { ensureDate } from &apos;@/utils/date&apos;;
import { float32ToBytes, bytesToFloat32Array, calculateVectorNorm, validateVector } from &apos;@/utils/vectorUtils&apos;;

export class EmbeddingService {
  /**
   * Create a new embedding chunk
   */
  async createEmbedding(data: EmbeddingChunkCreate): Promise&lt;EmbeddingChunk&gt; {
    // Validate embedding before storage
    if (!validateVector(data.embedding, 768)) {
      throw new Error(&apos;Invalid embedding: must have 768 dimensions and contain valid values&apos;);
    }

    // Calculate and store norm for faster similarity calculations
    const norm = calculateVectorNorm(data.embedding);

    const embedding: EmbeddingChunk = {
      id: crypto.randomUUID(),
      documentId: data.documentId,
      sessionId: data.sessionId,
      content: data.content,
      embedding: data.embedding,
      chunkIndex: data.metadata.chunkIndex, // Extract chunkIndex as top-level field
      source: data.metadata.source,
      page: data.metadata.pageNumber,
      tokenCount: data.metadata.tokenCount,
      embeddingNorm: norm,
      metadata: {
        ...data.metadata,
        pageNumber: data.metadata.pageNumber,
        pageNumbers: data.metadata.pageNumbers || (data.metadata.pageNumber ? [data.metadata.pageNumber] : undefined),
        embeddingNorm: norm,
        embeddingBytes: float32ToBytes(data.embedding), // Store as bytes for efficiency
      },
      createdAt: new Date(),
    };

    if (!db) throw new Error(&apos;Database not initialized&apos;);
    await db.embeddings.add(embedding);
    return embedding;
  }

  /**
   * Create multiple embedding chunks in batch
   */
  async createEmbeddingsBatch(embeddings: EmbeddingChunkCreate[]): Promise&lt;void&gt; {
    console.log(&apos;üîç EMBEDDING SERVICE DEBUG: createEmbeddingsBatch called with:&apos;, {
      count: embeddings.length,
      documentIds: [...new Set(embeddings.map(e =&gt; e.documentId))],
      sessionIds: [...new Set(embeddings.map(e =&gt; e.sessionId))]
    });

    const embeddingChunks: EmbeddingChunk[] = embeddings.map(data =&gt; {
      // Validate embedding
      if (!validateVector(data.embedding, 768)) {
        throw new Error(`Invalid embedding for chunk ${data.documentId}: must have 768 dimensions and contain valid values`);
      }

      // Calculate norm for faster similarity calculations
      const norm = calculateVectorNorm(data.embedding);

      return {
        id: crypto.randomUUID(),
        documentId: data.documentId,
        sessionId: data.sessionId,
        chunkIndex: data.metadata.chunkIndex, // Extract chunkIndex as top-level field
        content: data.content,
        source: data.metadata.source,
        page: data.metadata.pageNumber,
        embedding: data.embedding,
        tokenCount: data.metadata.tokenCount,
        embeddingNorm: norm,
        metadata: {
          ...data.metadata,
          pageNumber: data.metadata.pageNumber,
          pageNumbers: data.metadata.pageNumbers || (data.metadata.pageNumber ? [data.metadata.pageNumber] : undefined),
          embeddingNorm: norm,
          embeddingBytes: float32ToBytes(data.embedding), // Store as bytes for efficiency
        },
        createdAt: new Date(),
      };
    });

    console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Processed embedding chunks:&apos;, {
      count: embeddingChunks.length,
      firstChunk: {
        id: embeddingChunks[0]?.id,
        documentId: embeddingChunks[0]?.documentId,
        sessionId: embeddingChunks[0]?.sessionId
      }
    });

    if (!db) throw new Error(&apos;Database not initialized&apos;);

    console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Starting transaction to save embeddings&apos;);
    console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Starting transaction to save embeddings&apos;);
    await db.transaction(&apos;rw&apos;, db.embeddings, async () =&gt; {
      console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Transaction started, adding embeddings via bulkAdd&apos;);

      if (!db) throw new Error(&apos;Database not initialized&apos;);

      // Use bulkAdd for much better performance
      await db.embeddings.bulkAdd(embeddingChunks);

      console.log(&apos;üîç EMBEDDING SERVICE DEBUG: All embeddings added to transaction via bulkAdd&apos;);
    });

    console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Transaction completed successfully&apos;);
  }

  /**
   * Add embeddings directly without re-validation or re-mapping (for efficient batch processing)
   * This assumes the chunks are already fully formed and validated
   */
  async addEmbeddingsDirectly(chunks: EmbeddingChunk[]): Promise&lt;void&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);
    if (chunks.length === 0) return;

    // console.log(`üîç EMBEDDING SERVICE DEBUG: Direct batch insert of ${chunks.length} chunks`);

    if (!db) throw new Error(&apos;Database not initialized&apos;);
    await db.transaction(&apos;rw&apos;, db.embeddings, async () =&gt; {
      if (!db) throw new Error(&apos;Database not initialized&apos;);
      await db.embeddings.bulkAdd(chunks);
    });
  }

  /**
   * Get all embeddings for a document
   */
  async getEmbeddingsByDocument(documentId: string): Promise&lt;EmbeddingChunk[]&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);
    const embeddings = await db.embeddings
      .where(&apos;documentId&apos;)
      .equals(documentId)
      .sortBy(&apos;chunkIndex&apos;);

    // Ensure createdAt is a Date object (handles IndexedDB serialization)
    return embeddings.map(embedding =&gt; ({
      ...embedding,
      createdAt: ensureDate(embedding.createdAt)
    }));
  }

  /**
   * Get all embeddings for a session
   */
  async getEmbeddingsBySession(sessionId: string, userId?: string): Promise&lt;EmbeddingChunk[]&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);

    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(sessionId);
      if (!session || session.userId !== userId) {
        return []; // Return empty array if session doesn&apos;t exist or doesn&apos;t belong to user
      }
    }

    const embeddings = await db.embeddings
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .toArray();

    // Ensure createdAt is a Date object (handles IndexedDB serialization)
    return embeddings.map(embedding =&gt; ({
      ...embedding,
      createdAt: ensureDate(embedding.createdAt)
    }));
  }

  /**
   * Get embeddings for enabled documents in a session
   */
  async getEnabledEmbeddingsBySession(sessionId: string, userId?: string): Promise&lt;EmbeddingChunk[]&gt; {
    // First get enabled documents for the session
    if (!db) throw new Error(&apos;Database not initialized&apos;);

    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(sessionId);
      if (!session || session.userId !== userId) {
        return []; // Return empty array if session doesn&apos;t exist or doesn&apos;t belong to user
      }
    }

    const enabledDocuments = await db.documents
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .and((doc: any) =&gt; doc.enabled === true)
      .toArray();

    const documentIds = enabledDocuments.map((doc: any) =&gt; doc.id);

    // Then get embeddings for those documents
    if (documentIds.length === 0) {
      return [];
    }

    if (!db) throw new Error(&apos;Database not initialized&apos;);
    const embeddings = await db.embeddings
      .where(&apos;documentId&apos;)
      .anyOf(documentIds)
      .toArray();

    // Ensure createdAt is a Date object (handles IndexedDB serialization)
    return embeddings.map(embedding =&gt; ({
      ...embedding,
      createdAt: ensureDate(embedding.createdAt)
    }));
  }

  /**
   * Delete embeddings for a document
   */
  async deleteEmbeddingsByDocument(documentId: string): Promise&lt;void&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);
    await db.embeddings.where(&apos;documentId&apos;).equals(documentId).delete();
  }

  /**
   * Check if embeddings already exist for a document
   */
  async embeddingsExistForDocument(documentId: string): Promise&lt;boolean&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);
    const count = await db.embeddings.where(&apos;documentId&apos;).equals(documentId).count();
    return count &gt; 0;
  }

  /**
   * Create embeddings with idempotent behavior
   * Deletes existing embeddings for the document before creating new ones
   */
  async createEmbeddingsIdempotent(embeddings: EmbeddingChunkCreate[]): Promise&lt;void&gt; {
    if (!embeddings || embeddings.length === 0) return;

    const documentId = embeddings[0].documentId;
    console.log(&apos;üîç EMBEDDING SERVICE DEBUG: createEmbeddingsIdempotent called for document:&apos;, documentId);

    try {
      // First check if embeddings already exist
      const existingEmbeddings = await this.embeddingsExistForDocument(documentId);

      if (existingEmbeddings) {
        console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Existing embeddings found, deleting before creating new ones&apos;);
        // Delete existing embeddings to avoid key constraint errors
        await this.deleteEmbeddingsByDocument(documentId);
      }

      // Create new embeddings
      await this.createEmbeddingsBatch(embeddings);
      console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Embeddings created successfully with idempotent approach&apos;);
    } catch (error) {
      console.error(&apos;üî¥ EMBEDDING SERVICE ERROR: Failed to create embeddings idempotently:&apos;, error);

      // Check if it&apos;s a constraint violation
      if (error instanceof Error &amp;&amp; error.name === &apos;ConstraintError&apos;) {
        console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Constraint error detected, attempting cleanup and retry&apos;);
        try {
          // Try to clean up and retry once
          await this.deleteEmbeddingsByDocument(documentId);
          await this.createEmbeddingsBatch(embeddings);
          console.log(&apos;üîç EMBEDDING SERVICE DEBUG: Retry after constraint error successful&apos;);
        } catch (retryError) {
          console.error(&apos;üî¥ EMBEDDING SERVICE ERROR: Retry after constraint error failed:&apos;, retryError);
          throw retryError;
        }
      } else {
        throw error;
      }
    }
  }

  /**
   * Delete embeddings for a session
   */
  async deleteEmbeddingsBySession(sessionId: string): Promise&lt;void&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);
    await db.embeddings.where(&apos;sessionId&apos;).equals(sessionId).delete();
  }

  /**
   * Get embedding count for a document
   */
  async getEmbeddingCountByDocument(documentId: string): Promise&lt;number&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);
    return await db.embeddings.where(&apos;documentId&apos;).equals(documentId).count();
  }

  /**
   * Get embedding count for a session
   */
  async getEmbeddingCountBySession(sessionId: string): Promise&lt;number&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);
    return await db.embeddings.where(&apos;sessionId&apos;).equals(sessionId).count();
  }

  /**
   * Search embeddings by content (basic text search)
   */
  async searchEmbeddingsByContent(sessionId: string, query: string, userId?: string): Promise&lt;EmbeddingChunk[]&gt; {
    const embeddings = await this.getEnabledEmbeddingsBySession(sessionId, userId);
    const lowerQuery = query.toLowerCase();

    // Note: embeddings are already processed by getEnabledEmbeddingsBySession
    // so createdAt is already ensured to be a Date object
    return embeddings.filter(embedding =&gt;
      embedding.content.toLowerCase().includes(lowerQuery)
    );
  }

  /**
   * Get embeddings with pagination
   */
  async getEmbeddingsPaginated(
    sessionId: string,
    offset: number = 0,
    limit: number = 100,
    userId?: string
  ): Promise&lt;EmbeddingChunk[]&gt; {
    if (!db) throw new Error(&apos;Database not initialized&apos;);

    // If userId is provided, verify session ownership
    if (userId) {
      const session = await db.sessions.get(sessionId);
      if (!session || session.userId !== userId) {
        return []; // Return empty array if session doesn&apos;t exist or doesn&apos;t belong to user
      }
    }

    const embeddings = await db.embeddings
      .where(&apos;sessionId&apos;)
      .equals(sessionId)
      .offset(offset)
      .limit(limit)
      .toArray();

    // Ensure createdAt is a Date object (handles IndexedDB serialization)
    return embeddings.map(embedding =&gt; ({
      ...embedding,
      createdAt: ensureDate(embedding.createdAt)
    }));
  }
}

export const embeddingService = new EmbeddingService();</file><file path="src/services/rag/citationService.ts">import type { VectorSearchResult } from &apos;@/types/embedding&apos;;
import type { Citation as MessageCitation } from &apos;@/types/message&apos;;
import type { SimplifiedCitation, SimplifiedCitationGroup, PageGroup } from &apos;@/types/citation&apos;;

export interface Citation {
  document: string;
  page?: number;
  pages?: number[]; // Multiple pages for combined chunks
  pageRange?: string; // Formatted page range like &quot;5-7&quot; or &quot;5,7,9&quot;
  excerpt: string;
  sourceIndex: number;
  chunkId: string;
  fullContent?: string; // Full chunk content for display
}

export interface ProcessedCitations {
  citations: Citation[];
  renumberedResponse: string;
  usedSourceIndices: number[];
  validationWarnings: string[]; // Add validation warnings
}


export class CitationService {
  /**
   * Extract citations from AI response and process them
   * Filters unused citations and renumbers them sequentially
   * Enhanced with robust validation and page number accuracy
   */
  processCitations(
    response: string,
    searchResults: VectorSearchResult[]
  ): ProcessedCitations {
    console.log(&apos;\n=== CITATION PROCESSING DEBUG START ===&apos;);
    console.log(&apos;[CITATION INPUT]&apos;, `Processing citations for response with ${searchResults.length} search results`);
    
    // Extract all citation references from response
    const citationMatches = this.extractCitationReferences(response);
    console.log(&apos;[CITATION MATCHES]&apos;, `Found ${citationMatches.length} citation references:`, citationMatches.map(m =&gt; `[${m.index}] at position ${m.position}`));
    
    const usedSourceIndices = new Set&lt;number&gt;();
    const validationWarnings: string[] = [];

    // Log all search results for reference
    console.log(&apos;[SEARCH RESULTS]&apos;, &apos;Available search results:&apos;);
    searchResults.forEach((result, index) =&gt; {
      console.log(`[RESULT ${index}]`, {
        chunkId: result.chunk.id,
        documentTitle: result.document.title,
        similarity: result.similarity,
        chunkPage: result.chunk.page,
        metadataPageNumber: result.chunk.metadata?.pageNumber,
        isCombined: result.chunk.metadata?.isCombined,
        originalChunkCount: result.chunk.metadata?.originalChunkCount,
        combinedChunkIds: result.chunk.metadata?.combinedChunkIds,
        contentPreview: result.chunk.content.substring(0, 100) + &apos;...&apos;
      });
    });

    // Filter valid citations and collect used indices
    const validCitations: Citation[] = [];
    
    for (const match of citationMatches) {
      const sourceIndex = match.index;
      
      // CRITICAL FIX: Convert 1-based citation to 0-based index
      // LLM citations are 1-based (CONTEXT SOURCE 1, 2, 3, 4, 5) but searchResults array is 0-based
      const correctedSourceIndex = sourceIndex - 1;
      console.log(`[CITATION INDEX MAPPING]`, `Citation [${sourceIndex}] -&gt; searchResults[${correctedSourceIndex}] (CONTEXT SOURCE ${sourceIndex})`);
      
      // Strict validation: source index must exist in search results
      if (correctedSourceIndex &gt;= 0 &amp;&amp; correctedSourceIndex &lt; searchResults.length) {
        const result = searchResults[correctedSourceIndex];
        
        console.log(`[PROCESSING CITATION [${sourceIndex}]]`, {
          chunkId: result.chunk.id,
          documentTitle: result.document.title,
          chunkPage: result.chunk.page,
          metadataPageNumber: result.chunk.metadata?.pageNumber,
          isCombined: result.chunk.metadata?.isCombined,
          correctedIndex: correctedSourceIndex,
          contextSource: `CONTEXT SOURCE ${sourceIndex}`,
          mappingCorrect: true
        });
        
        // Enhanced page number detection - handle combined chunks with multiple pages
        const pageInfo = this.detectPageNumber(
          result.chunk.content,
          result.chunk.metadata?.pageNumber,
          result.chunk.page,
          result.chunk.metadata?.pageNumbers
        );
        
        console.log(`[PAGE DETECTION [${sourceIndex}]]`, {
          contentPage: result.chunk.page,
          metadataPage: result.chunk.metadata?.pageNumber,
          metadataPageNumbers: result.chunk.metadata?.pageNumbers,
          pageInfo,
          isCombined: result.chunk.metadata?.isCombined,
          detectionPriority: &apos;metadata.pageNumbers &gt; chunk.page &gt; metadata.pageNumber &gt; content extraction&apos;
        });
        
        // Create citation with full content and enhanced page information
        const citation: Citation = {
          document: result.document.title || result.document.fileName,
          page: pageInfo.page,
          pages: pageInfo.pages,
          pageRange: pageInfo.pageRange,
          excerpt: this.createExcerpt(result.chunk.content),
          sourceIndex, // Keep original sourceIndex for display
          chunkId: result.chunk.id,
          fullContent: result.chunk.content, // Store full content for display
        };

        console.log(`[CITATION CREATED [${sourceIndex}]]`, {
          document: citation.document,
          page: citation.page,
          pages: citation.pages,
          pageRange: citation.pageRange,
          excerpt: citation.excerpt.substring(0, 80) + &apos;...&apos;
        });

        validCitations.push(citation);
        usedSourceIndices.add(sourceIndex);
      } else {
        // Add warning for invalid citation
        const warning = `Invalid citation [${sourceIndex}]: Source index out of range (corrected: ${correctedSourceIndex}, available: 0-${searchResults.length - 1})`;
        validationWarnings.push(warning);
        console.log(&apos;[INVALID CITATION]&apos;, {
          citationNumber: sourceIndex,
          correctedIndex: correctedSourceIndex,
          contextSource: `CONTEXT SOURCE ${sourceIndex}`,
          mappingFailed: true,
          reason: &apos;Index out of range&apos;,
          availableRange: `0-${searchResults.length - 1}`
        });
      }
    }

    // Remove duplicates and sort by source index
    const uniqueCitations = this.removeDuplicateCitations(validCitations)
      .sort((a, b) =&gt; a.sourceIndex - b.sourceIndex);

    console.log(&apos;[UNIQUE CITATIONS]&apos;, `After duplicate removal: ${uniqueCitations.length} citations`);
    uniqueCitations.forEach((citation, index) =&gt; {
      console.log(`[UNIQUE ${index}]`, {
        sourceIndex: citation.sourceIndex,
        document: citation.document,
        page: citation.page,
        pages: citation.pages,
        pageRange: citation.pageRange,
        chunkId: citation.chunkId
      });
    });

    // NEW: Validate that cited content actually matches the sources
    const contentValidationResult = this.validateCitationContent(response, uniqueCitations, searchResults);
    validationWarnings.push(...contentValidationResult.warnings);
    
    // Filter out citations that failed content validation
    const validatedCitations = uniqueCitations.filter((citation, index) =&gt; {
      const isValid = contentValidationResult.validCitationIndices.has(index);
      if (!isValid) {
        console.log(`[CONTENT VALIDATION FAILED]`, `Citation [${citation.sourceIndex}] removed - content doesn&apos;t match source`);
      }
      return isValid;
    });

    // Renumber citations in response and remove invalid ones
    const renumberedResponse = this.renumberCitationsAndRemoveInvalid(response, validatedCitations, validationWarnings);

    console.log(&apos;[CITATION RESULT]&apos;, {
      originalCitations: citationMatches.length,
      validCitations: validCitations.length,
      uniqueCitations: uniqueCitations.length,
      validatedCitations: validatedCitations.length,
      contentValidationWarnings: contentValidationResult.warnings.length,
      finalPageNumbers: validatedCitations.map(c =&gt; ({
        document: c.document,
        page: c.page,
        pages: c.pages,
        pageRange: c.pageRange
      }))
    });
    console.log(&apos;=== CITATION PROCESSING DEBUG END ===\n&apos;);

    return {
      citations: validatedCitations,
      renumberedResponse,
      usedSourceIndices: Array.from(usedSourceIndices).sort((a, b) =&gt; a - b),
      validationWarnings,
    };
  }

  /**
   * Extract citation references from text using regex
   * FIXED: Handles comma-separated citations like [2, 13]
   */
  private extractCitationReferences(text: string): Array&lt;{ index: number; position: number }&gt; {
    // Pattern matches [1], [1,2], [1, 2, 3] etc.
    const citationPattern = /\[([\d,\s]+)\]/g;
    const matches: Array&lt;{ index: number; position: number }&gt; = [];
    let match;

    while ((match = citationPattern.exec(text)) !== null) {
      // Split by comma and process each number found in the brackets
      const indices = match[1].split(&apos;,&apos;).map(s =&gt; parseInt(s.trim(), 10));
      
      for (const index of indices) {
        if (!isNaN(index)) {
          matches.push({
            index,
            position: match.index,
          });
        }
      }
    }

    return matches;
  }

  /**
   * Remove duplicate citations (same document and page)
   * Enhanced to handle combined chunks properly
   */
  private removeDuplicateCitations(citations: Citation[]): Citation[] {
    const seen = new Set&lt;string&gt;();
    const unique: Citation[] = [];

    for (const citation of citations) {
      // Create a more sophisticated key that handles multiple pages
      let key: string;
      if (citation.pages &amp;&amp; citation.pages.length &gt; 0) {
        // For combined chunks, use sorted page numbers as part of the key
        const sortedPages = [...citation.pages].sort((a, b) =&gt; a - b).join(&apos;,&apos;);
        key = `${citation.document}_${sortedPages}`;
      } else if (citation.page) {
        // For single pages, use the page number
        key = `${citation.document}_${citation.page}`;
      } else {
        // For no page information
        key = `${citation.document}_unknown`;
      }
      
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(citation);
      }
    }

    return unique;
  }

  /**
   * Enhanced page number detection with priority order
   * Priority: 1. metadata.pageNumbers (for combined chunks), 2. chunk.page (direct page field), 3. metadata.pageNumber, 4. content extraction
   */
  private detectPageNumber(
    content: string,
    metadataPageNumber?: number,
    chunkPage?: number,
    metadataPageNumbers?: number[]
  ): { page?: number; pages?: number[]; pageRange?: string } {
    console.log(&apos;[PAGE DETECTION]&apos;, {
      chunkPage,
      metadataPageNumber,
      metadataPageNumbers,
      contentPreview: content.substring(0, 50) + &apos;...&apos;,
      checkingPriority: &apos;metadata.pageNumbers &gt; chunk.page &gt; metadata.pageNumber &gt; content extraction&apos;
    });
    
    // Priority 1: For combined chunks, use pageNumbers array
    if (metadataPageNumbers &amp;&amp; metadataPageNumbers.length &gt; 0) {
      const sortedPages = [...metadataPageNumbers].sort((a, b) =&gt; a - b);
      const pageRange = this.formatPageRange(sortedPages);
      console.log(&apos;[PAGE DETECTION RESULT]&apos;, `Using metadata.pageNumbers: ${sortedPages.join(&apos;, &apos;)} (range: ${pageRange})`);
      return {
        page: sortedPages[0], // Primary page for compatibility
        pages: sortedPages,
        pageRange
      };
    }
    
    // Priority 2: Use direct page field from chunk if available
    if (chunkPage &amp;&amp; chunkPage &gt; 0) {
      console.log(&apos;[PAGE DETECTION RESULT]&apos;, `Using chunk.page: ${chunkPage}`);
      return { page: chunkPage };
    }
    
    // Priority 3: Use metadata pageNumber if available
    if (metadataPageNumber &amp;&amp; metadataPageNumber &gt; 0) {
      console.log(&apos;[PAGE DETECTION RESULT]&apos;, `Using metadata.pageNumber: ${metadataPageNumber}`);
      return { page: metadataPageNumber };
    }
    
    // Priority 4: Try to extract page number from content as fallback
    const pagePatterns = [
      /page\s+(\d+)/i,
      /p\.?\s*(\d+)/i,
      /Á¨¨(\d+)È°µ/,
      /page\s+(\d+)\s+of/i,
    ];

    for (const pattern of pagePatterns) {
      const match = content.match(pattern);
      if (match &amp;&amp; match[1]) {
        const extractedPage = parseInt(match[1], 10);
        // Only use extracted page if it&apos;s reasonable (not 0 or negative)
        if (extractedPage &gt; 0) {
          console.log(&apos;[PAGE DETECTION RESULT]&apos;, `Using content extraction: ${extractedPage}`);
          return { page: extractedPage };
        }
      }
    }

    console.log(&apos;[PAGE DETECTION RESULT]&apos;, &apos;No valid page number found&apos;);
    // Return undefined if no valid page number found
    return {};
  }

  /**
   * Format page numbers into a readable range or list
   */
  private formatPageRange(pages: number[]): string {
    if (pages.length === 0) return &apos;&apos;;
    if (pages.length === 1) return `${pages[0]}`;
    
    // Check if pages are consecutive
    const isConsecutive = pages.every((page, index) =&gt; {
      return index === 0 || page === pages[index - 1] + 1;
    });
    
    if (isConsecutive) {
      return `${pages[0]}-${pages[pages.length - 1]}`;
    } else {
      // For non-consecutive pages, show them as a list
      return pages.join(&apos;, &apos;);
    }
  }

  /**
   * Renumber citations in response text sequentially and remove invalid ones
   * FIXED: Handles comma-separated lists like [2, 13] correctly
   */
  private renumberCitationsAndRemoveInvalid(
    response: string,
    citations: Citation[],
    validationWarnings: string[]
  ): string {
    let renumbered = response;
    
    // Create set of valid source indices
    const validSourceIndices = new Set(citations.map(c =&gt; c.sourceIndex));
    
    // Create mapping from original indices to new indices
    const indexMap = new Map&lt;number, number&gt;();
    citations.forEach((citation, newIndex) =&gt; {
      indexMap.set(citation.sourceIndex, newIndex + 1);
    });

    // Replace both single [1] and multi [1, 2] citations
    const citationGroupPattern = /\[([\d,\s]+)\]/g;
    
    renumbered = renumbered.replace(citationGroupPattern, (match, innerContent) =&gt; {
        // Parse all numbers in the bracket
        const indices = innerContent.split(&apos;,&apos;).map((s: string) =&gt; parseInt(s.trim(), 10));
        
        // Map to new valid indices
        const newIndices = indices
            .filter((idx: number) =&gt; {
                if (!validSourceIndices.has(idx)) {
                    // Only log warning once per invalid index
                    if (!renumbered.includes(`invalid_logged_${idx}`)) {
                        validationWarnings.push(`Removed invalid citation [${idx}] from response`);
                    }
                    return false;
                }
                return true;
            })
            .map((idx: number) =&gt; indexMap.get(idx))
            .filter((idx: number | undefined): idx is number =&gt; idx !== undefined)
            .sort((a: number, b: number) =&gt; a - b); // Sort for cleaner display
            
        // If no valid citations remain in this group, return empty string
        if (newIndices.length === 0) {
            return &apos;&apos;;
        }
        
        // Return renumbered group
        return `[${newIndices.join(&apos;, &apos;)}]`;
    });

    // Clean up punctuation spacing
    renumbered = renumbered.replace(/ +([.,;:!])/g, &apos;$1&apos;);

    return renumbered.trim();
  }

  /**
   * Create a concise excerpt from chunk content for preview
   * Full content will be available via fullContent property
   */
  private createExcerpt(content: string, maxLength: number = 300): string {
    if (content.length &lt;= maxLength) {
      return content;
    }

    // Try to end at sentence boundary
    const truncated = content.substring(0, maxLength);
    const lastSentenceEnd = Math.max(
      truncated.lastIndexOf(&apos;.&apos;),
      truncated.lastIndexOf(&apos;!&apos;),
      truncated.lastIndexOf(&apos;?&apos;)
    );

    if (lastSentenceEnd &gt; maxLength * 0.7) {
      return truncated.substring(0, lastSentenceEnd + 1);
    }

    return truncated + &apos;...&apos;;
  }

  /**
   * Format citations for display at the end of response in Vancouver style
   */
  formatCitationsForDisplay(citations: Citation[]): string {
    if (citations.length === 0) {
      return &apos;&apos;;
    }

    const sources = citations.map((citation, index) =&gt; {
      let pageInfo = &apos;&apos;;
      if (citation.pageRange) {
        pageInfo = `. pp. ${citation.pageRange}`;
      } else if (citation.pages &amp;&amp; citation.pages.length &gt; 1) {
        pageInfo = `. pp. ${citation.pages.join(&apos;, &apos;)}`;
      } else if (citation.page) {
        pageInfo = `. p. ${citation.page}`;
      }
      return `${index + 1}. ${citation.document}${pageInfo}`;
    });

    return &apos;\n\n**Vancouver Style References:**\n&apos; + sources.join(&apos;\n&apos;);
  }

  /**
   * Enhanced validation of citation format in response
   */
  validateCitationFormat(response: string, availableSources: number): {
    isValid: boolean;
    errors: string[];
    warnings: string[];
  } {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check for citation references
    const citationMatches = this.extractCitationReferences(response);
    
    if (citationMatches.length === 0) {
      warnings.push(&apos;No citations found in response&apos;);
    }

    // Check for invalid citation numbers (out of range)
    for (const match of citationMatches) {
      if (match.index &gt;= availableSources) {
        errors.push(`Citation [${match.index}] is invalid - only ${availableSources} sources available (0-${availableSources - 1})`);
      }
      if (match.index &lt; 0) {
        errors.push(`Citation [${match.index}] is invalid - negative index`);
      }
    }

    // Check for consecutive citations without context
    const consecutivePattern = /\[\d+\]\s*\[\d+\]/g;
    const consecutiveMatches = response.match(consecutivePattern);
    if (consecutiveMatches &amp;&amp; consecutiveMatches.length &gt; 0) {
      warnings.push(&apos;Found consecutive citations without context between them&apos;);
    }

    // Check for citations at the very end (might be missing context)
    const endCitationPattern = /\[\d+\]\s*$/;
    if (endCitationPattern.test(response.trim())) {
      warnings.push(&apos;Citation appears at the very end without context&apos;);
    }

    // Check for citation gaps (e.g., [1], [3] without [2])
    const usedIndices = citationMatches.map(m =&gt; m.index).sort((a, b) =&gt; a - b);
    for (let i = 1; i &lt; usedIndices.length; i++) {
      if (usedIndices[i] &gt; usedIndices[i - 1] + 1) {
        warnings.push(`Citation gap detected between [${usedIndices[i - 1]}] and [${usedIndices[i]}]`);
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Extract citation metadata for storage in the correct MessageCitation format
   * Enhanced to include full content and handle combined chunks
   */
  extractCitationMetadata(
    citations: Citation[],
    searchResults: VectorSearchResult[]
  ): MessageCitation[] {
    return citations.map(citation =&gt; {
      // Find the corresponding search result to check if it&apos;s a combined chunk
      const searchResult = searchResults.find(result =&gt; result.chunk.id === citation.chunkId);
      
      // Handle combined chunks by including metadata about the original chunks
      let enhancedExcerpt = citation.fullContent || citation.excerpt;
      let additionalMetadata: any = {};
      
      if (searchResult?.chunk.metadata?.isCombined) {
        additionalMetadata = {
          isCombined: true,
          originalChunkCount: searchResult.chunk.metadata.originalChunkCount,
          combinedChunkIds: searchResult.chunk.metadata.combinedChunkIds,
        };
        
        // For combined chunks, we might want to add a note about the combination
        if (searchResult.chunk.metadata.originalChunkCount &amp;&amp; searchResult.chunk.metadata.originalChunkCount &gt; 1) {
          enhancedExcerpt = `[Combined from ${searchResult.chunk.metadata.originalChunkCount} chunks]\n\n${enhancedExcerpt}`;
        }
      }
      
      return {
        document: citation.document,
        page: citation.page,
        pages: citation.pages,
        pageRange: citation.pageRange,
        excerpt: enhancedExcerpt,
        ...additionalMetadata,
      };
    });
  }

  /**
   * Create citation links for interactive UI
   */
  createCitationLinks(citations: Citation[]): Array&lt;{
    id: string;
    text: string;
    documentId: string;
    pageNumber?: number;
    chunkId: string;
  }&gt; {
    return citations.map((citation, index) =&gt; ({
      id: `citation-${index + 1}`,
      text: `[${index + 1}]`,
      documentId: citation.document,
      pageNumber: citation.page,
      pages: citation.pages,
      pageRange: citation.pageRange,
      chunkId: citation.chunkId,
    }));
  }

  /**
   * Merge citations from multiple responses
   */
  mergeCitations(citationGroups: ProcessedCitations[]): ProcessedCitations {
    const allCitations: Citation[] = [];
    const allUsedIndices: number[] = [];
    const allValidationWarnings: string[] = [];
    let mergedResponse = &apos;&apos;;

    for (let i = 0; i &lt; citationGroups.length; i++) {
      const group = citationGroups[i];
      
      // Offset citation indices for merged response
      const offsetCitations = group.citations.map(citation =&gt; ({
        ...citation,
        sourceIndex: citation.sourceIndex + allUsedIndices.length,
      }));

      allCitations.push(...offsetCitations);
      allUsedIndices.push(...group.usedSourceIndices);
      allValidationWarnings.push(...(group.validationWarnings || []));
      
      if (i === 0) {
        mergedResponse = group.renumberedResponse;
      } else {
        // Append response with adjusted citation numbers
        mergedResponse += &apos;\n\n&apos; + this.adjustCitationIndices(
          group.renumberedResponse,
          allUsedIndices.length
        );
      }
    }

    return {
      citations: this.removeDuplicateCitations(allCitations),
      renumberedResponse: mergedResponse,
      usedSourceIndices: allUsedIndices,
      validationWarnings: allValidationWarnings,
    };
  }

  /**
   * Adjust citation indices by offset
   * FIXED: Handles comma-separated citations
   */
  private adjustCitationIndices(text: string, offset: number): string {
    const citationPattern = /\[([\d,\s]+)\]/g;
    
    return text.replace(citationPattern, (match, innerContent) =&gt; {
        const indices = innerContent.split(&apos;,&apos;).map((s: string) =&gt; parseInt(s.trim(), 10));
        const newIndices = indices.map((idx: number) =&gt; idx + offset);
        return `[${newIndices.join(&apos;, &apos;)}]`;
    });
  }

  /**
   * NEW: Validate that cited content actually appears in the cited sources
   * Enhanced with confidence scoring and more lenient validation criteria
   */
  private validateCitationContent(
    response: string,
    citations: Citation[],
    searchResults: VectorSearchResult[]
  ): {
    validCitationIndices: Set&lt;number&gt;;
    warnings: string[];
  } {
    const validCitationIndices = new Set&lt;number&gt;();
    const warnings: string[] = [];

    console.log(&apos;\n=== CONTENT VALIDATION START ===&apos;);
    console.log(&apos;[VALIDATION INPUT]&apos;, `Checking ${citations.length} citations against their sources`);
    console.log(&apos;[CITATION JOURNEY]&apos;, `Response length: ${response.length} characters`);
    console.log(&apos;[CITATION JOURNEY]&apos;, `Available search results: ${searchResults.length} sources`);

    // Extract text segments that should be supported by each citation
    const citationContexts = this.extractCitationContexts(response);
    console.log(&apos;[CITATION JOURNEY]&apos;, `Extracted contexts for ${citationContexts.size} citations`);
    
    // Log detailed citation journey
    citationContexts.forEach((context, index) =&gt; {
      console.log(`[CITATION JOURNEY CONTEXT ${index}]`, {
        citationNumber: index,
        contextLength: context.length,
        contextPreview: context.substring(0, 100) + &apos;...&apos;,
        expectedSourceIndex: index - 1, // 0-based
        contextSource: &apos;CONTEXT SOURCE &apos; + index
      });
    });

    for (let i = 0; i &lt; citations.length; i++) {
      const citation = citations[i];
      const sourceIndex = citation.sourceIndex;
      
      // Get the source content - CRITICAL FIX: Convert 1-based citation to 0-based index
      // LLM citations are 1-based (CONTEXT SOURCE 1, 2, 3, 4, 5) but searchResults array is 0-based
      const correctedSourceIndex = sourceIndex - 1;
      console.log(`[CITATION INDEX MAPPING]`, `Citation [${sourceIndex}] -&gt; searchResults[${correctedSourceIndex}] (CONTEXT SOURCE ${sourceIndex})`);
      
      const sourceResult = searchResults[correctedSourceIndex];
      if (!sourceResult) {
        warnings.push(`Citation [${sourceIndex}]: Source not found in search results (corrected index: ${correctedSourceIndex})`);
        continue;
      }

      const sourceContent = sourceResult.chunk.content.toLowerCase();
      const citationContext = citationContexts.get(sourceIndex);
      
      if (!citationContext) {
        warnings.push(`Citation [${sourceIndex}]: No context found for citation`);
        continue;
      }

      // Check if the cited context actually appears in the source
      const contextLower = citationContext.toLowerCase();
      const contentMatch = this.checkContentMatchWithConfidence(contextLower, sourceContent);
      
      console.log(`[VALIDATING CITATION [${sourceIndex}]]`, {
        citationNumber: sourceIndex,
        sourceIndex: correctedSourceIndex, // 0-based
        contextLength: citationContext.length,
        sourceContentLength: sourceContent.length,
        confidenceScore: contentMatch.confidence,
        isValid: contentMatch.confidence &gt;= 0.2, // Accept citations with 20%+ confidence (less strict)
        contextPreview: citationContext.substring(0, 100) + &apos;...&apos;,
        sourcePreview: sourceContent.substring(0, 100) + &apos;...&apos;,
        sourcePage: sourceResult.chunk.metadata?.pageNumber || sourceResult.chunk.page,
        sourceDocument: sourceResult.document.title || sourceResult.document.fileName,
        validationReason: contentMatch.reason
      });

      // Use confidence scoring instead of binary validation - LESS STRICT: lowered threshold from 0.3 to 0.2
      if (contentMatch.confidence &gt;= 0.2) {
        validCitationIndices.add(i);
        if (contentMatch.confidence &lt; 0.5) { // Lowered from 0.6 to 0.5
          warnings.push(`Citation [${sourceIndex}]: Low confidence match (${Math.round(contentMatch.confidence * 100)}%) - ${contentMatch.reason}`);
        }
      } else {
        warnings.push(`Citation [${sourceIndex}]: Rejected - ${contentMatch.reason} (confidence: ${Math.round(contentMatch.confidence * 100)}%)`);
      }
    }

    console.log(&apos;[VALIDATION RESULT]&apos;, {
      totalCitations: citations.length,
      validCitations: validCitationIndices.size,
      invalidCitations: citations.length - validCitationIndices.size,
      warnings: warnings.length
    });
    console.log(&apos;=== CONTENT VALIDATION END ===\n&apos;);

    return { validCitationIndices, warnings };
  }

  /**
   * Extract the text context that each citation should support
   * FIXED: Handles comma-separated citations by associating text with ALL citations in the group
   */
  private extractCitationContexts(response: string): Map&lt;number, string&gt; {
    console.log(&apos;\n=== CITATION CONTEXT EXTRACTION START ===&apos;);
    console.log(&apos;[CONTEXT EXTRACTION]&apos;, `Extracting contexts from response of ${response.length} characters`);
    
    const citationContexts = new Map&lt;number, string&gt;();
    const citationPattern = /\[([\d,\s]+)\]/g;
    let match;
    let lastIndex = 0;

    while ((match = citationPattern.exec(response)) !== null) {
      const citationPosition = match.index;
      
      // Parse all indices in this group
      const indices = match[1].split(&apos;,&apos;).map(s =&gt; parseInt(s.trim(), 10));
      
      // Extract text from last position to this citation group
      const textSegment = response.substring(lastIndex, citationPosition).replace(/[ \t]+/g, &apos; &apos;).trim();
      
      console.log(`[CONTEXT EXTRACTION MATCH]`, {
        citationNumbers: indices,
        citationPosition: citationPosition,
        citationText: match[0],
        lastPosition: lastIndex,
        segmentLength: textSegment.length
      });
      
      // If this segment has text, associate it with all citations in this group
      if (textSegment.length &gt; 10 || citationContexts.size === 0) {
        indices.forEach(idx =&gt; {
            citationContexts.set(idx, textSegment);
        });
      } else if (citationContexts.size &gt; 0) {
        // If text segment is too short, append to previous citation&apos;s context
        // (This is heuristic and might need refinement for multi-citation logic)
        // For grouped citations like [1,2], they share context, so finding the last key works reasonably well
        const lastKey = Array.from(citationContexts.keys()).pop();
        if (lastKey !== undefined) {
          const existingContext = citationContexts.get(lastKey) || &apos;&apos;;
          const combinedContext = existingContext + &apos; &apos; + textSegment;
          indices.forEach(idx =&gt; {
              citationContexts.set(idx, combinedContext);
          });
        }
      }
      
      lastIndex = citationPosition + match[0].length;
    }

    console.log(&apos;[CONTEXT EXTRACTION RESULT]&apos;, `Extracted ${citationContexts.size} citation contexts`);
    console.log(&apos;=== CITATION CONTEXT EXTRACTION END ===\n&apos;);

    return citationContexts;
  }

  /**
   * Check if the cited context actually matches the source content with confidence scoring
   * ENHANCED: More lenient validation with better medical term handling
   */
  private checkContentMatchWithConfidence(context: string, sourceContent: string): {
    confidence: number;
    reason: string;
  } {
    console.log(&apos;\n=== CONTENT MATCH ANALYSIS START ===&apos;);
    console.log(&apos;[CONTENT MATCH INPUT]&apos;, {
      contextLength: context.length,
      sourceLength: sourceContent.length,
      contextPreview: context.substring(0, 100) + &apos;...&apos;,
      sourcePreview: sourceContent.substring(0, 100) + &apos;...&apos;
    });

    // Remove common words and normalize for comparison
    const normalizedContext = this.normalizeTextForComparison(context);
    const normalizedSource = this.normalizeTextForComparison(sourceContent);

    let confidence = 0;
    let reasons: string[] = [];

    // 1. Check for direct phrase matches (reduced from 3 to 2 consecutive words for more leniency)
    const contextWords = normalizedContext.split(/\s+/);
    const sourceWords = normalizedSource.split(/\s+/);
    
    let maxMatchLength = 0;
    let totalPhraseMatches = 0;
    
    for (let i = 0; i &lt;= contextWords.length - 2; i++) { // Reduced from 3 to 2
      const phrase = contextWords.slice(i, i + 2).join(&apos; &apos;);
      if (normalizedSource.includes(phrase)) {
        totalPhraseMatches++;
        maxMatchLength = Math.max(maxMatchLength, 2);
        
        // Check for longer matches
        for (let j = 3; j &lt;= contextWords.length - i; j++) {
          const longerPhrase = contextWords.slice(i, i + j).join(&apos; &apos;);
          if (normalizedSource.includes(longerPhrase)) {
            maxMatchLength = j;
          } else {
            break;
          }
        }
      }
    }

    // Calculate phrase match confidence
    if (maxMatchLength &gt;= 2) { // Reduced from 3 to 2
      const phraseConfidence = Math.min(0.8, (maxMatchLength / 8) + (totalPhraseMatches * 0.15)); // More lenient calculation
      confidence = Math.max(confidence, phraseConfidence);
      reasons.push(`${maxMatchLength}+ consecutive words match`);
    }

    // 2. Check for key term overlap (reduced from 2 to 1 important term for more leniency)
    const importantTerms = this.extractImportantTerms(context);
    const matchingTerms = importantTerms.filter(term =&gt;
      normalizedSource.includes(term.toLowerCase())
    );

    const hasTermOverlap = matchingTerms.length &gt;= 1 || // Reduced from 2 to 1
                          (matchingTerms.length &gt;= 1 &amp;&amp; importantTerms.length &lt;= 1);

    if (hasTermOverlap) {
      const termConfidence = Math.min(0.7, (matchingTerms.length / Math.max(importantTerms.length, 1)) * 0.9); // More lenient
      confidence = Math.max(confidence, termConfidence);
      reasons.push(`${matchingTerms.length}/${importantTerms.length} key terms match`);
    }

    // 3. Enhanced semantic similarity check with lower threshold
    const semanticSimilarity = this.calculateSemanticSimilarity(normalizedContext, normalizedSource);
    if (semanticSimilarity &gt; 0.2) { // Reduced from 0.3 to 0.2
      const semanticConfidence = Math.min(0.6, semanticSimilarity * 0.8); // More lenient
      confidence = Math.max(confidence, semanticConfidence);
      reasons.push(`semantic similarity: ${Math.round(semanticSimilarity * 100)}%`);
    }

    // 4. Enhanced medical/scientific term matching with higher boost
    const medicalTerms = this.extractMedicalTerms(context);
    const matchingMedicalTerms = medicalTerms.filter(term =&gt;
      normalizedSource.includes(term.toLowerCase())
    );
    
    if (matchingMedicalTerms.length &gt; 0) {
      confidence += 0.15 * (matchingMedicalTerms.length / Math.max(medicalTerms.length, 1)); // Increased from 0.1 to 0.15
      reasons.push(`${matchingMedicalTerms.length} medical terms match`);
    }

    // 5. NEW: Add partial match consideration for medical content
    const medicalTermBoost = this.calculateMedicalTermMatch(context, sourceContent);
    if (medicalTermBoost &gt; 0) {
      confidence = Math.min(confidence + medicalTermBoost, 1.0);
      reasons.push(`medical term relevance: ${Math.round(medicalTermBoost * 100)}%`);
    }

    // Cap confidence at 1.0
    confidence = Math.min(confidence, 1.0);

    let reason = &apos;&apos;;
    if (confidence &lt; 0.2) { // Updated threshold to match new validation
      if (maxMatchLength &gt; 0) {
        reason = `Only found ${maxMatchLength} consecutive matching words (need at least 2)`;
      } else if (matchingTerms.length &gt; 0) {
        reason = `Only ${matchingTerms.length} key terms match (need at least 1)`;
      } else {
        reason = &apos;No meaningful content match found between citation and source&apos;;
      }
    } else {
      reason = reasons.join(&apos;; &apos;);
    }

    console.log(&apos;[CONTENT MATCH RESULT]&apos;, {
      confidence: Math.round(confidence * 100) + &apos;%&apos;,
      reason: reason,
      phraseMatches: totalPhraseMatches,
      termMatches: matchingTerms.length,
      medicalMatches: matchingMedicalTerms.length,
      semanticSimilarity: Math.round(semanticSimilarity * 100) + &apos;%&apos;
    });
    console.log(&apos;=== CONTENT MATCH ANALYSIS END ===\n&apos;);

    return { confidence, reason };
  }

  /**
   * NEW: Calculate medical term match boost for better validation
   */
  private calculateMedicalTermMatch(context: string, sourceContent: string): number {
    const medicalTerms = [
      &apos;glaucoma&apos;, &apos;cataract&apos;, &apos;diabetes&apos;, &apos;hypertension&apos;, &apos;ophthalmoscopy&apos;, &apos;ultrasound&apos;,
      &apos;diagnosis&apos;, &apos;treatment&apos;, &apos;symptom&apos;, &apos;therapy&apos;, &apos;medication&apos;, &apos;surgery&apos;, &apos;examination&apos;,
      &apos;retina&apos;, &apos;cornea&apos;, &apos;lens&apos;, &apos;optic&apos;, &apos;vision&apos;, &apos;eye&apos;, &apos;ocular&apos;, &apos;ophthalmic&apos;,
      &apos;intraocular&apos;, &apos;pressure&apos;, &apos;fluid&apos;, &apos;injection&apos;, &apos;laser&apos;, &apos;phacoemulsification&apos;
    ];

    const contextLower = context.toLowerCase();
    const sourceLower = sourceContent.toLowerCase();

    let matchCount = 0;
    for (const term of medicalTerms) {
      if (contextLower.includes(term) &amp;&amp; sourceLower.includes(term)) {
        matchCount++;
      }
    }

    // Return boost based on medical term overlap
    return Math.min(matchCount * 0.1, 0.3); // Max 30% boost
  }

  /**
   * Calculate semantic similarity between two texts using Jaccard similarity
   * This is a simplified semantic similarity check
   */
  private calculateSemanticSimilarity(text1: string, text2: string): number {
    const words1 = new Set(text1.split(/\s+/).filter(w =&gt; w.length &gt; 2));
    const words2 = new Set(text2.split(/\s+/).filter(w =&gt; w.length &gt; 2));
    
    const intersection = new Set([...words1].filter(x =&gt; words2.has(x)));
    const union = new Set([...words1, ...words2]);
    
    if (union.size === 0) return 0;
    return intersection.size / union.size;
  }

  /**
   * Legacy method for backward compatibility
   */
  private checkContentMatch(context: string, sourceContent: string): {
    isValid: boolean;
    reason: string;
  } {
    const result = this.checkContentMatchWithConfidence(context, sourceContent);
    return {
      isValid: result.confidence &gt;= 0.3,
      reason: result.reason
    };
  }

  /**
   * Normalize text for comparison by removing punctuation and common words
   */
  private normalizeTextForComparison(text: string): string {
    const commonWords = new Set([
      &apos;the&apos;, &apos;a&apos;, &apos;an&apos;, &apos;and&apos;, &apos;or&apos;, &apos;but&apos;, &apos;in&apos;, &apos;on&apos;, &apos;at&apos;, &apos;to&apos;, &apos;for&apos;,
      &apos;of&apos;, &apos;with&apos;, &apos;by&apos;, &apos;is&apos;, &apos;are&apos;, &apos;was&apos;, &apos;were&apos;, &apos;be&apos;, &apos;been&apos;, &apos;have&apos;,
      &apos;has&apos;, &apos;had&apos;, &apos;do&apos;, &apos;does&apos;, &apos;did&apos;, &apos;will&apos;, &apos;would&apos;, &apos;could&apos;, &apos;should&apos;,
      &apos;this&apos;, &apos;that&apos;, &apos;these&apos;, &apos;those&apos;, &apos;i&apos;, &apos;you&apos;, &apos;he&apos;, &apos;she&apos;, &apos;it&apos;, &apos;we&apos;, &apos;they&apos;
    ]);

    return text
      .toLowerCase()
      .replace(/[^\w\s]/g, &apos; &apos;) // Replace punctuation with spaces
      .replace(/[ \t]+/g, &apos; &apos;) // Only replace spaces and tabs, NOT newlines
      .trim()
      .split(/\s+/)
      .filter(word =&gt; !commonWords.has(word) &amp;&amp; word.length &gt; 1)
      .join(&apos; &apos;);
  }

  /**
   * Extract important terms (nouns and specific terminology) from text
   * Enhanced with better medical/scientific term identification
   */
  private extractImportantTerms(text: string): string[] {
    // Enhanced medical and scientific terms
    const medicalTerms = [
      &apos;cataract&apos;, &apos;glaucoma&apos;, &apos;diabetes&apos;, &apos;hypertension&apos;, &apos;ophthalmoscopy&apos;, &apos;ultrasound&apos;,
      &apos;diagnosis&apos;, &apos;treatment&apos;, &apos;symptom&apos;, &apos;therapy&apos;, &apos;medication&apos;, &apos;surgery&apos;, &apos;examination&apos;,
      &apos;retina&apos;, &apos;cornea&apos;, &apos;lens&apos;, &apos;optic&apos;, &apos;vision&apos;, &apos;eye&apos;, &apos;ocular&apos;, &apos;ophthalmic&apos;,
      &apos;intraocular&apos;, &apos;pressure&apos;, &apos;fluid&apos;, &apos;injection&apos;, &apos;laser&apos;, &apos;phacoemulsification&apos;,
      &apos;biometry&apos;, &apos;keratometry&apos;, &apos;astigmatism&apos;, &apos;myopia&apos;, &apos;hyperopia&apos;, &apos;presbyopia&apos;
    ];

    const scientificTerms = [
      &apos;analysis&apos;, &apos;research&apos;, &apos;study&apos;, &apos;clinical&apos;, &apos;trial&apos;, &apos;patient&apos;, &apos;outcome&apos;,
      &apos;procedure&apos;, &apos;technique&apos;, &apos;method&apos;, &apos;result&apos;, &apos;conclusion&apos;, &apos;evidence&apos;,
      &apos;parameter&apos;, &apos;measurement&apos;, &apos;assessment&apos;, &apos;evaluation&apos;, &apos;diagnostic&apos;
    ];

    // Create patterns for matching
    const importantPatterns = [
      /\b[a-zA-Z]{4,}\b/g, // Words with 4+ characters
      new RegExp(`\\b(?:${medicalTerms.join(&apos;|&apos;)})\\b`, &apos;gi&apos;), // Medical terms
      new RegExp(`\\b(?:${scientificTerms.join(&apos;|&apos;)})\\b`, &apos;gi&apos;), // Scientific terms
      /\b(?:[A-Z][a-z]+(?:[A-Z][a-z]+)*)\b/g, // CamelCase technical terms
      /\b\d+(?:\.\d+)?(?:%|mg|ml|mm|cm)\b/g, // Measurements and units
    ];

    const allMatches: string[] = [];
    importantPatterns.forEach(pattern =&gt; {
      const matches = text.match(pattern);
      if (matches) {
        allMatches.push(...matches);
      }
    });

    // Filter out common words and normalize
    const commonWords = new Set([
      &apos;this&apos;, &apos;that&apos;, &apos;with&apos;, &apos;from&apos;, &apos;they&apos;, &apos;have&apos;, &apos;been&apos;, &apos;said&apos;, &apos;each&apos;,
      &apos;which&apos;, &apos;their&apos;, &apos;time&apos;, &apos;will&apos;, &apos;about&apos;, &apos;would&apos;, &apos;there&apos;, &apos;could&apos;
    ]);

    const filteredTerms = allMatches
      .map(term =&gt; term.toLowerCase())
      .filter(term =&gt; !commonWords.has(term) &amp;&amp; term.length &gt; 2);

    // Return unique terms
    return Array.from(new Set(filteredTerms));
  }

  /**
   * Extract specifically medical terms from text
   */
  private extractMedicalTerms(text: string): string[] {
    const medicalTerms = [
      &apos;cataract&apos;, &apos;glaucoma&apos;, &apos;diabetes&apos;, &apos;hypertension&apos;, &apos;ophthalmoscopy&apos;, &apos;ultrasound&apos;,
      &apos;diagnosis&apos;, &apos;treatment&apos;, &apos;symptom&apos;, &apos;therapy&apos;, &apos;medication&apos;, &apos;surgery&apos;, &apos;examination&apos;,
      &apos;retina&apos;, &apos;cornea&apos;, &apos;lens&apos;, &apos;optic&apos;, &apos;vision&apos;, &apos;eye&apos;, &apos;ocular&apos;, &apos;ophthalmic&apos;,
      &apos;intraocular&apos;, &apos;pressure&apos;, &apos;fluid&apos;, &apos;injection&apos;, &apos;laser&apos;, &apos;phacoemulsification&apos;,
      &apos;biometry&apos;, &apos;keratometry&apos;, &apos;astigmatism&apos;, &apos;myopia&apos;, &apos;hyperopia&apos;, &apos;presbyopia&apos;
    ];

    const pattern = new RegExp(`\\b(?:${medicalTerms.join(&apos;|&apos;)})\\b`, &apos;gi&apos;);
    const matches = text.match(pattern);
    
    return matches ? Array.from(new Set(matches.map(term =&gt; term.toLowerCase()))) : [];
  }

  /**
   * NEW: Process citations using simplified page-based grouping
   * Groups all chunks from the same page into a single citation
   * ENHANCED: Added comprehensive logging and content validation
   */
  processSimplifiedCitations(
    response: string,
    searchResults: VectorSearchResult[]
  ): SimplifiedCitationGroup {
    console.log(&apos;\n=== SIMPLIFIED CITATION PROCESSING START ===&apos;);
    console.log(&apos;[SIMPLIFIED INPUT]&apos;, `Processing ${searchResults.length} search results for simplified citations`);
    console.log(&apos;[RESPONSE ANALYSIS]&apos;, `LLM Response length: ${response.length} characters`);
    console.log(&apos;[RESPONSE PREVIEW]&apos;, response.substring(0, 200) + (response.length &gt; 200 ? &apos;...&apos; : &apos;&apos;));
    
    // Extract citation references from response
    const citationMatches = this.extractCitationReferences(response);
    console.log(&apos;[CITATION MATCHES]&apos;, `Found ${citationMatches.length} citation references:`, citationMatches.map(m =&gt; `[${m.index}] at position ${m.position}`));
    
    const usedSourceIndices = new Set&lt;number&gt;();
    
    // Group search results by page
    const pageGroups = this.groupByPage(searchResults);
    console.log(&apos;[PAGE GROUPS]&apos;, `Created ${pageGroups.length} page groups`);
    
    // Extract citation contexts for validation
    const citationContexts = this.extractCitationContexts(response);
    console.log(&apos;[CITATION CONTEXTS]&apos;, `Extracted contexts for ${citationContexts.size} citations`);
    citationContexts.forEach((context, index) =&gt; {
      console.log(`[CONTEXT ${index}]`, context.substring(0, 100) + (context.length &gt; 100 ? &apos;...&apos; : &apos;&apos;));
    });

    // Filter valid citations and create simplified citations
    const validCitations: SimplifiedCitation[] = [];
    const validationWarnings: string[] = [];
    
    for (const match of citationMatches) {
      const sourceIndex = match.index;
      
      // CRITICAL FIX: Convert 1-based citation to 0-based index
      // LLM citations are 1-based (CONTEXT SOURCE 1, 2, 3, 4, 5) but searchResults array is 0-based
      const correctedSourceIndex = sourceIndex - 1;
      console.log(`[SIMPLIFIED CITATION MAPPING]`, `Citation [${sourceIndex}] -&gt; searchResults[${correctedSourceIndex}] (CONTEXT SOURCE ${sourceIndex})`);
      
      if (correctedSourceIndex &gt;= 0 &amp;&amp; correctedSourceIndex &lt; searchResults.length) {
        const result = searchResults[correctedSourceIndex];
        const pageNumber = this.getEffectivePageNumber(result);
        
        console.log(`[PROCESSING CITATION [${sourceIndex}]]`, {
          documentTitle: result.document.title || result.document.fileName,
          pageNumber,
          chunkId: result.chunk.id,
          similarity: result.similarity,
          chunkPreview: result.chunk.content.substring(0, 150) + &apos;...&apos;
        });
        
        if (pageNumber !== undefined) {
          // Find the page group for this result
          const pageGroup = pageGroups.find(pg =&gt;
            pg.documentId === result.document.id &amp;&amp; pg.page === pageNumber
          );
          
          if (pageGroup) {
            // Combine all content from this page
            const combinedContent = pageGroup.chunks
              .sort((a, b) =&gt; a.content.localeCompare(b.content)) // Sort for consistency
              .map(chunk =&gt; chunk.content)
              .join(&apos;\n---\n&apos;);
            
            // NEW: Validate that citation context matches the source content
            const citationContext = citationContexts.get(sourceIndex);
            let isValidCitation = true;
            let validationReason = &apos;&apos;;
            
            if (citationContext) {
              const validation = this.checkContentMatchWithConfidence(citationContext, combinedContent);
              isValidCitation = validation.confidence &gt;= 0.2; // LESS STRICT: lowered threshold from 0.3 to 0.2
              validationReason = validation.reason;
              
              console.log(`[CITATION VALIDATION [${sourceIndex}]]`, {
                isValid: isValidCitation,
                confidence: validation.confidence,
                reason: validation.reason,
                contextPreview: citationContext.substring(0, 80) + &apos;...&apos;,
                sourcePreview: combinedContent.substring(0, 80) + &apos;...&apos;
              });
              
              if (!isValidCitation) {
                validationWarnings.push(`Citation [${sourceIndex}] validation failed: ${validationReason}`);
              }
            } else {
              console.warn(`[VALIDATION WARNING]`, `No context found for citation [${sourceIndex}]`);
              validationWarnings.push(`No context found for citation [${sourceIndex}]`);
            }
            
            // Only add citation if it passes validation
            if (isValidCitation) {
              const simplifiedCitation: SimplifiedCitation = {
                document: result.document.title || result.document.fileName,
                page: pageNumber,
                combinedContent,
                sourceIndex,
                chunkIds: pageGroup.chunks.map(chunk =&gt; chunk.id),
                similarity: Math.max(...pageGroup.chunks.map(chunk =&gt; chunk.similarity))
              };
              
              validCitations.push(simplifiedCitation);
              usedSourceIndices.add(sourceIndex);
              
              console.log(`[VALID CITATION ADDED [${sourceIndex}]]`, {
                document: simplifiedCitation.document,
                page: simplifiedCitation.page,
                chunkCount: simplifiedCitation.chunkIds.length,
                similarity: simplifiedCitation.similarity,
                correctedIndex: correctedSourceIndex,
                contextSource: `CONTEXT SOURCE ${sourceIndex}`,
                mappingCorrect: true
              });
            } else {
              console.log(`[INVALID CITATION REJECTED [${sourceIndex}]]`, {
                reason: validationReason,
                correctedIndex: correctedSourceIndex,
                contextSource: `CONTEXT SOURCE ${sourceIndex}`,
                mappingFailed: true
              });
            }
          } else {
            console.warn(`[PAGE GROUP NOT FOUND]`, `No page group found for document ${result.document.id}, page ${pageNumber}`);
            validationWarnings.push(`No page group found for citation [${sourceIndex}]`);
          }
        } else {
          console.warn(`[PAGE NUMBER NOT FOUND]`, `No valid page number for citation [${sourceIndex}]`);
          validationWarnings.push(`No valid page number for citation [${sourceIndex}]`);
        }
      } else {
        console.warn(`[INVALID CITATION INDEX]`, `Citation [${sourceIndex}] is out of range (corrected index: ${correctedSourceIndex}, available: 0-${searchResults.length - 1})`);
        validationWarnings.push(`Citation [${sourceIndex}] is out of range (corrected index: ${correctedSourceIndex})`);
      }
    }
    
    // Remove duplicates and sort by source index
    const uniqueCitations = this.removeDuplicateSimplifiedCitations(validCitations)
      .sort((a, b) =&gt; a.sourceIndex - b.sourceIndex);
    
    // Renumber citations in response
    const renumberedResponse = this.renumberSimplifiedCitations(response, uniqueCitations);
    
    console.log(&apos;[SIMPLIFIED RESULT]&apos;, {
      originalCitations: citationMatches.length,
      validCitations: validCitations.length,
      uniqueCitations: uniqueCitations.length,
      rejectedCitations: citationMatches.length - validCitations.length,
      pageGroups: pageGroups.length,
      validationWarnings: validationWarnings.length
    });
    
    if (validationWarnings.length &gt; 0) {
      console.log(&apos;[VALIDATION WARNINGS]&apos;, validationWarnings);
    }
    
    console.log(&apos;=== SIMPLIFIED CITATION PROCESSING END ===\n&apos;);
    
    return {
      citations: uniqueCitations,
      renumberedResponse,
      usedSourceIndices: Array.from(usedSourceIndices).sort((a, b) =&gt; a - b),
      validationWarnings
    };
  }

  /**
   * Group search results by document and page
   */
  private groupByPage(searchResults: VectorSearchResult[]): PageGroup[] {
    const pageMap = new Map&lt;string, PageGroup&gt;();
    
    for (const result of searchResults) {
      const pageNumber = this.getEffectivePageNumber(result);
      
      if (pageNumber !== undefined) {
        const pageKey = `${result.document.id}_${pageNumber}`;
        
        if (!pageMap.has(pageKey)) {
          pageMap.set(pageKey, {
            documentId: result.document.id,
            documentTitle: result.document.title || result.document.fileName,
            page: pageNumber,
            chunks: []
          });
        }
        
        const pageGroup = pageMap.get(pageKey)!;
        pageGroup.chunks.push({
          id: result.chunk.id,
          content: result.chunk.content,
          similarity: result.similarity
        });
      }
    }
    
    return Array.from(pageMap.values());
  }

  /**
   * Get effective page number from search result
   */
  private getEffectivePageNumber(result: VectorSearchResult): number | undefined {
    // Priority 1: metadata.pageNumbers (for combined chunks)
    if (result.chunk.metadata?.pageNumbers &amp;&amp; result.chunk.metadata.pageNumbers.length &gt; 0) {
      return result.chunk.metadata.pageNumbers[0];
    }
    
    // Priority 2: chunk.page
    if (result.chunk.page &amp;&amp; result.chunk.page &gt; 0) {
      return result.chunk.page;
    }
    
    // Priority 3: metadata.pageNumber
    if (result.chunk.metadata?.pageNumber &amp;&amp; result.chunk.metadata.pageNumber &gt; 0) {
      return result.chunk.metadata.pageNumber;
    }
    
    // Priority 4: Extract from content
    const pagePatterns = [
      /page\s+(\d+)/i,
      /p\.?\s*(\d+)/i,
      /Á¨¨(\d+)È°µ/,
      /page\s+(\d+)\s+of/i,
    ];

    for (const pattern of pagePatterns) {
      const match = result.chunk.content.match(pattern);
      if (match &amp;&amp; match[1]) {
        const extractedPage = parseInt(match[1], 10);
        if (extractedPage &gt; 0) {
          return extractedPage;
        }
      }
    }
    
    return undefined;
  }

  /**
   * Remove duplicate simplified citations
   */
  private removeDuplicateSimplifiedCitations(citations: SimplifiedCitation[]): SimplifiedCitation[] {
    const seen = new Set&lt;string&gt;();
    const unique: SimplifiedCitation[] = [];

    for (const citation of citations) {
      const key = `${citation.document}_${citation.page}`;
      
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(citation);
      }
    }

    return unique;
  }

  /**
   * Renumber citations in simplified response
   * FIXED: Handles comma-separated citations
   */
  private renumberSimplifiedCitations(
    response: string,
    citations: SimplifiedCitation[]
  ): string {
    console.log(&apos;\n=== CITATION RENUMBERING DEBUG START ===&apos;);
    console.log(&apos;[RENAMING INPUT]&apos;, {
      responseLength: response.length,
      hasNewlines: response.includes(&apos;\n&apos;),
      newlineCount: (response.match(/\n/g) || []).length,
      bulletCount: (response.match(/^\* /gm) || []).length,
      firstFewLines: response.split(&apos;\n&apos;).slice(0, 5)
    });
    
    let renumbered = response;
    
    // Create set of valid source indices
    const validSourceIndices = new Set(citations.map(c =&gt; c.sourceIndex));
    
    // Create mapping from original indices to new indices
    const indexMap = new Map&lt;number, number&gt;();
    citations.forEach((citation, newIndex) =&gt; {
      indexMap.set(citation.sourceIndex, newIndex + 1);
    });

    // Replace citation groups [1, 2, 3]
    const citationGroupPattern = /\[([\d,\s]+)\]/g;
    
    renumbered = renumbered.replace(citationGroupPattern, (match, innerContent) =&gt; {
        const indices = innerContent.split(&apos;,&apos;).map((s: string) =&gt; parseInt(s.trim(), 10));
        
        const newIndices = indices
            .filter((idx: number) =&gt; validSourceIndices.has(idx))
            .map((idx: number) =&gt; indexMap.get(idx))
            .filter((idx: number | undefined): idx is number =&gt; idx !== undefined)
            .sort((a: number, b: number) =&gt; a - b);
            
        if (newIndices.length === 0) return &apos;&apos;;
        
        return `[${newIndices.join(&apos;, &apos;)}]`;
    });

    // Clean up punctuation spacing
    renumbered = renumbered.replace(/ +([.,;:!])/g, &apos;$1&apos;);
    
    console.log(&apos;=== CITATION RENUMBERING DEBUG END ===\n&apos;);

    return renumbered.trim();
  }

  /**
   * Format simplified citations for display
   */
  formatSimplifiedCitationsForDisplay(citations: SimplifiedCitation[]): string {
    if (citations.length === 0) {
      return &apos;&apos;;
    }

    const sources = citations.map((citation, index) =&gt; {
      return `${index + 1}. ${citation.document}. Page ${citation.page}`;
    });

    return &apos;\n\n**Vancouver Style References:**\n&apos; + sources.join(&apos;\n&apos;);
  }

  /**
   * Convert simplified citations to message citation format for storage
   */
  convertSimplifiedToMessageCitations(citations: SimplifiedCitation[]): MessageCitation[] {
    return citations.map((citation, index) =&gt; ({
      document: citation.document,
      page: citation.page,
      excerpt: citation.combinedContent,
      // Store additional metadata for debugging
      chunkIds: citation.chunkIds,
      similarity: citation.similarity
    }));
  }
}

// Singleton instance
export const citationService = new CitationService();</file><file path="src/store/chatStore.ts">import { create } from &apos;zustand&apos;;
import { devtools, persist } from &apos;zustand/middleware&apos;;
import type { ChatStore } from &apos;./types&apos;;
import { Message, MessageSender } from &apos;@/types/message&apos;;
import { getIndexedDBServices } from &apos;../services/indexedDB&apos;;
import { chatPipeline } from &apos;../services/rag/chatPipeline&apos;;
import { useSessionStore } from &apos;./sessionStore&apos;;
import { userIdLogger } from &apos;../utils/userIdDebugLogger&apos;;

// Helper function to get services (client-side only)
const getMessageService = () =&gt; {
  if (typeof window !== &apos;undefined&apos;) {
    const services = getIndexedDBServices();
    return services.messageService;
  }
  return null;
};

export const useChatStore = create&lt;ChatStore&gt;()(
  devtools(
    persist(
      (set, get) =&gt; ({
        // State
        messages: [],
        isStreaming: false,
        streamingContent: &apos;&apos;,
        streamingCitations: [],
        error: null,
        isLoading: false,
        isReadingSources: false,
        progressPercentage: 0,
        currentProgressStep: &apos;&apos;,
        
        // Actions
        loadMessages: async (sessionId: string) =&gt; {
          const { userId: currentUserId } = useSessionStore.getState();
          const operationId = userIdLogger.logOperationStart(&apos;ChatStore&apos;, &apos;loadMessages&apos;, currentUserId);
          
          try {
            const messageService = getMessageService();
            if (!messageService) {
              throw new Error(&apos;Message service not available&apos;);
            }
            
            // Get session to verify ownership and get userId
            const services = getIndexedDBServices();
            
            userIdLogger.logServiceCall(&apos;ChatStore&apos;, &apos;sessionService&apos;, &apos;getSession&apos;, currentUserId);
            const session = await services.sessionService.getSession(sessionId, currentUserId || undefined);
            if (!session) {
              throw new Error(&apos;Session not found&apos;);
            }
            
            userIdLogger.logServiceCall(&apos;ChatStore&apos;, &apos;messageService&apos;, &apos;getMessagesBySession&apos;, session.userId);
            const messages = await messageService.getMessagesBySession(sessionId, session.userId);
            
            userIdLogger.logOperationEnd(&apos;ChatStore&apos;, operationId, currentUserId);
            set({ messages });
          } catch (error) {
            userIdLogger.logError(&apos;ChatStore.loadMessages&apos;, error instanceof Error ? error : String(error), currentUserId);
            set({
              error: error instanceof Error ? error.message : &apos;Failed to load messages&apos;,
            });
          }
        },
        
        sendMessage: async (sessionId: string, content: string) =&gt; {
          const { userId: currentUserId } = useSessionStore.getState();
          const operationId = userIdLogger.logOperationStart(&apos;ChatStore&apos;, &apos;sendMessage&apos;, currentUserId);
          
          const userMessage: Message = {
            id: crypto.randomUUID(),
            content,
            role: MessageSender.USER,
            timestamp: new Date(),
            sessionId,
          };
          
          set(state =&gt; ({
            messages: [...state.messages, userMessage],
            error: null,
            isStreaming: false, // Don&apos;t show streaming content
            isReadingSources: true, // Show &quot;Reading sources&quot; instead
            progressPercentage: 0,
            currentProgressStep: &apos;Query Rewriting&apos;,
          }));
          
          try {
            const messageService = getMessageService();
            if (!messageService) {
              throw new Error(&apos;Message service not available&apos;);
            }
            
            // Save user message to IndexedDB
            userIdLogger.logServiceCall(&apos;ChatStore&apos;, &apos;messageService&apos;, &apos;createMessage&apos;, currentUserId);
            await messageService.createMessage(userMessage);
            
            // Use the actual chat pipeline to generate response
            // Pass the already created userMessage to avoid duplication
            await chatPipeline.sendMessage(
              sessionId,
              content,
              (event) =&gt; {
                if (event.type === &apos;status&apos;) {
                  // Update progress based on status message
                  console.log(&apos;Chat status:&apos;, event.message);
                  const { setProgressState } = get();
                  
                  switch (event.message) {
                    case &apos;Query Rewriting&apos;:
                      setProgressState(25, &apos;Query Rewriting&apos;);
                      break;
                    case &apos;Embedding Generation&apos;:
                      setProgressState(50, &apos;Embedding Generation&apos;);
                      break;
                    case &apos;Vector Search&apos;:
                      setProgressState(75, &apos;Vector Search&apos;);
                      break;
                    case &apos;Response Generation&apos;:
                      setProgressState(90, &apos;Response Generation&apos;);
                      break;
                    case &apos;Response Formatting&apos;:
                      setProgressState(95, &apos;Response Formatting&apos;);
                      break;
                    default:
                      // For other status messages, don&apos;t update progress
                      break;
                  }
                } else if (event.type === &apos;done&apos;) {
                  // Reload messages to get the final response
                  // Get session to verify ownership and get userId
                  const services = getIndexedDBServices();
                  // Get userId from sessionStore
                  const { userId: finalUserId } = useSessionStore.getState();
                  
                  userIdLogger.logServiceCall(&apos;ChatStore&apos;, &apos;sessionService&apos;, &apos;getSession (done callback)&apos;, finalUserId);
                  services.sessionService.getSession(sessionId, finalUserId || undefined).then(session =&gt; {
                    if (session) {
                      userIdLogger.logServiceCall(&apos;ChatStore&apos;, &apos;messageService&apos;, &apos;getMessagesBySession (done callback)&apos;, session.userId);
                      messageService.getMessagesBySession(sessionId, session.userId).then(messages =&gt; {
                        userIdLogger.logOperationEnd(&apos;ChatStore&apos;, operationId, finalUserId);
                          const { setProgressState } = get();
                          setProgressState(100, &apos;Complete&apos;);
                          
                          set({
                            messages,
                            isStreaming: false,
                            streamingContent: &apos;&apos;,
                            streamingCitations: [],
                            isReadingSources: false,
                          });
                      });
                    }
                  });
                } else if (event.type === &apos;error&apos;) {
                  userIdLogger.logError(&apos;ChatStore.sendMessage (pipeline error)&apos;, event.message || &apos;Unknown error&apos;, currentUserId);
                  set({
                    error: event.message || &apos;Failed to generate response&apos;,
                    isStreaming: false,
                    streamingContent: &apos;&apos;,
                    streamingCitations: [],
                    isReadingSources: false,
                    progressPercentage: 0,
                    currentProgressStep: &apos;&apos;,
                  });
                }
              },
              userMessage // Pass the already created userMessage
            );
          } catch (error) {
            userIdLogger.logError(&apos;ChatStore.sendMessage&apos;, error instanceof Error ? error : String(error), currentUserId);
            set({
              error: error instanceof Error ? error.message : &apos;Failed to send message&apos;,
              isStreaming: false,
            });
          }
        },
        
        clearHistory: async (sessionId: string) =&gt; {
          try {
            const messageService = getMessageService();
            if (!messageService) {
              throw new Error(&apos;Message service not available&apos;);
            }
            await messageService.deleteMessagesBySession(sessionId);
            set({ messages: [], error: null });
          } catch (error) {
            set({
              error: error instanceof Error ? error.message : &apos;Failed to clear messages&apos;,
            });
          }
        },
        
        setStreamingState: (isStreaming: boolean, content?: string, citations?: any[]) =&gt; {
          set({
            isStreaming,
            streamingContent: content || &apos;&apos;,
            streamingCitations: citations || [],
          });
        },
        
        addMessage: (message: Message) =&gt; {
          set(state =&gt; ({
            messages: [...state.messages, message],
          }));
        },
        
        setError: (error: string | null) =&gt; {
          set({ error });
        },
        
        setReadingSourcesState: (isReadingSources: boolean) =&gt; {
          set({ isReadingSources });
        },
        
        setProgressState: (percentage: number, step: string) =&gt; {
          set({
            progressPercentage: percentage,
            currentProgressStep: step
          });
        },
      }),
      {
        name: &apos;chat-store&apos;,
        partialize: (state) =&gt; ({
          messages: state.messages,
        }),
      }
    )
  )
);</file><file path="src/app/layout.tsx">import type { Metadata, Viewport } from &apos;next&apos;;
import { Inter } from &apos;next/font/google&apos;;
import Script from &apos;next/script&apos;;
import &apos;../styles/globals.css&apos;;
import &apos;../styles/mobile-touch.css&apos;;
import { AppInitializer } from &apos;./AppInitializer&apos;;
import SubscriptionModal from &apos;@/components/SubscriptionModal&apos;;
import { RouteErrorBoundary } from &apos;@/components/common/RouteErrorBoundary&apos;;
import { InstallPrompt } from &apos;@/components/common/InstallPrompt&apos;;

const inter = Inter({ subsets: [&apos;latin&apos;] });

export const metadata: Metadata = {
  title: &apos;Meddy - Chat with Documents Privately&apos;,
  description: &apos;Private RAG chat application for documents&apos;,
  manifest: &apos;/manifest.json&apos;,
  icons: {
    icon: [
      { url: &apos;/favicon-32.png&apos;, sizes: &apos;32x32&apos;, type: &apos;image/png&apos; },
      { url: &apos;/icon-192x192.png&apos;, sizes: &apos;192x192&apos;, type: &apos;image/png&apos; },
      { url: &apos;/icon-512x512.png&apos;, sizes: &apos;512x512&apos;, type: &apos;image/png&apos; },
    ],
    apple: [
      { url: &apos;/icon-192x192.png&apos;, sizes: &apos;192x192&apos;, type: &apos;image/png&apos; },
    ],
  },
};

export const viewport: Viewport = {
  width: &apos;device-width&apos;,
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  themeColor: &apos;#020617&apos;,
  viewportFit: &apos;cover&apos;,
  interactiveWidget: &apos;resizes-content&apos;,
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    &lt;html lang=&quot;en&quot; className=&quot;dark&quot;&gt;
      &lt;body className={`${inter.className} bg-slate-950 text-slate-200 antialiased`}&gt;
        &lt;Script
          id=&quot;error-suppression&quot;
          strategy=&quot;beforeInteractive&quot;
          src=&quot;/error-suppression.js&quot;
        /&gt;
        &lt;RouteErrorBoundary&gt;
          &lt;div id=&quot;root&quot; className=&quot;min-h-screen flex flex-col&quot;&gt;
            &lt;AppInitializer /&gt;
            &lt;SubscriptionModal /&gt;
            &lt;InstallPrompt /&gt;
            {children}
          &lt;/div&gt;
        &lt;/RouteErrorBoundary&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</file><file path="src/services/rag/documentProcessor.ts">import { calculateVectorNorm } from &apos;@/utils/vectorUtils&apos;;
import type { Document } from &apos;@/types/document&apos;;
import type { EmbeddingChunk, EmbeddingGenerationProgress } from &apos;@/types/embedding&apos;;
import type { PreprocessedPackage, PreprocessedChunk } from &apos;@/types/preprocessed&apos;;
import { embeddingService } from &apos;../gemini&apos;;
import { getIndexedDBServices } from &apos;../indexedDB&apos;;
import { packageValidator } from &apos;./packageValidator&apos;;
import { metadataExtractor } from &apos;./metadataExtractor&apos;;
import { ingestionErrorHandler } from &apos;./errorHandler&apos;;
import { progressTracker, createDocumentIngestionOperation, type ProgressOperation } from &apos;./progressTracker&apos;;
import { useDocumentStore } from &apos;@/store&apos;;

export class DocumentProcessor {
  private embeddingService = getIndexedDBServices().embeddingService;

  /**
   * Check if a document with the given filename already exists in the session
   * Returns the existing document if found, undefined otherwise
   */
  async checkForDuplicateByFilename(
    sessionId: string,
    filename: string,
    userId: string
  ): Promise&lt;Document | undefined&gt; {
    console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Checking for duplicate filename &quot;${filename}&quot; in session &quot;${sessionId}&quot;`);
    console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Timestamp: ${new Date().toISOString()}`);
    console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: User ID: ${userId}`);
    
    if (!sessionId || !filename || !userId) {
      console.log(&apos;üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Missing required parameters&apos;);
      return undefined;
    }

    try {
      const { documentService } = getIndexedDBServices();
      
      // Check for exact filename match
      console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Checking exact filename match`);
      let existingDoc = await documentService.getDocumentByFilename(sessionId, filename, userId);
      if (existingDoc) {
        console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Found exact filename match:`, {
          id: existingDoc.id,
          filename: existingDoc.filename,
          title: existingDoc.title,
          status: existingDoc.status
        });
        return existingDoc;
      }
      
      // Get all documents in the session for manual checking
      console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: No exact match found, checking all documents in session`);
      const allDocs = await documentService.getDocumentsBySession(sessionId, userId);
      console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Found ${allDocs.length} documents in session`);
      
      // Log all documents for debugging
      console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: All documents in session:`, allDocs.map(doc =&gt; ({
        id: doc.id,
        filename: doc.filename,
        title: doc.title,
        status: doc.status,
        enabled: doc.enabled
      })));
      
      // Check for case-insensitive filename match
      console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Checking case-insensitive filename match`);
      const caseInsensitiveMatch = allDocs.find(doc =&gt;
        doc.filename.toLowerCase() === filename.toLowerCase()
      );
      if (caseInsensitiveMatch) {
        console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Found case-insensitive filename match:`, {
          id: caseInsensitiveMatch.id,
          filename: caseInsensitiveMatch.filename,
          title: caseInsensitiveMatch.title,
          status: caseInsensitiveMatch.status
        });
        return caseInsensitiveMatch;
      }
      
      // Check for filename match against title (in case title was set to filename)
      console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Checking filename vs title match`);
      const titleMatch = allDocs.find(doc =&gt;
        doc.title === filename || doc.title?.toLowerCase() === filename.toLowerCase()
      );
      if (titleMatch) {
        console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: Found title match:`, {
          id: titleMatch.id,
          filename: titleMatch.filename,
          title: titleMatch.title,
          status: titleMatch.status
        });
        return titleMatch;
      }
      
      console.log(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK: No duplicate found for filename &quot;${filename}&quot;`);
      return undefined;
    } catch (error) {
      console.error(`üîç DOCUMENT PROCESSOR DUPLICATE CHECK ERROR: Error checking for duplicates:`, error);
      return undefined;
    }
  }

  async processDocument(
    document: Document,
    onProgress?: (progress: EmbeddingGenerationProgress) =&gt; void
  ): Promise&lt;void&gt; {
    try {
      // Check if document is already processed
      const existingEmbeddings = await this.embeddingService.getEmbeddingsByDocument(document.id);
      if (existingEmbeddings.length &gt; 0) {
        return; // Already processed
      }

      // Read and parse document content
      const content = await this.readDocumentContent(document);

      // Extract metadata from content if not already present
      if (!document.title || !document.language) {
        onProgress?.({
          totalChunks: 0,
          processedChunks: 0,
          currentChunk: &apos;Extracting metadata...&apos;,
          isComplete: false,
        });

        const metadataResult = await metadataExtractor.extractFromContent(content, document.filename);

        if (metadataResult.success) {
          const documentService = getIndexedDBServices().documentService;
          const metadataUpdate = metadataExtractor.applyToDocument(document, metadataResult.metadata);
          // Get session to retrieve userId for ownership verification
          const sessionService = getIndexedDBServices().sessionService;
          const session = await sessionService.getSession(document.sessionId, document.userId);
          await documentService.updateDocument(document.id, metadataUpdate, session?.userId);

          // Update document object with new metadata
          Object.assign(document, metadataUpdate);

          // Log warnings
          if (metadataResult.warnings.length &gt; 0) {
            console.warn(&apos;Content metadata extraction warnings:&apos;, metadataResult.warnings);
          }
        }
      }

      const chunks = await this.chunkDocument(content, document);

      // Update progress
      onProgress?.({
        totalChunks: chunks.length,
        processedChunks: 0,
        currentChunk: &apos;Starting processing...&apos;,
        isComplete: false,
      });

      // Generate embeddings for chunks
      const embeddingChunks: EmbeddingChunk[] = [];

      for (let i = 0; i &lt; chunks.length; i++) {
        const chunk = chunks[i];

        onProgress?.({
          totalChunks: chunks.length,
          processedChunks: i,
          currentChunk: chunk.text.substring(0, 50) + &apos;...&apos;,
          isComplete: false,
        });

        try {
          const embedding = await embeddingService.generateEmbedding(chunk.text);

          const embeddingChunk: EmbeddingChunk = {
            id: chunk.id,
            documentId: document.id,
            sessionId: document.sessionId,
            chunkIndex: i,
            content: chunk.text,
            source: document.filename,
            page: chunk.metadata?.pageNumber,
            embedding,
            tokenCount: this.estimateTokenCount(chunk.text),
            embeddingNorm: 0, // Will be calculated in embeddingService
            metadata: {
              pageNumber: chunk.metadata?.pageNumber,
              pageNumbers: chunk.metadata?.pageNumbers || (chunk.metadata?.pageNumber ? [chunk.metadata.pageNumber] : undefined),
              chunkIndex: i,
              startPosition: chunk.metadata?.startPosition || 0,
              endPosition: chunk.metadata?.endPosition || chunk.text.length,
              tokenCount: this.estimateTokenCount(chunk.text),
              // Add document metadata to chunk for better search context
              documentTitle: document.title,
              documentAuthor: document.author,
              documentLanguage: document.language,
            },
            createdAt: new Date(),
          };

          embeddingChunks.push(embeddingChunk);
        } catch (error) {
          console.error(`Error processing chunk ${i}:`, error);
          // Continue with next chunk
        }
      }

      // Save embeddings to database with idempotent behavior
      await this.embeddingService.createEmbeddingsIdempotent(embeddingChunks.map(chunk =&gt; ({
        documentId: chunk.documentId,
        sessionId: chunk.sessionId,
        content: chunk.content,
        embedding: chunk.embedding,
        metadata: chunk.metadata
      })));

      // Update document status
      const documentService = getIndexedDBServices().documentService;
      // Get session to retrieve userId for ownership verification
      const sessionService = getIndexedDBServices().sessionService;
      const session = await sessionService.getSession(document.sessionId, document.userId);
      await documentService.updateDocument(document.id, {
        status: &apos;completed&apos;,
        processedAt: new Date(),
      }, session?.userId);

      // Update the document store to reflect the status change
      const documentStore = useDocumentStore.getState();
      await documentStore.loadDocuments(document.sessionId);

      // Final progress update
      onProgress?.({
        totalChunks: chunks.length,
        processedChunks: chunks.length,
        currentChunk: &apos;Processing complete&apos;,
        isComplete: true,
      });
    } catch (error) {
      console.error(&apos;Error processing document:&apos;, error);

      // CRITICAL FIX: Check if embeddings were actually saved before marking as failed
      let embeddingsWereSaved = false;
      try {
        const existingEmbeddings = await this.embeddingService.getEmbeddingsByDocument(document.id);
        embeddingsWereSaved = existingEmbeddings.length &gt; 0;

        console.log(&apos;üîç EMBEDDING VERIFICATION DEBUG (processDocument):&apos;, {
          documentId: document.id,
          embeddingsFound: existingEmbeddings.length,
          embeddingsWereSaved
        });
      } catch (verificationError) {
        console.error(&apos;Error verifying embeddings in processDocument:&apos;, verificationError);
      }

      // Only mark as failed if core processing (embedding generation and saving) actually failed
      if (!embeddingsWereSaved) {
        console.log(&apos;üî¥ MARKING AS FAILED: No embeddings were saved, marking document as failed&apos;);
        const documentService = getIndexedDBServices().documentService;
        // Get session to retrieve userId for ownership verification
        const sessionService = getIndexedDBServices().sessionService;
        const session = await sessionService.getSession(document.sessionId, document.userId);
        await documentService.updateDocument(document.id, {
          status: &apos;failed&apos;,
          ingestError: error instanceof Error ? error.message : &apos;Unknown error&apos;,
        }, session?.userId);

        throw error;
      } else {
        console.log(&apos;‚úÖ EMBEDDINGS SAVED: Core processing succeeded, keeping document as completed despite error&apos;);
        // Don&apos;t mark as failed if embeddings were saved - the core processing succeeded
        // Just log the error but don&apos;t change the status or throw
      }
    }
  }

  async processPreprocessedPackage(
    sessionId: string,
    packageData: PreprocessedPackage,
    userId: string,
    onProgress?: (progress: EmbeddingGenerationProgress) =&gt; void
  ): Promise&lt;string&gt; {
    console.log(&apos;üöÄ DocumentProcessor: Starting preprocessed package processing&apos;);

    // Early validation of userId
    if (!userId) {
      const errorMsg = &apos;User ID is required for document processing&apos;;
      console.error(&apos;‚ùå DocumentProcessor: userId validation failed:&apos;, errorMsg);
      throw new Error(errorMsg);
    }

    console.log(&apos;üìã DocumentProcessor: Package info:&apos;, {
      sessionId,
      userId,
      formatVersion: packageData.format_version,
      documentId: packageData.document_metadata?.id,
      filename: packageData.document_metadata?.filename,
      chunksCount: packageData.chunks?.length || 0
    });

    // Create progress tracking operation
    const operation = createDocumentIngestionOperation({
      sessionId,
      documentId: packageData.document_metadata.id,
      fileName: packageData.document_metadata.filename,
      totalChunks: packageData.chunks.length
    });

    try {
      console.log(&apos;‚úÖ DocumentProcessor: Starting progress tracking operation:&apos;, operation.id);
      // Start operation
      progressTracker.startOperation(operation.id);

      // Add validation step
      const validationStep = progressTracker.addStep(operation.id, {
        name: &apos;validation&apos;,
        description: &apos;Validating package format and contents&apos;,
      });

      progressTracker.startStep(operation.id, validationStep.id);

      // Validate package first
      onProgress?.({
        totalChunks: 0,
        processedChunks: 0,
        currentChunk: &apos;Validating package...&apos;,
        isComplete: false,
      });

      console.log(&apos;üîç DocumentProcessor: Validating package structure...&apos;);
      const validation = await packageValidator.validatePackage(packageData);
      console.log(&apos;üìä DocumentProcessor: Validation result:&apos;, {
        isValid: validation.isValid,
        errorsCount: validation.errors.length,
        warningsCount: validation.warnings.length,
        errors: validation.errors,
        warnings: validation.warnings
      });

      if (!validation.isValid) {
        console.error(&apos;‚ùå DocumentProcessor: Package validation failed&apos;);
        progressTracker.failStep(operation.id, validationStep.id, validation.errors.join(&apos;, &apos;));
        const validationErrorResult = ingestionErrorHandler.handlePackageValidationError(
          new Error(validation.errors.join(&apos;, &apos;)),
          packageData,
          { operation: &apos;package_validation&apos;, sessionId, filename: packageData.document_metadata.filename }
        );

        const errorMessage = ingestionErrorHandler.createUserFriendlyMessage(validationErrorResult.errors);
        console.error(&apos;‚ùå DocumentProcessor: Validation error message:&apos;, errorMessage);
        progressTracker.failOperation(operation.id, errorMessage);
        throw new Error(errorMessage);
      }

      console.log(&apos;‚úÖ DocumentProcessor: Package validation passed&apos;);
      progressTracker.completeStep(operation.id, validationStep.id, { warnings: validation.warnings });

      // Log warnings if any
      if (validation.warnings.length &gt; 0) {
        console.warn(&apos;‚ö†Ô∏è DocumentProcessor: Package validation warnings:&apos;, validation.warnings);
      }

      // Add metadata extraction step
      const metadataStep = progressTracker.addStep(operation.id, {
        name: &apos;metadata_extraction&apos;,
        description: &apos;Extracting comprehensive metadata from document&apos;,
      });

      progressTracker.startStep(operation.id, metadataStep.id);

      // Extract comprehensive metadata
      onProgress?.({
        totalChunks: 0,
        processedChunks: 0,
        currentChunk: &apos;Extracting metadata...&apos;,
        isComplete: false,
      });

      let metadataResult;
      try {
        metadataResult = await metadataExtractor.extractFromPreprocessedPackage(packageData);

        if (!metadataResult.success) {
          const metadataErrorResult = ingestionErrorHandler.handleDocumentProcessingError(
            new Error(metadataResult.errors.join(&apos;, &apos;)),
            { id: packageData.document_metadata.id, sessionId, filename: packageData.document_metadata.filename } as Document,
            { operation: &apos;metadata_extraction&apos;, sessionId, documentId: packageData.document_metadata.id }
          );

          // Continue with basic metadata if extraction fails
          console.warn(&apos;Metadata extraction failed, continuing with basic metadata:&apos;, metadataErrorResult.errors);
          progressTracker.completeStep(operation.id, metadataStep.id, {
            warnings: metadataErrorResult.errors,
            fallbackUsed: true
          });
        } else {
          // Log metadata warnings
          if (metadataResult.warnings.length &gt; 0) {
            console.warn(&apos;Metadata extraction warnings:&apos;, metadataResult.warnings);
          }

          progressTracker.completeStep(operation.id, metadataStep.id, {
            warnings: metadataResult.warnings,
            metadata: metadataResult.metadata
          });
        }
      } catch (error) {
        const metadataErrorResult = ingestionErrorHandler.handleDocumentProcessingError(
          error,
          { id: packageData.document_metadata.id, sessionId, filename: packageData.document_metadata.filename } as Document,
          { operation: &apos;metadata_extraction&apos;, sessionId, documentId: packageData.document_metadata.id }
        );

        // Continue with basic metadata
        console.warn(&apos;Metadata extraction failed, continuing with basic metadata:&apos;, metadataErrorResult.errors);
        metadataResult = { success: false, metadata: {}, warnings: [], errors: [] };

        progressTracker.completeStep(operation.id, metadataStep.id, {
          warnings: metadataErrorResult.errors,
          fallbackUsed: true
        });
      }

      // Add document creation/update step
      const documentStep = progressTracker.addStep(operation.id, {
        name: &apos;document_creation&apos;,
        description: &apos;Creating or updating document record&apos;,
      });

      progressTracker.startStep(operation.id, documentStep.id);

      // Create or update document with extracted metadata
      const documentService = getIndexedDBServices().documentService;
      const packageDocId = packageData.document_metadata.id;

      console.log(&apos;üîç DOCUMENT ID DEBUG: Package document ID:&apos;, packageDocId);
      console.log(&apos;üîç SESSION ID DEBUG: Current session ID from URL:&apos;, sessionId);
      console.log(&apos;üîç SESSION ID DEBUG: Session ID from package metadata:&apos;, packageData.export_metadata?.session_id);
      console.log(&apos;üîç DUPLICATE DEBUG: Starting document creation process at:&apos;, new Date().toISOString());
      console.log(&apos;üîç DUPLICATE DEBUG: About to check for existing documents in IndexedDB&apos;);

      // Always use the current session ID, not the one from package metadata
      // This ensures documents are associated with the current session
      const currentSessionId = sessionId;

      // Get session to retrieve userId for ownership verification
      const sessionService = getIndexedDBServices().sessionService;
      const session = await sessionService.getSession(currentSessionId, userId);

      // CRITICAL FIX: Check if document exists across ALL sessions, not just the current one
      let document = await documentService.getDocument(packageDocId, session?.userId);
      let actualDocId: string;
      let needsNewId = false;

      console.log(&apos;üîç DOCUMENT ID DEBUG: Checking for existing document in current session:&apos;, !!document);
      console.log(&apos;üîç DUPLICATE DEBUG: Document check result at:&apos;, new Date().toISOString(), {
        documentId: packageDocId,
        foundInCurrentSession: !!document,
        sessionId: sessionId,
        userId: session?.userId
      });

      // If document doesn&apos;t exist in current session, check if it exists in any session
      if (!document) {
        const existingDocAcrossSessions = await documentService.getDocumentAcrossAllSessions(packageDocId);
        console.log(&apos;üîç DOCUMENT ID DEBUG: Checking for existing document across all sessions:&apos;, !!existingDocAcrossSessions);

        if (existingDocAcrossSessions) {
          console.log(&apos;üîç DOCUMENT ID DEBUG: Document exists in another session:&apos;, {
            id: existingDocAcrossSessions.id,
            filename: existingDocAcrossSessions.filename,
            existingSessionId: existingDocAcrossSessions.sessionId,
            currentSessionId: currentSessionId
          });
          needsNewId = true;
        }
      }

      if (document) {
        console.log(&apos;üîç DOCUMENT ID DEBUG: Existing document details:&apos;, {
          id: document.id,
          filename: document.filename,
          status: document.status,
          enabled: document.enabled,
          sessionId: document.sessionId
        });

        // CRITICAL FIX: Update existing document to ensure it&apos;s associated with the current session
        // This fixes the session ID mismatch issue
        const metadataUpdate = {
          ...metadataExtractor.applyToDocument(document, metadataResult.metadata),
          sessionId: currentSessionId // Force update to current session ID
        };

        console.log(&apos;üîç SESSION ID DEBUG: Updating existing document with session ID:&apos;, currentSessionId);
        await documentService.updateDocument(packageDocId, metadataUpdate, session?.userId);
        actualDocId = packageDocId;
        console.log(&apos;üîç DOCUMENT ID DEBUG: Updated existing document with ID:&apos;, actualDocId);
        progressTracker.updateStepProgress(operation.id, documentStep.id, 50, {
          action: &apos;updated_existing_document&apos;,
          sessionIdUpdated: document.sessionId !== currentSessionId
        });
      } else {
        // Generate a new ID if the document exists in another session to avoid conflicts
        const finalDocId = needsNewId ? crypto.randomUUID() : packageDocId;

        console.log(&apos;üîç DOCUMENT ID DEBUG: Creating new document&apos;, {
          originalPackageId: packageDocId,
          needsNewId,
          finalDocId
        });

        // Create new document with extracted metadata
        // CRITICAL FIX: Always use the current session ID, not the one from package metadata
        const documentCreate = {
          id: finalDocId, // Use new ID if needed to avoid conflicts
          sessionId: currentSessionId, // Always use the current session ID
          filename: packageData.document_metadata.filename,
          fileSize: packageData.document_metadata.file_size,
          pageCount: packageData.document_metadata.page_count,
          title: metadataResult.metadata.title,
          author: metadataResult.metadata.author,
          language: metadataResult.metadata.language,
        };

        console.log(&apos;üîç DOCUMENT ID DEBUG: Document create data:&apos;, documentCreate);
        console.log(&apos;üîç SESSION ID DEBUG: Session ID in documentCreate:&apos;, currentSessionId);
        console.log(&apos;üîç SESSION ID DEBUG: Session ID from packageData (ignored):&apos;, packageData.export_metadata?.session_id);

        // Get session to retrieve userId
        const sessionService = getIndexedDBServices().sessionService;
        const session = await sessionService.getSession(currentSessionId, userId);
        if (!session) {
          throw new Error(`Session not found: ${currentSessionId}`);
        }

        // CRITICAL FIX: Check for duplicates before creating document
        console.log(&apos;üîç DUPLICATE PREVENTION: Checking for duplicates before document creation&apos;);
        const duplicateDoc = await this.checkForDuplicateByFilename(
          currentSessionId,
          packageData.document_metadata.filename,
          session.userId
        );
        
        if (duplicateDoc) {
          console.log(&apos;üîç DUPLICATE PREVENTION: Found duplicate document, throwing error to prevent creation&apos;);
          const duplicateError = new Error(
            `Document &quot;${packageData.document_metadata.filename}&quot; already exists in this library. Skipping duplicate.`
          );
          // Mark as a special duplicate error that can be handled differently
          (duplicateError as any).isDuplicate = true;
          (duplicateError as any).duplicateDocumentId = duplicateDoc.id;
          throw duplicateError;
        }

        console.log(&apos;üîç DUPLICATE PREVENTION: No duplicates found, proceeding with document creation&apos;);
        document = await documentService.createDocument(documentCreate, session.userId);

        console.log(&apos;üîç DOCUMENT ID DEBUG: Created document with sessionId:&apos;, document.sessionId);
        console.log(&apos;üîç DUPLICATE DEBUG: Document created in IndexedDB at:&apos;, new Date().toISOString());
        actualDocId = document.id;
        console.log(&apos;üîç DOCUMENT ID DEBUG: Created new document with ID:&apos;, actualDocId);
        console.log(&apos;üîç DOCUMENT ID DEBUG: Created document details:&apos;, {
          id: document.id,
          filename: document.filename,
          status: document.status,
          enabled: document.enabled,
          sessionId: document.sessionId,
          createdAt: document.createdAt
        });
        console.log(&apos;üîç DUPLICATE DEBUG: Document now available for duplicate checking in IndexedDB&apos;);

        // Validate the document was created with the correct session ID
        if (document.sessionId !== currentSessionId) {
          console.error(&apos;üî¥ SESSION ID MISMATCH: Document created with wrong session ID!&apos;, {
            expected: currentSessionId,
            actual: document.sessionId
          });
        } else {
          console.log(&apos;‚úÖ SESSION ID VERIFIED: Document created with correct session ID&apos;);
        }

        progressTracker.updateStepProgress(operation.id, documentStep.id, 50, {
          action: needsNewId ? &apos;created_new_document_with_new_id&apos; : &apos;created_new_document&apos;,
          sessionIdVerified: document.sessionId === currentSessionId,
          originalPackageId: packageDocId,
          newDocumentId: finalDocId,
          idGenerated: needsNewId
        });
      }

      progressTracker.completeStep(operation.id, documentStep.id, { documentId: actualDocId });

      // Add chunk processing step
      const chunkStep = progressTracker.addStep(operation.id, {
        name: &apos;chunk_processing&apos;,
        description: &apos;Processing document chunks and embeddings&apos;,
      });

      progressTracker.startStep(operation.id, chunkStep.id);

      // Get chunks directly from package (new format)
      const chunks: PreprocessedChunk[] = packageData.chunks;

      onProgress?.({
        totalChunks: chunks.length,
        processedChunks: 0,
        currentChunk: &apos;Starting import...&apos;,
        isComplete: false,
      });

      // Process chunks in batches to avoid memory pressure and blocking the main thread
      const BATCH_SIZE = 200;
      let processedCount = 0;
      const totalChunks = chunks.length;

      // Initial progress update
      onProgress?.({
        totalChunks,
        processedChunks: 0,
        currentChunk: &apos;Starting import...&apos;,
        isComplete: false,
      });

      for (let i = 0; i &lt; totalChunks; i += BATCH_SIZE) {
        const batch = chunks.slice(i, i + BATCH_SIZE);
        const embeddingChunks: EmbeddingChunk[] = [];

        // Process batch
        for (let j = 0; j &lt; batch.length; j++) {
          const chunk = batch[j];
          const globalIndex = i + j;

          try {
            // CRITICAL FIX: Generate new chunk ID if we generated a new document ID to avoid conflicts
            const chunkId = needsNewId ? `chunk_${actualDocId}_${globalIndex}` : chunk.id;

            // Calculate norm directly to avoid overhead later
            const embeddingVector = new Float32Array(chunk.embedding);
            const norm = calculateVectorNorm(embeddingVector);

            // Convert preprocessed chunk to embedding chunk directly
            const embeddingChunk: EmbeddingChunk = {
              id: chunkId,
              documentId: actualDocId,
              sessionId,
              chunkIndex: chunk.metadata?.chunk_index || globalIndex,
              content: chunk.text,
              source: chunk.metadata?.source || packageData.document_metadata.filename,
              page: chunk.metadata?.page || 1,
              embedding: embeddingVector,
              tokenCount: this.estimateTokenCount(chunk.text),
              embeddingNorm: norm,
              metadata: {
                pageNumber: chunk.metadata?.page || 1,
                pageNumbers: chunk.metadata?.pageNumbers || (chunk.metadata?.page ? [chunk.metadata.page] : undefined),
                chunkIndex: chunk.metadata?.chunk_index || globalIndex,
                startPosition: 0,
                endPosition: chunk.text.length,
                tokenCount: this.estimateTokenCount(chunk.text),
                documentId: actualDocId,
                sessionId: sessionId,
                source: chunk.metadata?.source || packageData.document_metadata.filename,
                // Add extracted metadata to chunk metadata for better search context
                documentTitle: metadataResult.metadata.title,
                documentAuthor: metadataResult.metadata.author,
                documentLanguage: metadataResult.metadata.language,
                embeddingModel: metadataResult.metadata.embeddingModel,
                embeddingNorm: norm, // Include norm in metadata as well
              },
              createdAt: new Date(),
            };

            embeddingChunks.push(embeddingChunk);
          } catch (error) {
            console.error(`Error processing chunk ${globalIndex}:`, error);
          }
        }

        // Save batch directly to database
        if (embeddingChunks.length &gt; 0) {
          // CRITICAL FIX: Ensure all embeddings use the correct session ID
          const validatedBatch = embeddingChunks.map(chunk =&gt; {
            if (chunk.sessionId !== sessionId) {
              return {
                ...chunk,
                sessionId: sessionId,
                metadata: { ...chunk.metadata, sessionId: sessionId }
              };
            }
            return chunk;
          });

          // Use direct insertion to skip redundant validation/mapping
          await this.embeddingService.addEmbeddingsDirectly(validatedBatch);
        }

        processedCount += batch.length;

        // Update progress (throttled naturally by batch size)
        onProgress?.({
          totalChunks,
          processedChunks: Math.min(processedCount, totalChunks),
          currentChunk: batch[0].text.substring(0, 50) + &apos;...&apos;,
          isComplete: false,
        });

        const progressPercent = (processedCount / totalChunks) * 100;
        progressTracker.updateStepProgress(operation.id, chunkStep.id, progressPercent, {
          processedChunks: processedCount,
          totalChunks,
          currentChunkId: batch[batch.length - 1].id
        });

        // Yield to main thread to keep UI responsive
        await new Promise(resolve =&gt; setTimeout(resolve, 0));
      }

      progressTracker.completeStep(operation.id, chunkStep.id, {
        totalChunks: totalChunks,
        processedChunks: processedCount,
        successfulChunks: processedCount // Assuming all processed chunks were successful
      });

      console.log(&apos;üîç EMBEDDING STORAGE DEBUG: Embeddings saved successfully with correct session ID&apos;);

      // Update document status to completed
      try {
        console.log(&apos;üîç DOCUMENT STATUS DEBUG: üöÄ Starting document status update to completed&apos;);
        console.log(&apos;üîç DOCUMENT STATUS DEBUG: Document ID:&apos;, actualDocId);
        console.log(&apos;üîç SESSION ID DEBUG: Session ID for document update:&apos;, sessionId);
        console.log(&apos;üîç TIMESTAMP DEBUG: Status update started at:&apos;, new Date().toISOString());

        const timestamp = new Date();
        console.log(&apos;üîç TIMESTAMP DEBUG: Status update started at:&apos;, timestamp.toISOString());

        // Verify document exists before update
        const docBeforeUpdate = await documentService.getDocument(actualDocId);
        console.log(&apos;üîç DOCUMENT STATUS DEBUG: Document before update:&apos;, docBeforeUpdate);

        if (!docBeforeUpdate) {
          throw new Error(`Document not found before status update: ${actualDocId}`);
        }

        // Verify embeddings were actually saved
        const embeddingsCount = await this.embeddingService.getEmbeddingCountByDocument(actualDocId);
        console.log(&apos;üîç EMBEDDING VERIFICATION DEBUG: Embeddings before status update:&apos;, {
          documentId: actualDocId,
          embeddingsCount,
          hasEmbeddings: embeddingsCount &gt; 0
        });

        if (embeddingsCount === 0) {
          throw new Error(`No embeddings found for document ${actualDocId} after processing`);
        }

        console.log(&apos;‚úÖ EMBEDDINGS VERIFIED: Updating document status to completed&apos;);

        await documentService.updateDocumentStatus(actualDocId, &apos;completed&apos;);
        console.log(&apos;üîç DOCUMENT STATUS DEBUG: Document status updated in database&apos;);

        // Verify update
        const docAfterUpdate = await documentService.getDocument(actualDocId);
        console.log(&apos;üîç DOCUMENT STATUS DEBUG: Document after update:&apos;, docAfterUpdate);

        if (docAfterUpdate?.sessionId !== sessionId) {
          console.error(&apos;üî¥ SESSION ID MISMATCH after update:&apos;, {
            expected: sessionId,
            actual: docAfterUpdate?.sessionId
          });
          // Attempt to fix
          await documentService.updateDocument(actualDocId, { sessionId });
          console.log(&apos;‚úÖ SESSION ID FIXED: Document updated with correct session ID&apos;);
        } else {
          console.log(&apos;‚úÖ SESSION ID VERIFIED: Document updated with correct session ID&apos;);
        }

        // Force refresh of document store
        console.log(&apos;üîç DOCUMENT STORE DEBUG: Refreshing document store after status update&apos;);
        console.log(&apos;üîç SESSION ID DEBUG: Session ID for document store refresh:&apos;, sessionId);

        // Use the store&apos;s loadDocuments action to refresh the list
        // We need to access the store instance directly or dispatch an event
        // Since we can&apos;t use hooks here, we&apos;ll use the store&apos;s getState() method if available
        // or rely on the UI to refresh when it detects the change

        // Try to trigger a refresh via the store
        try {
          const store = useDocumentStore.getState();
          if (store &amp;&amp; store.loadDocuments) {
            console.log(&apos;üîç DOCUMENT STORE DEBUG: Starting loadDocuments for session:&apos;, sessionId);
            // Pass the userId if available from the session
            // We need to get the session first to get the userId
            const sessionService = getIndexedDBServices().sessionService;
            const session = await sessionService.getSession(sessionId);

            await store.loadDocuments(sessionId);
            console.log(&apos;üîç DOCUMENT STORE DEBUG: Document store refreshed&apos;);

            // Verify store state
            const updatedDocs = store.documents;
            console.log(&apos;üîç DOCUMENT STORE DEBUG: Documents in store after refresh:&apos;, updatedDocs.length);
          }
        } catch (storeError) {
          console.warn(&apos;‚ö†Ô∏è DOCUMENT STORE DEBUG: Failed to trigger store refresh:&apos;, storeError);
        }

        const endTime = new Date();
        console.log(&apos;üîç TIMESTAMP DEBUG: Status update completed at:&apos;, endTime.toISOString());

      } catch (error) {
        console.error(&apos;üî¥ DOCUMENT STATUS DEBUG: Error updating document status:&apos;, error);
        throw error;
      }

      onProgress?.({
        totalChunks: chunks.length,
        processedChunks: chunks.length,
        currentChunk: &apos;Import complete&apos;,
        isComplete: true,
      });

      // Complete operation
      progressTracker.completeOperation(operation.id, {
        documentId: actualDocId,
        totalChunks: chunks.length,
        processedChunks: processedCount,
        metadata: metadataResult.metadata
      });

      console.log(&apos;üéâ DocumentProcessor: Package processing completed successfully&apos;);
      return operation.id;
    } catch (error) {
      console.error(&apos;üí• DocumentProcessor: Error processing preprocessed package:&apos;, error);
      console.error(&apos;üí• DocumentProcessor: Error details:&apos;, {
        name: error instanceof Error ? error.name : &apos;Unknown&apos;,
        message: error instanceof Error ? error.message : &apos;Unknown error&apos;,
        stack: error instanceof Error ? error.stack : &apos;No stack trace&apos;,
        sessionId,
        packageId: packageData.document_metadata?.id
      });

      // CRITICAL FIX: Check if embeddings were actually saved before marking as failed
      let embeddingsWereSaved = false;
      let actualDocumentId = packageData?.document_metadata?.id;

      if (packageData?.document_metadata?.id) {
        try {
          const embeddingService = getIndexedDBServices().embeddingService;
          const documentService = getIndexedDBServices().documentService;
          const sessionService = getIndexedDBServices().sessionService;
          const session = await sessionService.getSession(sessionId, userId);

          // Check if document exists in current session or across all sessions
          let document = await documentService.getDocument(packageData.document_metadata.id, session?.userId);
          if (!document) {
            document = await documentService.getDocumentAcrossAllSessions(packageData.document_metadata.id);
          }

          if (document) {
            actualDocumentId = document.id;
            // Check if embeddings exist for this document
            const existingEmbeddings = await embeddingService.getEmbeddingsByDocument(document.id);
            embeddingsWereSaved = existingEmbeddings.length &gt; 0;

            console.log(&apos;üîç EMBEDDING VERIFICATION DEBUG:&apos;, {
              documentId: document.id,
              embeddingsFound: existingEmbeddings.length,
              embeddingsWereSaved,
              documentStatus: document.status
            });
          }
        } catch (verificationError) {
          console.error(&apos;Error verifying embeddings:&apos;, verificationError);
        }
      }

      // Only mark as failed if core processing (embedding generation and saving) actually failed
      if (!embeddingsWereSaved &amp;&amp; actualDocumentId) {
        console.log(&apos;üî¥ MARKING AS FAILED: No embeddings were saved, marking document as failed&apos;);
        const documentService = getIndexedDBServices().documentService;
        try {
          // Get session to retrieve userId for ownership verification
          const sessionService = getIndexedDBServices().sessionService;
          const session = await sessionService.getSession(sessionId, userId);
          await documentService.updateDocument(actualDocumentId, {
            status: &apos;failed&apos;,
            ingestError: error instanceof Error ? error.message : &apos;Unknown error&apos;,
          }, session?.userId);
        } catch (updateError) {
          const updateErrorResult = ingestionErrorHandler.handleStorageError(
            updateError,
            &apos;updateDocument&apos;,
            { operation: &apos;storage&apos;, sessionId, documentId: actualDocumentId }
          );

          console.error(&apos;Failed to update document status to failed:&apos;, updateErrorResult.errors);
        }
      } else if (embeddingsWereSaved) {
        console.log(&apos;‚úÖ EMBEDDINGS SAVED: Core processing succeeded, keeping document as completed despite error&apos;);
        // Don&apos;t mark as failed if embeddings were saved - the core processing succeeded
        // Just log the error but don&apos;t change the status
      }

      // Handle the main error with user-friendly message
      const mainErrorResult = ingestionErrorHandler.handleDocumentProcessingError(
        error,
        { id: actualDocumentId, sessionId, filename: packageData.document_metadata.filename } as Document,
        { operation: &apos;document_processing&apos;, sessionId, documentId: actualDocumentId }
      );

      const errorMessage = ingestionErrorHandler.createUserFriendlyMessage(mainErrorResult.errors);
      progressTracker.failOperation(operation.id, errorMessage);

      // Only throw the error if core processing failed
      if (!embeddingsWereSaved) {
        throw new Error(errorMessage);
      } else {
        // If embeddings were saved, don&apos;t throw - the document is actually processed successfully
        console.log(&apos;üéâ CORE PROCESSING SUCCEEDED: Document processed successfully despite secondary error&apos;);
        return operation.id;
      }
    }
  }

  private async readDocumentContent(document: Document): Promise&lt;string&gt; {
    // This is a simplified implementation
    // In a real app, you&apos;d need to handle different file types
    try {
      if (document.storedPath) {
        // For files stored in IndexedDB or local storage
        return await this.readFileFromStorage(document.storedPath);
      } else if (document.originalPath) {
        // For uploaded files
        return await this.readFileFromUpload(document.originalPath);
      } else {
        // Return empty string or throw error based on requirements
        return &apos;&apos;;
      }
    } catch (error) {
      console.error(&apos;Error reading document content:&apos;, error);
      throw new Error(&apos;Failed to read document content&apos;);
    }
  }

  private async readFileFromStorage(path: string): Promise&lt;string&gt; {
    // Implementation depends on how files are stored
    // This is a placeholder
    return &apos;Document content placeholder&apos;;
  }

  private async readFileFromUpload(path: string): Promise&lt;string&gt; {
    // Implementation for uploaded files
    // This is a placeholder
    return &apos;Document content placeholder&apos;;
  }

  private async chunkDocument(
    content: string,
    document: Document
  ): Promise&lt;Array&lt;{ id: string; text: string; metadata?: any }&gt;&gt; {
    const chunkSize = 1000; // Default chunk size
    const chunkOverlap = 200; // Default overlap
    const chunks: Array&lt;{ id: string; text: string; metadata?: any }&gt; = [];

    let currentPosition = 0;
    let chunkIndex = 0;

    while (currentPosition &lt; content.length) {
      const endPosition = Math.min(
        currentPosition + chunkSize,
        content.length
      );

      const chunkText = content.substring(currentPosition, endPosition);

      chunks.push({
        id: `chunk_${document.id}_${chunkIndex}`,
        text: chunkText,
        metadata: {
          pageNumber: 1, // TODO: Extract actual page numbers
          startPosition: currentPosition,
          endPosition,
          chunkIndex,
        },
      });

      currentPosition = endPosition - chunkOverlap;
      chunkIndex++;
    }

    return chunks;
  }

  private estimateTokenCount(text: string): number {
    // Rough estimation: ~4 characters per token
    return Math.ceil(text.length / 4);
  }

  async validateDocument(document: Document): Promise&lt;boolean&gt; {
    try {
      // Check if document exists and is accessible
      const content = await this.readDocumentContent(document);

      // Basic validation
      if (!content || content.trim().length === 0) {
        return false;
      }

      // Check for reasonable size
      if (content.length &gt; 10_000_000) { // 10MB limit
        return false;
      }

      return true;
    } catch (error) {
      console.error(&apos;Error validating document:&apos;, error);
      return false;
    }
  }

  async extractMetadata(content: string): Promise&lt;any&gt; {
    // Simple metadata extraction
    const lines = content.split(&apos;\n&apos;);
    const metadata: any = {};

    // Try to extract title from first few lines
    for (let i = 0; i &lt; Math.min(10, lines.length); i++) {
      const line = lines[i].trim();
      if (line.length &gt; 0 &amp;&amp; line.length &lt; 200) {
        metadata.title = line;
        break;
      }
    }

    // Extract word count
    metadata.wordCount = content.split(/\s+/).length;

    // Extract character count
    metadata.characterCount = content.length;

    // Estimate reading time (200 words per minute)
    metadata.readingTimeMinutes = Math.ceil(metadata.wordCount / 200);

    return metadata;
  }
}

// Singleton instance
export const documentProcessor = new DocumentProcessor();</file><file path="src/app/login/page.tsx">&apos;use client&apos;;

import { createClient } from &apos;@/utils/supabase/client&apos;;
import { useState, useEffect, Suspense } from &apos;react&apos;;
import { useSearchParams } from &apos;next/navigation&apos;;

function LoginContent() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const searchParams = useSearchParams();
  const supabase = createClient();

  useEffect(() =&gt; {
    // Handle error messages returned from Supabase redirects
    const errorMsg = searchParams.get(&apos;error_description&apos;) || searchParams.get(&apos;error&apos;);
    if (errorMsg) {
      setError(errorMsg);
    }
  }, [searchParams]);

  const handleGoogleLogin = async () =&gt; {
    setIsLoading(true);
    setError(null);

    try {
      // Get the URL to redirect to after login (if the user was kicked here by middleware)
      const next = searchParams.get(&apos;redirectedFrom&apos;) || &apos;/&apos;;
      
      const { error } = await supabase.auth.signInWithOAuth({
        provider: &apos;google&apos;,
        options: {
          // Redirect to our callback route, passing the &apos;next&apos; destination
          redirectTo: `${window.location.origin}/auth/callback?next=${encodeURIComponent(next)}`,
          queryParams: {
            access_type: &apos;offline&apos;,
            prompt: &apos;consent&apos;,
          },
        },
      });

      if (error) throw error;
    } catch (err: any) {
      setError(err.message);
      setIsLoading(false);
    }
  };

  return (
    &lt;div className=&quot;flex min-h-screen flex-col items-center justify-center bg-slate-950 px-6 py-12 lg:px-8&quot;&gt;
      &lt;div className=&quot;sm:mx-auto sm:w-full sm:max-w-md&quot;&gt;
        &lt;div className=&quot;flex flex-col items-center justify-center text-center&quot;&gt;
          &lt;div className=&quot;h-16 w-16 bg-blue-600 rounded-2xl flex items-center justify-center mb-6 shadow-lg shadow-blue-900/20&quot;&gt;
            &lt;svg
              className=&quot;h-10 w-10 text-white&quot;
              fill=&quot;none&quot;
              viewBox=&quot;0 0 24 24&quot;
              stroke=&quot;currentColor&quot;
            &gt;
              &lt;path
                strokeLinecap=&quot;round&quot;
                strokeLinejoin=&quot;round&quot;
                strokeWidth={2}
                d=&quot;M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253&quot;
              /&gt;
            &lt;/svg&gt;
          &lt;/div&gt;
          
          &lt;h2 className=&quot;text-3xl font-bold tracking-tight text-white&quot;&gt;
            Welcome to Meddy
          &lt;/h2&gt;
          &lt;p className=&quot;mt-2 text-sm text-slate-400&quot;&gt;
            Your private RAG medical assistant
          &lt;/p&gt;
        &lt;/div&gt;

        &lt;div className=&quot;mt-10 sm:mx-auto sm:w-full sm:max-w-[400px]&quot;&gt;
          &lt;div className=&quot;bg-slate-900 px-6 py-12 shadow-xl rounded-xl border border-slate-800 sm:px-10&quot;&gt;
            &lt;div className=&quot;space-y-6&quot;&gt;
              &lt;div&gt;
                &lt;button
                  onClick={handleGoogleLogin}
                  disabled={isLoading}
                  className=&quot;flex w-full items-center justify-center gap-3 rounded-lg bg-white px-3 py-3 text-sm font-semibold text-gray-900 shadow-sm hover:bg-gray-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white transition-all disabled:opacity-70 disabled:cursor-not-allowed&quot;
                &gt;
                  {isLoading ? (
                    &lt;div className=&quot;h-5 w-5 border-2 border-gray-900 border-t-transparent rounded-full animate-spin&quot; /&gt;
                  ) : (
                    &lt;svg className=&quot;h-5 w-5&quot; viewBox=&quot;0 0 24 24&quot; aria-hidden=&quot;true&quot;&gt;
                      &lt;path
                        d=&quot;M12.0003 20.45C16.667 20.45 20.5855 17.2721 20.5855 12.3053C20.5855 11.6601 20.5288 11.034 20.4198 10.4286H12.0003V13.8631H16.8143C16.6062 14.9877 15.9736 15.9529 15.0289 16.5862L17.9152 18.8267C19.6047 17.2709 20.5855 14.9786 20.5855 12.3053Z&quot;
                        fill=&quot;#4285F4&quot;
                      /&gt;
                      &lt;path
                        d=&quot;M12.0001 20.45C14.3164 20.45 16.2629 19.6826 17.915 18.8267L15.0287 16.5862C14.2604 17.1013 13.2751 17.4072 12.0001 17.4072C9.76451 17.4072 7.87197 15.8973 7.19572 13.8633H4.21313V16.1776C5.87979 19.4935 9.27851 20.45 12.0001 20.45Z&quot;
                        fill=&quot;#34A853&quot;
                      /&gt;
                      &lt;path
                        d=&quot;M7.19559 13.8633C7.02353 13.3481 6.92987 12.8005 6.92987 12.2361C6.92987 11.6717 7.02353 11.1241 7.19559 10.6089V8.29462H4.213C3.60759 9.5005 3.2666 10.8354 3.2666 12.2361C3.2666 13.6369 3.60759 14.9718 4.213 16.1776L7.19559 13.8633Z&quot;
                        fill=&quot;#FBBC05&quot;
                      /&gt;
                      &lt;path
                        d=&quot;M12.0001 7.06517C13.2604 7.06517 14.4001 7.49894 15.2895 8.3496L17.969 5.67004C16.3475 4.15939 14.3562 3.75 12.0001 3.75C9.27851 3.75 5.87979 4.70656 4.21313 8.02246L7.19572 10.3367C7.87197 8.30263 9.76451 7.06517 12.0001 7.06517Z&quot;
                        fill=&quot;#EA4335&quot;
                      /&gt;
                    &lt;/svg&gt;
                  )}
                  &lt;span className=&quot;text-base&quot;&gt;Sign in with Google&lt;/span&gt;
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            {error &amp;&amp; (
              &lt;div className=&quot;mt-6 rounded-md bg-red-900/30 border border-red-900 p-4&quot;&gt;
                &lt;div className=&quot;flex&quot;&gt;
                  &lt;div className=&quot;flex-shrink-0&quot;&gt;
                    &lt;svg className=&quot;h-5 w-5 text-red-400&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;&gt;
                      &lt;path fillRule=&quot;evenodd&quot; d=&quot;M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z&quot; clipRule=&quot;evenodd&quot; /&gt;
                    &lt;/svg&gt;
                  &lt;/div&gt;
                  &lt;div className=&quot;ml-3&quot;&gt;
                    &lt;h3 className=&quot;text-sm font-medium text-red-200&quot;&gt;Authentication Error&lt;/h3&gt;
                    &lt;div className=&quot;mt-1 text-sm text-red-300&quot;&gt;{error}&lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            )}
          &lt;/div&gt;
          
          &lt;p className=&quot;mt-8 text-center text-xs text-slate-500&quot;&gt;
            By signing in, you agree to our Terms of Service and Privacy Policy
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Simple loading fallback component
function LoginLoadingFallback() {
  return (
    &lt;div className=&quot;flex min-h-screen flex-col items-center justify-center bg-slate-950 px-6 py-12 lg:px-8&quot;&gt;
      &lt;div className=&quot;sm:mx-auto sm:w-full sm:max-w-md&quot;&gt;
        &lt;div className=&quot;flex flex-col items-center justify-center text-center&quot;&gt;
          &lt;div className=&quot;h-16 w-16 bg-blue-600 rounded-2xl flex items-center justify-center mb-6 shadow-lg shadow-blue-900/20&quot;&gt;
            &lt;div className=&quot;h-10 w-10 border-2 border-white border-t-transparent rounded-full animate-spin&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
          &lt;h2 className=&quot;text-3xl font-bold tracking-tight text-white&quot;&gt;
            Welcome to Meddy
          &lt;/h2&gt;
          &lt;p className=&quot;mt-2 text-sm text-slate-400&quot;&gt;
            Your private RAG medical assistant
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default function LoginPage() {
  return (
    &lt;Suspense fallback={&lt;LoginLoadingFallback /&gt;}&gt;
      &lt;LoginContent /&gt;
    &lt;/Suspense&gt;
  );
}</file><file path="src/app/session/[id]/page.tsx">&apos;use client&apos;;

import React, { useEffect, useState, useRef } from &apos;react&apos;;

export const dynamic = &apos;force-dynamic&apos;;
import { useParams, useRouter } from &apos;next/navigation&apos;;
import { useSessionStore, useChatStore, useDocumentStore, useSettingsStore } from &apos;../../../store&apos;;
import { TabBar, ChatTabs } from &apos;../../../components/layout&apos;;
import { ChatList, MessageInput, PhrasePills } from &apos;../../../components/chat&apos;;
import { DocumentList, JsonUpload, DocumentLibrary } from &apos;../../../components/document&apos;;
import { Button, DropdownMenu, DropdownMenuItem } from &apos;../../../components/ui&apos;;
import { Loading } from &apos;../../../components/ui&apos;;
import { EmptyState } from &apos;../../../components/common&apos;;
import { Header } from &apos;../../../components/layout&apos;;
import { documentProcessor } from &apos;../../../services/rag&apos;;
import { useRouteErrorHandler } from &apos;../../../components/common/RouteErrorBoundary&apos;;

export default function SessionPage() {
  const params = useParams();
  const router = useRouter();
  const { handleRouteError, safeNavigate } = useRouteErrorHandler();
  const sessionId = params.id as string;

  // Validate session ID format
  useEffect(() =&gt; {
    if (!sessionId) {
      handleRouteError(new Error(&apos;Session ID is missing&apos;), &apos;Session page load&apos;);
      safeNavigate(&apos;/&apos;, &apos;Invalid session ID&apos;);
      return;
    }

    // Basic validation for session ID format (UUID or similar)
    const validIdPattern = /^[a-zA-Z0-9\-_]{10,}$/;
    if (!validIdPattern.test(sessionId)) {
      console.error(&apos;üîç [SESSION_PAGE] Invalid session ID format:&apos;, sessionId);
      handleRouteError(new Error(`Invalid session ID format: ${sessionId}`), &apos;Session ID validation&apos;);
      safeNavigate(&apos;/&apos;, &apos;Invalid session ID format&apos;);
      return;
    }

    console.log(&apos;üîç [SESSION_PAGE] Loading session with valid ID:&apos;, sessionId);
  }, [sessionId, handleRouteError, safeNavigate]);

  const {
    currentSession,
    setCurrentSessionId,
    deleteSession,
    isLoading: sessionLoading,
  } = useSessionStore();

  const {
    messages,
    isLoading: messagesLoading,
    sendMessage,
    clearHistory,
    isStreaming,
  } = useChatStore();

  const {
    documents,
    loadDocuments,
    isUploading: documentsLoading,
  } = useDocumentStore();

  const { settings } = useSettingsStore();
  const { userId } = useSessionStore();

  const [activeTab, setActiveTab] = useState(&apos;chat&apos;);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [isLibraryOpen, setIsLibraryOpen] = useState(false);
  const [messageInput, setMessageInput] = useState(&apos;&apos;);
  const messageInputRef = useRef&lt;HTMLTextAreaElement&gt;(null);

  // Load session data on mount (client-side only)
  useEffect(() =&gt; {
    if (typeof window !== &apos;undefined&apos; &amp;&amp; sessionId) {
      setCurrentSessionId(sessionId);
      loadDocuments(sessionId);
    }
  }, [sessionId, setCurrentSessionId, loadDocuments]);

  // Redirect if session not found (client-side only)
  useEffect(() =&gt; {
    if (typeof window !== &apos;undefined&apos; &amp;&amp; !sessionLoading &amp;&amp; !currentSession) {
      router.push(&apos;/&apos;);
    }
  }, [currentSession, sessionLoading, router]);

  const handleSendMessage = async (content: string) =&gt; {
    if (!sessionId) return;

    try {
      await sendMessage(sessionId, content);
      setMessageInput(&apos;&apos;); // Clear the input after sending
    } catch (error) {
      console.error(&apos;Failed to send message:&apos;, error);
    }
  };

  const handlePhraseSelect = (phrase: string) =&gt; {
    // Append the selected phrase to the current message input with an extra space
    const newMessage = messageInput ? `${messageInput} ${phrase} ` : `${phrase} `;
    setMessageInput(newMessage);

    // Focus the input field and position cursor at the end
    requestAnimationFrame(() =&gt; {
      if (messageInputRef.current) {
        messageInputRef.current.focus();
        const length = messageInputRef.current.value.length;
        messageInputRef.current.setSelectionRange(length, length);
      }
    });
  };

  const handleDeleteSession = async () =&gt; {
    if (!sessionId) return;

    try {
      await deleteSession(sessionId);
      router.push(&apos;/&apos;);
    } catch (error) {
      console.error(&apos;Failed to delete session:&apos;, error);
    }
  };

  const handleClearHistory = async () =&gt; {
    if (!sessionId) return;

    try {
      await clearHistory(sessionId);
    } catch (error) {
      console.error(&apos;Failed to clear history:&apos;, error);
    }
  };


  if (sessionLoading) {
    return (
      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900&quot;&gt;
        &lt;Header /&gt;
        &lt;div className=&quot;flex justify-center items-center h-64&quot;&gt;
          &lt;Loading size=&quot;lg&quot; text=&quot;Loading session...&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  if (!currentSession) {
    return (
      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900&quot;&gt;
        &lt;Header /&gt;
        &lt;div className=&quot;container mx-auto px-4 py-8&quot;&gt;
          &lt;EmptyState
            title=&quot;Session not found&quot;
            description=&quot;The session you&apos;re looking for doesn&apos;t exist or has been deleted.&quot;
            action={
              &lt;Button onClick={() =&gt; router.push(&apos;/&apos;)}&gt;
                Go Back Home
              &lt;/Button&gt;
            }
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col&quot;&gt;
      {/* Sticky Header */}
      &lt;div className=&quot;sticky top-0 z-40 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700&quot;&gt;
        &lt;Header
          title={currentSession.name}
          actions={null} // Remove actions from header, moving to tab bar
        /&gt;
      &lt;/div&gt;

      {/* Sticky Tab Navigation */}
      &lt;div className=&quot;sticky top-14 sm:top-16 z-30 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700&quot;&gt;
        &lt;div className=&quot;container mx-auto px-3 sm:px-4&quot;&gt;
          &lt;TabBar
            tabs={ChatTabs.ChatDocuments}
            activeTab={activeTab}
            onTabChange={setActiveTab}
            variant=&quot;underline&quot;
            actions={
              &lt;DropdownMenu
                trigger={
                  &lt;Button variant=&quot;ghost&quot; size=&quot;sm&quot; className=&quot;p-2&quot;&gt;
                    &lt;svg
                      className=&quot;h-4 w-4 sm:h-5 sm:w-5 text-gray-700 dark:text-gray-200&quot;
                      fill=&quot;none&quot;
                      viewBox=&quot;0 0 24 24&quot;
                      stroke=&quot;currentColor&quot;
                    &gt;
                      &lt;path
                        strokeLinecap=&quot;round&quot;
                        strokeLinejoin=&quot;round&quot;
                        strokeWidth={2}
                        d=&quot;M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z&quot;
                      /&gt;
                    &lt;/svg&gt;
                  &lt;/Button&gt;
                }
              &gt;
                &lt;DropdownMenuItem onClick={handleClearHistory} disabled={messages.length === 0}&gt;
                  Clear History
                &lt;/DropdownMenuItem&gt;
                &lt;DropdownMenuItem
                  onClick={() =&gt; setIsDeleteDialogOpen(true)}
                  variant=&quot;danger&quot;
                &gt;
                  Delete Session
                &lt;/DropdownMenuItem&gt;
              &lt;/DropdownMenu&gt;
            }
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Tab Content */}
      &lt;div className=&quot;flex-1 container mx-auto px-4 pt-6 pb-0 overflow-hidden flex flex-col&quot;&gt;
        {activeTab === &apos;chat&apos; &amp;&amp; (
          &lt;div className=&quot;flex-1 flex flex-col min-h-0&quot;&gt;
            {messages.length === 0 &amp;&amp; !messagesLoading ? (
              // This wrapper controls the layout to ensure input stays at bottom
              &lt;div className=&quot;flex flex-col flex-1 min-h-0&quot;&gt;
                {/* This wrapper grows to fill all available space */}
                &lt;div className=&quot;flex-1 flex items-center justify-center&quot;&gt;
                  {documents.length === 0 ? (
                    &lt;EmptyState
                      title=&quot;No books added, Add books to chat ü•≥&quot;
                      description=&quot;&quot;
                      icon={
                        &lt;div className=&quot;text-4xl mb-2&quot;&gt;üìö&lt;/div&gt;
                      }
                      action={
                        &lt;Button
                          onClick={() =&gt; setActiveTab(&apos;documents&apos;)}
                          variant=&quot;primary&quot;
                          size=&quot;lg&quot;
                        &gt;
                          ADD BOOKS
                        &lt;/Button&gt;
                      }
                    /&gt;
                  ) : (
                    &lt;EmptyState
                      title=&quot;Start a conversation&quot;
                      description=&quot;Ask a question about your documents to get started&quot;
                      icon={
                        &lt;svg
                          className=&quot;w-12 h-12 text-gray-400&quot;
                          fill=&quot;none&quot;
                          viewBox=&quot;0 0 24 24&quot;
                          stroke=&quot;currentColor&quot;
                        &gt;
                          &lt;path
                            strokeLinecap=&quot;round&quot;
                            strokeLinejoin=&quot;round&quot;
                            strokeWidth={2}
                            d=&quot;M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z&quot;
                          /&gt;
                        &lt;/svg&gt;
                      }
                    /&gt;
                  )}
                &lt;/div&gt;

                {/* API Key Configuration Button */}
                {!settings?.geminiApiKey &amp;&amp; (
                  &lt;div className=&quot;flex-shrink-0 mt-4 max-w-4xl mx-auto w-full&quot;&gt;
                    &lt;Button
                      onClick={() =&gt; router.push(&apos;/settings&apos;)}
                      variant=&quot;primary&quot;
                      className=&quot;w-full&quot;
                    &gt;
                      Set API Key First
                    &lt;/Button&gt;
                  &lt;/div&gt;
                )}

                {/* Phrase Pills */}
                &lt;div className=&quot;flex-shrink-0 mt-4 max-w-4xl mx-auto w-full&quot;&gt;
                  &lt;PhrasePills
                    onPhraseSelect={handlePhraseSelect}
                    className=&quot;bg-gray-100 dark:bg-gray-800 rounded-lg&quot;
                  /&gt;
                &lt;/div&gt;

                {/* Add Books Button when no documents are available */}
                {documents.length === 0 &amp;&amp; (
                  &lt;div className=&quot;flex-shrink-0 mt-4 max-w-4xl mx-auto w-full&quot;&gt;
                    &lt;Button
                      onClick={() =&gt; setActiveTab(&apos;documents&apos;)}
                      variant=&quot;primary&quot;
                      className=&quot;w-full&quot;
                    &gt;
                      Add Books First
                    &lt;/Button&gt;
                  &lt;/div&gt;
                )}

                {/* Message Input is now properly positioned at the bottom */}
                &lt;div className=&quot;flex-shrink-0 mt-4 max-w-4xl mx-auto w-full&quot;&gt;
                  &lt;MessageInput
                    sessionId={sessionId}
                    disabled={isStreaming || !settings?.geminiApiKey || documents.length === 0}
                    placeholder={
                      !settings?.geminiApiKey
                        ? &apos;Please configure your API key in settings&apos;
                        : documents.length === 0
                        ? &apos;Please add a Book first to chat&apos;
                        : &apos;Ask a question about your documents...&apos;
                    }
                    value={messageInput}
                    onChange={setMessageInput}
                    inputRef={messageInputRef}
                  /&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ) : (
              &lt;&gt;
                &lt;div className=&quot;flex-1 overflow-y-auto min-h-0&quot;&gt;
                  &lt;ChatList
                    sessionId={sessionId}
                    className=&quot;max-w-4xl mx-auto&quot;
                  /&gt;
                &lt;/div&gt;

                {/* API Key Configuration Button */}
                {!settings?.geminiApiKey &amp;&amp; (
                  &lt;div className=&quot;flex-shrink-0 mt-4 max-w-4xl mx-auto w-full&quot;&gt;
                    &lt;Button
                      onClick={() =&gt; router.push(&apos;/settings&apos;)}
                      variant=&quot;primary&quot;
                      className=&quot;w-full&quot;
                    &gt;
                      Set API Key First
                    &lt;/Button&gt;
                  &lt;/div&gt;
                )}

                {/* Add Books Button when no documents are available */}
                {documents.length === 0 &amp;&amp; (
                  &lt;div className=&quot;flex-shrink-0 mt-4 max-w-4xl mx-auto w-full&quot;&gt;
                    &lt;Button
                      onClick={() =&gt; setActiveTab(&apos;documents&apos;)}
                      variant=&quot;primary&quot;
                      className=&quot;w-full&quot;
                    &gt;
                      Add Books First
                    &lt;/Button&gt;
                  &lt;/div&gt;
                )}

                {/* Phrase Pills */}
                &lt;div className=&quot;flex-shrink-0 mt-4 max-w-4xl mx-auto w-full&quot;&gt;
                  &lt;PhrasePills
                    onPhraseSelect={handlePhraseSelect}
                    className=&quot;bg-gray-100 dark:bg-gray-800 rounded-lg&quot;
                  /&gt;
                &lt;/div&gt;

                {/* Message Input */}
                &lt;div className=&quot;flex-shrink-0 mt-4 max-w-4xl mx-auto w-full&quot;&gt;
                  &lt;MessageInput
                    sessionId={sessionId}
                    disabled={isStreaming || !settings?.geminiApiKey || documents.length === 0}
                    placeholder={
                      !settings?.geminiApiKey
                        ? &apos;Please configure your API key in settings&apos;
                        : documents.length === 0
                        ? &apos;Please add a Book first to chat&apos;
                        : &apos;Ask a question about your documents...&apos;
                    }
                    value={messageInput}
                    onChange={setMessageInput}
                    inputRef={messageInputRef}
                  /&gt;
                &lt;/div&gt;
              &lt;/&gt;
            )}
          &lt;/div&gt;
        )}

        {activeTab === &apos;documents&apos; &amp;&amp; (
          &lt;div className=&quot;max-w-6xl mx-auto flex-1 overflow-y-auto&quot;&gt;
            &lt;div className=&quot;space-y-6 pb-6&quot;&gt;
              &lt;div className=&quot;sticky top-0 bg-gray-50 dark:bg-gray-900 py-6 z-10&quot;&gt;
                &lt;h2 className=&quot;text-lg font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;
                  Documents ({documents.length})
                &lt;/h2&gt;

                &lt;div className=&quot;flex flex-col items-center gap-4 mb-4&quot;&gt;
                  &lt;Button
                    variant=&quot;primary&quot;
                    onClick={() =&gt; setIsLibraryOpen(true)}
                    size=&quot;lg&quot;
                    className=&quot;text-lg px-8 py-3&quot;
                  &gt;
                    &lt;span className=&quot;mr-2&quot;&gt;üè•&lt;/span&gt; Library
                  &lt;/Button&gt;

                  {documents.length &gt; 0 &amp;&amp; (
                    &lt;Button
                      variant=&quot;ghost&quot;
                      onClick={() =&gt; setActiveTab(&apos;chat&apos;)}
                      size=&quot;md&quot;
                      className=&quot;text-sm px-4 py-2 bg-green-400 hover:bg-green-500 dark:bg-green-500 dark:hover:bg-green-600 text-white rounded-full shadow-sm transition-colors duration-200&quot;
                    &gt;
                      &lt;svg
                        className=&quot;w-4 h-4 mr-2&quot;
                        fill=&quot;none&quot;
                        viewBox=&quot;0 0 24 24&quot;
                        stroke=&quot;currentColor&quot;
                      &gt;
                        &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M10 19l-7-7m0 0l7-7m-7 7h18&quot; /&gt;
                      &lt;/svg&gt;
                      Start chatting
                    &lt;/Button&gt;
                  )}

                  &lt;div className=&quot;text-center&quot;&gt;
                    &lt;p className=&quot;text-yellow-500 mb-2&quot;&gt;Can&apos;t find the book in the library?&lt;/p&gt;
                    &lt;p className=&quot;text-yellow-500 mb-4&quot;&gt;No worries! ü•≥&lt;/p&gt;
                    &lt;Button
                      variant=&quot;secondary&quot;
                      onClick={() =&gt; window.open(&apos;https://t.me/prayas_ojha&apos;, &apos;_blank&apos;)}
                      size=&quot;md&quot;
                      className=&quot;text-sm px-4 py-2&quot;
                    &gt;
                      üéâ Request book üéâ
                    &lt;/Button&gt;
                    &lt;p className=&quot;text-yellow-500 mt-4&quot;&gt;We will try to add the resource you want to library ‚ù§Ô∏è&lt;/p&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;

              {documents.length === 0 &amp;&amp; !documentsLoading ? (
                &lt;div className=&quot;text-center py-12&quot;&gt;
                  &lt;p className=&quot;text-gray-500 dark:text-gray-400 text-lg mb-2&quot;&gt;
                    No documents yet!
                  &lt;/p&gt;
                  &lt;p className=&quot;text-yellow-500 text-lg&quot;&gt;
                    Go to the library to add books üéâ
                  &lt;/p&gt;
                &lt;/div&gt;
              ) : (
                &lt;DocumentList
                  documents={documents}
                  loading={documentsLoading}
                  variant=&quot;grid&quot;
                /&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      {/* Delete Confirmation Dialog */}
      {isDeleteDialogOpen &amp;&amp; (
        &lt;div className=&quot;fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4&quot;&gt;
          &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-lg p-4 sm:p-6 max-w-md w-full mx-4&quot;&gt;
            &lt;h3 className=&quot;text-base sm:text-lg font-semibold text-gray-900 dark:text-white mb-3 sm:mb-4&quot;&gt;
              Delete Session
            &lt;/h3&gt;

            &lt;p className=&quot;text-sm sm:text-base text-gray-600 dark:text-gray-300 mb-4 sm:mb-6&quot;&gt;
              Are you sure you want to delete &quot;{currentSession.name}&quot;? This action cannot be undone and will remove all messages and documents.
            &lt;/p&gt;

            &lt;div className=&quot;flex gap-2 sm:gap-3&quot;&gt;
              &lt;Button
                variant=&quot;outline&quot;
                onClick={() =&gt; setIsDeleteDialogOpen(false)}
                className=&quot;flex-1&quot;
              &gt;
                Cancel
              &lt;/Button&gt;

              &lt;Button
                variant=&quot;danger&quot;
                onClick={handleDeleteSession}
                className=&quot;flex-1&quot;
              &gt;
                Delete
              &lt;/Button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {/* Document Library Modal */}
      {isLibraryOpen &amp;&amp; (
        &lt;DocumentLibrary
          sessionId={sessionId}
          onClose={() =&gt; setIsLibraryOpen(false)}
        /&gt;
      )}
    &lt;/div&gt;
  );
}</file><file path="src/app/AppInitializer.tsx">&apos;use client&apos;;

import { useEffect, useState } from &apos;react&apos;;
import { geminiService } from &apos;../services/gemini&apos;;
import { useSettingsStore, useSessionStore, useDocumentStore } from &apos;../store&apos;;
import { createClient } from &apos;../utils/supabase/client&apos;;
import { userIdLogger } from &apos;../utils/userIdDebugLogger&apos;;

export function AppInitializer() {
  const [isClient, setIsClient] = useState(false);

  // Ensure we only run client-side code on the client
  useEffect(() =&gt; {
    setIsClient(true);
  }, []);
  const { settings, loadSettings, setUserId: setSettingsUserId, clearSettings } = useSettingsStore();
  const { loadSessions, setUserId: setSessionUserId, clearSessions } = useSessionStore();
  const { setUserId: setDocumentUserId, clearDocuments } = useDocumentStore();
  const supabase = createClient();

  useEffect(() =&gt; {
    // Only run on client side
    if (!isClient) return;

    // Listen for auth state changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) =&gt; {
      console.log(&apos;[APP INIT]&apos;, &apos;Auth state changed:&apos;, event, session?.user?.id);

      const userId = session?.user?.id || null;

      // Log auth state change
      userIdLogger.logAuthChange(&apos;AppInitializer&apos;, userId, event);

      if (session?.user &amp;&amp; userId) {
        // Set User ID in stores
        userIdLogger.logStoreUpdate(&apos;SettingsStore&apos;, userId, &apos;setUserId&apos;);
        setSettingsUserId(userId);

        userIdLogger.logStoreUpdate(&apos;SessionStore&apos;, userId, &apos;setUserId&apos;);
        setSessionUserId(userId);

        userIdLogger.logStoreUpdate(&apos;DocumentStore&apos;, userId, &apos;setUserId&apos;);
        setDocumentUserId(userId); // Set DocumentStore user ID

        // Load user-specific data
        const settingsOpId = userIdLogger.logOperationStart(&apos;AppInitializer&apos;, &apos;loadSettings&apos;, userId);
        const sessionsOpId = userIdLogger.logOperationStart(&apos;AppInitializer&apos;, &apos;loadSessions&apos;, userId);

        await Promise.all([
          loadSettings(userId).finally(() =&gt; {
            userIdLogger.logOperationEnd(&apos;AppInitializer&apos;, settingsOpId, userId);
          }),
          loadSessions(userId).finally(() =&gt; {
            userIdLogger.logOperationEnd(&apos;AppInitializer&apos;, sessionsOpId, userId);
          })
          // Documents are loaded per session, so we don&apos;t load them here directly
        ]);

        console.log(&apos;[APP INIT]&apos;, &apos;User data loaded for:&apos;, userId);
      } else if (event === &apos;SIGNED_OUT&apos;) {
        // Clear stores on sign out
        userIdLogger.logStoreUpdate(&apos;SettingsStore&apos;, null, &apos;clearSettings&apos;);
        clearSettings();

        userIdLogger.logStoreUpdate(&apos;SessionStore&apos;, null, &apos;clearSessions&apos;);
        clearSessions();

        userIdLogger.logStoreUpdate(&apos;DocumentStore&apos;, null, &apos;clearDocuments&apos;);
        clearDocuments(); // Clear DocumentStore

        console.log(&apos;[APP INIT]&apos;, &apos;User data cleared&apos;);
      }
    });

    // Initial check for session
    const checkSession = async () =&gt; {
      if (!isClient) return;
      const { data: { session } } = await supabase.auth.getSession();
      const userId = session?.user?.id || null;

      if (session?.user &amp;&amp; userId) {
        // userId is already defined above as session?.user?.id || null
        // No need to redeclare it here

        userIdLogger.logAuthChange(&apos;AppInitializer&apos;, userId, &apos;INITIAL_SESSION_CHECK&apos;);

        userIdLogger.logStoreUpdate(&apos;SettingsStore&apos;, userId, &apos;setUserId (initial)&apos;);
        setSettingsUserId(userId);

        userIdLogger.logStoreUpdate(&apos;SessionStore&apos;, userId, &apos;setUserId (initial)&apos;);
        setSessionUserId(userId);

        userIdLogger.logStoreUpdate(&apos;DocumentStore&apos;, userId, &apos;setUserId (initial)&apos;);
        setDocumentUserId(userId); // Set DocumentStore user ID for initial check

        const settingsOpId = userIdLogger.logOperationStart(&apos;AppInitializer&apos;, &apos;loadSettings (initial)&apos;, userId);
        const sessionsOpId = userIdLogger.logOperationStart(&apos;AppInitializer&apos;, &apos;loadSessions (initial)&apos;, userId);

        await Promise.all([
          loadSettings(userId).finally(() =&gt; {
            userIdLogger.logOperationEnd(&apos;AppInitializer&apos;, settingsOpId, userId);
          }),
          loadSessions(userId).finally(() =&gt; {
            userIdLogger.logOperationEnd(&apos;AppInitializer&apos;, sessionsOpId, userId);
          })
        ]);
      } else {
        userIdLogger.logAuthChange(&apos;AppInitializer&apos;, null, &apos;INITIAL_SESSION_CHECK (no session)&apos;);
      }
    };

    checkSession();

    return () =&gt; {
      subscription.unsubscribe();
    };
  }, [loadSettings, loadSessions, setSettingsUserId, setSessionUserId, setDocumentUserId, clearSettings, clearSessions, clearDocuments, isClient, supabase]);

  // Initialize Gemini service when settings change (and API key is available)
  useEffect(() =&gt; {
    if (!isClient) return;

    if (settings?.geminiApiKey) {
      const initializeGemini = async () =&gt; {
        try {
          console.log(&apos;[APP INIT]&apos;, &apos;Initializing Gemini service...&apos;);
          // Use fallback model if settings.model is undefined (for backward compatibility)
          const model = settings.model || &apos;gemini-2.5-flash-lite&apos;;
          await geminiService.initialize(settings.geminiApiKey, model, &apos;text-embedding-004&apos;);
          console.log(&apos;[APP INIT]&apos;, &apos;Gemini service initialized successfully&apos;);
        } catch (error) {
          console.error(&apos;[APP INIT ERROR]&apos;, &apos;Failed to initialize Gemini service:&apos;, error);
        }
      };

      initializeGemini();
    }
  }, [isClient, settings?.geminiApiKey, settings?.model]); // Also update dependency

  // This component doesn&apos;t render anything
  return null;
}</file><file path="src/services/rag/chatPipeline.ts">import { getIndexedDBServices } from &apos;../indexedDB&apos;;
import { chatService, embeddingService } from &apos;../gemini&apos;;
import { vectorSearchService } from &apos;./vectorSearch&apos;;
import { documentProcessor } from &apos;./documentProcessor&apos;;
import { citationService } from &apos;./citationService&apos;;
import { ResponseFormatter } from &apos;./responseFormatter&apos;;
import { MessageSender, type MessageCreate, type Message } from &apos;@/types&apos;;
import type { ChatStreamEvent } from &apos;../gemini/chatService&apos;;
import type { SimplifiedCitationGroup } from &apos;@/types/citation&apos;;

export class ChatPipeline {
  private indexedDBServices = getIndexedDBServices();

  /**
   * Enhance user query with context information
   */
  private async enhanceQueryWithContext(sessionId: string, content: string): Promise&lt;string&gt; {
    try {
      console.log(&apos;\n=== QUERY ENHANCEMENT PROCESS START ===&apos;);
      console.log(&apos;[ORIGINAL QUERY]&apos;, content);

      // Get session information
      const session = await this.indexedDBServices.sessionService.getSession(sessionId);
      const sessionName = session?.name || &apos;Unknown Session&apos;;
      console.log(&apos;[SESSION INFO]&apos;, `Name: ${sessionName}, ID: ${sessionId}`);

      // Get enabled documents for the session
      if (!session) {
        console.log(&apos;[CONTEXT ENHANCEMENT]&apos;, &apos;Session not found - returning original query&apos;);
        console.log(&apos;=== QUERY ENHANCEMENT PROCESS END ===\n&apos;);
        return content;
      }
      const enabledDocuments = await this.indexedDBServices.documentService.getEnabledDocumentsBySession(sessionId, session.userId);
      console.log(&apos;[DOCUMENTS FOUND]&apos;, `${enabledDocuments.length} enabled documents`);

      // Extract document names (use title if available, otherwise filename)
      const documentNames = enabledDocuments.map(doc =&gt; doc.title || doc.filename).filter(Boolean);

      // If no documents are enabled, return the original query
      if (documentNames.length === 0) {
        console.log(&apos;[CONTEXT ENHANCEMENT]&apos;, &apos;No enabled documents found - returning original query&apos;);
        console.log(&apos;=== QUERY ENHANCEMENT PROCESS END ===\n&apos;);
        return content;
      }

      // Format the related documents string
      const relatedDocuments = documentNames.join(&apos;, &apos;);
      console.log(&apos;[CONTEXT DOCUMENTS]&apos;, relatedDocuments);

      // Create the enhanced query with context
      const enhancedQuery = `${content} [Context - ${sessionName} and related to ${relatedDocuments}]`;

      console.log(&apos;[ENHANCED QUERY]&apos;, enhancedQuery);
      console.log(&apos;=== QUERY ENHANCEMENT PROCESS END ===\n&apos;);

      return enhancedQuery;
    } catch (error) {
      console.error(&apos;[CONTEXT ENHANCEMENT ERROR]&apos;, error);
      console.log(&apos;=== QUERY ENHANCEMENT PROCESS END (WITH ERROR) ===\n&apos;);
      // If there&apos;s an error, return the original query
      return content;
    }
  }

  /**
   * Rewrites the user query based on chat history to make it standalone.
   * Solves the &quot;What are its causes?&quot; problem.
   */
  private async generateStandaloneQuery(
    content: string,
    history: any[],
    apiKey: string,
    model: string
  ): Promise&lt;string&gt; {
    // 1. Cost Optimization: If no history, no need to rewrite.
    if (!history || history.length === 0) {
      console.log(&apos;[QUERY REWRITER]&apos;, &apos;Skipping rewrite - No history.&apos;);
      return content;
    }

    // 2. Cost Optimization: Limit history to last 4 messages (2 turns)
    // This keeps input tokens low for the free tier.
    const recentHistory = history.slice(-4).map(msg =&gt;
      `${msg.role === &apos;user&apos; ? &apos;User&apos; : &apos;Assistant&apos;}: ${msg.content}`
    ).join(&apos;\n&apos;);

    const prompt = `
      Task: Rewrite the last user question to be a standalone query based on the conversation history.
      Rules:
      1. Replace pronouns (it, they, this) with specific nouns from history.
      2. Keep the query concise.
      3. If the question is already standalone, return it exactly as is.
      4. Do NOT answer the question.

      Conversation History:
      ${recentHistory}

      Last User Question:
      ${content}

      Standalone Query:
    `;

    try {
      // Use a specialized instance for rewriting to avoid interfering with main chat state
      // We reuse the existing Gemini service structure but make a quick generation call
      const { geminiService } = await import(&apos;../gemini/geminiService&apos;);
      
      // Note: We rely on the service already being initialized in AppInitializer,
      // but we pass options to ensure we use a fast/cheap configuration.
      const rewrittenQuery = await geminiService.generateResponse(
        prompt,
        undefined,
        undefined,
        {
          temperature: 0.1, // Low temperature for deterministic rewriting
          maxTokens: 100,   // Very low output tokens (saves limits)
        }
      );

      const cleanedQuery = rewrittenQuery.trim();
      console.log(&apos;[QUERY REWRITER]&apos;, `Original: &quot;${content}&quot; -&gt; Rewritten: &quot;${cleanedQuery}&quot;`);
      return cleanedQuery;

    } catch (error) {
      console.error(&apos;[QUERY REWRITER ERROR]&apos;, error);
      // Fallback: If API fails (rate limit), use original query so the app doesn&apos;t crash
      return content;
    }
  }

  /**
   * Send a message and get AI response with RAG context
   */
  async sendMessage(
    sessionId: string,
    content: string,
    onStreamEvent?: (event: ChatStreamEvent) =&gt; void,
    userMessage?: MessageCreate
  ): Promise&lt;void&gt; {
    try {
      console.log(&apos;\n=== CHAT PIPELINE PROCESS START ===&apos;);
      console.log(&apos;[USER INPUT]&apos;, `Session: ${sessionId}, Query: &quot;${content}&quot;`);

      // User message is now passed in as a parameter (already saved in chatStore)
      console.log(&apos;[MESSAGE STATUS]&apos;, &apos;User message already stored in database by chatStore&apos;);

      // Update progress: Query Rewriting (25%)
      if (onStreamEvent) {
        onStreamEvent({ type: &apos;status&apos;, message: &apos;Query Rewriting&apos; });
      }
      // Note: We&apos;ll update the store progress in the chatStore&apos;s sendMessage function

      // Get enabled documents for the session
      const sessionForDocuments = await this.indexedDBServices.sessionService.getSession(sessionId);
      if (!sessionForDocuments) {
        throw new Error(&apos;Session not found&apos;);
      }

      // 1. FETCH HISTORY (NEW STEP)
      // We need the history BEFORE we do the search
      console.log(&apos;[HISTORY]&apos;, &apos;Fetching chat history for context awareness...&apos;);
      const history = await this.indexedDBServices.messageService.getMessagesBySession(
        sessionId,
        sessionForDocuments.userId
      );

      // Get Settings for model info
      const settings = await this.indexedDBServices.settingsService.getSettings(sessionForDocuments.userId);
      const apiKey = settings?.geminiApiKey || &apos;&apos;;
      const model = settings?.model || &apos;gemini-2.5-flash-lite&apos;;

      // 2. GENERATE STANDALONE QUERY (NEW STEP)
      // This converts &quot;What are its causes?&quot; -&gt; &quot;What are the causes of cataract?&quot;
      console.log(&apos;[REWRITING]&apos;, &apos;Generating standalone query...&apos;);
      const standaloneQuery = await this.generateStandaloneQuery(content, history, apiKey, model);
      
      // üî¥ PROMINENT LOG: Show the converted query for tracking
      console.log(&apos;üî¥ Converted query -:&apos;, `&quot;${standaloneQuery}&quot;`);
      
      // Update progress: Embedding Generation (50%)
      if (onStreamEvent) {
        onStreamEvent({ type: &apos;status&apos;, message: &apos;Embedding Generation&apos; });
      }
      
      // 3. ENHANCE THE REWRITTEN QUERY, NOT THE ORIGINAL
      // Modify this line to pass &apos;standaloneQuery&apos; instead of &apos;content&apos;
      const enhancedQuery = await this.enhanceQueryWithContext(sessionId, standaloneQuery);
      console.log(&apos;[FINAL SEARCH QUERY]&apos;, enhancedQuery);

      const documents = await this.indexedDBServices.documentService.getDocumentsBySession(sessionId, sessionForDocuments.userId);
      console.log(&apos;[DOCUMENT STATUS]&apos;, `Found ${documents.length} total documents in session ${sessionId}`);
      console.log(&apos;[DOCUMENT STATUS]&apos;, &apos;Document details:&apos;, documents.map(doc =&gt; ({
        id: doc.id,
        filename: doc.filename,
        enabled: doc.enabled,
        status: doc.status
      })));

      const enabledDocuments = documents.filter(doc =&gt; doc.enabled);
      console.log(&apos;[DOCUMENT STATUS]&apos;, `${enabledDocuments.length}/${documents.length} documents enabled`);

      // Also check if there are any embeddings available for enabled documents
      const indexedDBEmbeddingService = this.indexedDBServices.embeddingService;
      let embeddings: any[] = [];

      if (enabledDocuments.length &gt; 0) {
        embeddings = await indexedDBEmbeddingService.getEnabledEmbeddingsBySession(sessionId, sessionForDocuments.userId);
      }

      console.log(&apos;[EMBEDDING STATUS]&apos;, `${embeddings.length} embeddings found for enabled documents`);

      if (enabledDocuments.length === 0 || embeddings.length === 0) {
        // No enabled documents or no embeddings available, just chat without context
        console.log(&apos;[PROCESSING MODE]&apos;, &apos;Direct response (no RAG context available)&apos;);
        await this.generateDirectResponse(sessionId, content, onStreamEvent);
        console.log(&apos;=== CHAT PIPELINE PROCESS END ===\n&apos;);
        return;
      }

      // 4. GENERATE EMBEDDING USING THE REWRITTEN QUERY
      console.log(&apos;[EMBEDDING GENERATION]&apos;, &apos;Creating vector embedding for enhanced query...&apos;);
      const queryEmbedding = await embeddingService.generateEmbedding(enhancedQuery);
      console.log(&apos;[EMBEDDING GENERATED]&apos;, `Vector created with ${queryEmbedding.length} dimensions`);
      
      // Update progress: Vector Search (75%)
      if (onStreamEvent) {
        onStreamEvent({ type: &apos;status&apos;, message: &apos;Vector Search&apos; });
      }

      // 5. PERFORM SEARCH USING THE REWRITTEN QUERY
      console.log(&apos;[VECTOR SEARCH]&apos;, &apos;Performing hybrid search...&apos;);
      const searchResults = await vectorSearchService.searchHybridEnhanced(
        queryEmbedding,
        sessionId,
        enhancedQuery, // Use the enhanced, rewritten query here
        {
          maxResults: 8,
          useDynamicWeighting: true,
          textWeight: 0.3,
          vectorWeight: 0.7,
          userId: sessionForDocuments.userId // Ensure userId is passed
        }
      );
      console.log(&apos;[SEARCH RESULTS]&apos;, `${searchResults.length} relevant chunks found`);
      console.log(&apos;‚úÖ CHUNKS USED =&apos;, searchResults.length);
      
      // Update progress: Response Generation (90%)
      if (onStreamEvent) {
        onStreamEvent({ type: &apos;status&apos;, message: &apos;Response Generation&apos; });
      }

      // Log detailed search results for debugging
      console.log(&apos;[SEARCH RESULTS DETAIL]&apos;, &apos;Detailed search results:&apos;);
      searchResults.forEach((result, index) =&gt; {
        console.log(`[SEARCH RESULT ${index}]`, {
          chunkId: result.chunk.id,
          documentTitle: result.document.title,
          similarity: result.similarity,
          chunkPage: result.chunk.page,
          metadataPageNumber: result.chunk.metadata?.pageNumber,
          isCombined: result.chunk.metadata?.isCombined,
          originalChunkCount: result.chunk.metadata?.originalChunkCount,
          combinedChunkIds: result.chunk.metadata?.combinedChunkIds,
          contentPreview: result.chunk.content.substring(0, 150) + &apos;...&apos;
        });
      });

      // Build context from search results
      console.log(&apos;[CONTEXT BUILDING]&apos;, &apos;Constructing context from search results...&apos;);
      const context = this.buildContext(searchResults);
      console.log(&apos;[CONTEXT CREATED]&apos;, `Context string length: ${context.length} characters`);

      // ... The rest of the function (Context Building, LLM Generation) remains the same ...
      // IMPORTANT: The final LLM call (generateSimplifiedContextualResponse)
      // should use the standalone query for better context understanding
      
      await this.generateSimplifiedContextualResponse(
        sessionId,
        standaloneQuery, // Use the rewritten query instead of original content
        this.buildContext(searchResults),
        searchResults,
        onStreamEvent
      );

      console.log(&apos;=== CHAT PIPELINE PROCESS END ===\n&apos;);

    } catch (error) {
      console.error(&apos;[PIPELINE ERROR]&apos;, &apos;Error in chat pipeline:&apos;, error);

      // Save error message
      const errorMessage: MessageCreate = {
        sessionId,
        content: &apos;Sorry, I encountered an error while processing your message. Please try again.&apos;,
        role: MessageSender.ASSISTANT,
      };

      await this.indexedDBServices.messageService.createMessage(errorMessage);
      console.log(&apos;[ERROR HANDLED]&apos;, &apos;Error message saved to database&apos;);
      console.log(&apos;=== CHAT PIPELINE PROCESS END (WITH ERROR) ===\n&apos;);
    }
  }

  /**
   * Generate response without document context
   */
  private async generateDirectResponse(
    sessionId: string,
    content: string,
    onStreamEvent?: (event: ChatStreamEvent) =&gt; void
  ): Promise&lt;void&gt; {
    console.log(&apos;\n=== DIRECT RESPONSE MODE (NO RAG) ===&apos;);
    console.log(&apos;[DIRECT MODE]&apos;, &apos;Generating response without document context&apos;);

    // Generate direct response without context
    // Generate direct response without context
    const session = await this.indexedDBServices.sessionService.getSession(sessionId);
    if (!session) {
      throw new Error(&apos;Session not found&apos;);
    }

    const settings = await this.indexedDBServices.settingsService.getSettings(session.userId);
    const messages = await this.indexedDBServices.messageService.getMessagesBySession(sessionId, session.userId);
    console.log(&apos;[CHAT HISTORY]&apos;, `Found ${messages.length} previous messages`);

    let fullResponse = &apos;&apos;;
    let citations: any[] = [];

    await chatService.generateStreamingResponse(
      [...messages, { id: &apos;temp&apos;, sessionId, content, role: MessageSender.USER, timestamp: new Date() }],
      [],
      settings || {
        userId: session.userId,
        geminiApiKey: &apos;&apos;,
        model: &apos;gemini-2.5-flash-lite&apos;,
        temperature: 0.7,
        maxTokens: 2048,
        similarityThreshold: 0.7,
        chunkSize: 1000,
        chunkOverlap: 200,
        theme: &apos;dark&apos;,
        fontSize: &apos;medium&apos;,
        showSources: true,
        autoSave: true,
        dataRetention: &apos;never&apos;,
        enableAnalytics: false,
        crashReporting: false,
        debugMode: false,
        logLevel: &apos;error&apos;
      },
      (event) =&gt; {
        if (event.type === &apos;chunk&apos;) {
          fullResponse += event.content || &apos;&apos;;
          // Don&apos;t send chunks to UI for direct response either
        } else if (event.type === &apos;citation&apos;) {
          citations.push(event.citation);
          // Don&apos;t send citations to UI during streaming
        } else if (event.type === &apos;end&apos;) {
          console.log(&apos;[DIRECT RESPONSE]&apos;, `Generated ${fullResponse.length} characters`);

          // Save assistant message
          const assistantMessage: MessageCreate = {
            sessionId,
            content: fullResponse,
            role: MessageSender.ASSISTANT,
            citations: citations.length &gt; 0 ? citations : undefined,
          };

          this.indexedDBServices.messageService.createMessage(assistantMessage);
          console.log(&apos;[RESPONSE SAVED]&apos;, &apos;Direct response stored in database&apos;);
          if (onStreamEvent) onStreamEvent(event);
        } else if (event.type === &apos;error&apos;) {
          console.error(&apos;[DIRECT MODE ERROR]&apos;, &apos;Streaming error:&apos;, event.error);
          if (onStreamEvent) onStreamEvent(event);
        }
      }
    );

    console.log(&apos;=== DIRECT RESPONSE MODE END ===\n&apos;);
  }

  /**
   * Generate response with document context
   */
  private async generateContextualResponse(
    sessionId: string,
    content: string,
    context: string,
    searchResults: any[],
    onStreamEvent?: (event: ChatStreamEvent) =&gt; void
  ): Promise&lt;void&gt; {
    console.log(&apos;\n=== CONTEXTUAL RESPONSE MODE (WITH RAG) ===&apos;);
    console.log(&apos;[RAG MODE]&apos;, &apos;Generating response with document context&apos;);
    console.log(&apos;[CONTEXT SUMMARY]&apos;, `Providing ${searchResults.length} context sources to LLM`);

    // Get session for system prompt
    // Get session for system prompt and userId
    const session = await this.indexedDBServices.sessionService.getSession(sessionId);
    if (!session) {
      throw new Error(&apos;Session not found&apos;);
    }
    const systemPrompt = this.getDefaultSystemPrompt(searchResults);
    console.log(&apos;[SYSTEM PROMPT]&apos;, &apos;Using default system prompt&apos;);

    const settings = await this.indexedDBServices.settingsService.getSettings(session.userId);
    console.log(&apos;[RAG SETTINGS]&apos;, &apos;Settings loaded for contextual response&apos;);
    console.log(&apos;[RAG SETTINGS]&apos;, `API Key present: ${settings?.geminiApiKey ? &apos;YES&apos; : &apos;NO&apos;}`);
    console.log(&apos;[RAG SETTINGS]&apos;, `Temperature: ${settings?.temperature}`);
    console.log(&apos;[RAG SETTINGS]&apos;, `Max tokens: ${settings?.maxTokens}`);

    const messages = await this.indexedDBServices.messageService.getMessagesBySession(sessionId, session.userId);
    console.log(&apos;[CHAT HISTORY]&apos;, `Found ${messages.length} previous messages`);

    let fullResponse = &apos;&apos;;
    let citations: any[] = [];

    await chatService.generateStreamingResponse(
      [...messages, { id: &apos;temp&apos;, sessionId, content, role: MessageSender.USER, timestamp: new Date() }],
      searchResults.map(result =&gt; ({
        chunk: result.chunk,
        similarity: result.similarity,
        document: result.document
      })),
      settings || {
        userId: session.userId,
        geminiApiKey: &apos;&apos;,
        model: &apos;gemini-2.5-flash-lite&apos;,
        temperature: 0.7,
        maxTokens: 2048,
        similarityThreshold: 0.7,
        chunkSize: 1000,
        chunkOverlap: 200,
        theme: &apos;dark&apos;,
        fontSize: &apos;medium&apos;,
        showSources: true,
        autoSave: true,
        dataRetention: &apos;never&apos;,
        enableAnalytics: false,
        crashReporting: false,
        debugMode: false,
        logLevel: &apos;error&apos;
      },
      (event) =&gt; {
        if (event.type === &apos;start&apos;) {
          console.log(&apos;[RESPONSE START]&apos;, &apos;Beginning streaming response generation&apos;);
          if (onStreamEvent) onStreamEvent({ type: &apos;status&apos;, message: &apos;Starting response generation...&apos; });
        } else if (event.type === &apos;thinking&apos;) {
          if (onStreamEvent) onStreamEvent({ type: &apos;status&apos;, message: event.content || &apos;Thinking...&apos; });
        } else if (event.type === &apos;progress&apos;) {
          if (onStreamEvent) onStreamEvent({
            type: &apos;status&apos;,
            message: `${event.progress?.message || &apos;Processing...&apos;} ${event.progress?.percentage || 0}%`
          });
        } else if (event.type === &apos;chunk&apos;) {
          if (event.content) {
            fullResponse += event.content;

            // Validate chunk in real-time
            const validation = this.validateStreamingChunk(event.content, fullResponse);
            if (!validation.isValid) {
              console.warn(&apos;[VALIDATION WARNING]&apos;, &apos;Streaming validation warning:&apos;, validation.warnings);
            }
            // Don&apos;t send text chunks to UI - we want to hide the unformatted response
          }
        } else if (event.type === &apos;citation&apos;) {
          citations.push(event.citation);
          // Don&apos;t send citations to UI during streaming
        } else if (event.type === &apos;end&apos;) {
          console.log(&apos;[RESPONSE COMPLETE]&apos;, `Generated ${fullResponse.length} characters with ${citations.length} citations`);

          // Process citations with enhanced validation and renumbering
          const citationResult = citationService.processCitations(fullResponse, searchResults);

          // Log validation warnings if any
          if (citationResult.validationWarnings &amp;&amp; citationResult.validationWarnings.length &gt; 0) {
            console.warn(&apos;[CITATION WARNINGS]&apos;, &apos;Citation validation warnings:&apos;, citationResult.validationWarnings);
            // Optionally send warnings to UI for debugging
            if (onStreamEvent) {
              onStreamEvent({
                type: &apos;status&apos;,
                message: `Citation warnings: ${citationResult.validationWarnings.length} issues found`
              });
            }
          }

          // Create metadata for storage with full content
          const citationMetadata = citationService.extractCitationMetadata(
            citationResult.citations,
            searchResults
          );

          // Save assistant message
          const assistantMessage: MessageCreate = {
            sessionId,
            content: citationResult.renumberedResponse,
            role: MessageSender.ASSISTANT,
            citations: citationMetadata,
          };

          this.indexedDBServices.messageService.createMessage(assistantMessage);
          console.log(&apos;[RESPONSE SAVED]&apos;, &apos;Contextual response with citations stored in database&apos;);
          if (onStreamEvent) onStreamEvent({ type: &apos;done&apos; });
        } else if (event.type === &apos;error&apos;) {
          console.error(&apos;[RAG MODE ERROR]&apos;, &apos;Streaming error:&apos;, event.error);
          if (onStreamEvent) onStreamEvent({
            type: &apos;error&apos;,
            message: event.error || &apos;Failed to generate response&apos;
          });
        }
      }
    );

    console.log(&apos;=== CONTEXTUAL RESPONSE MODE END ===\n&apos;);
  }

  /**
   * NEW: Generate response with simplified page-based citation system
   */
  private async generateSimplifiedContextualResponse(
    sessionId: string,
    content: string,
    context: string,
    searchResults: any[],
    onStreamEvent?: (event: ChatStreamEvent) =&gt; void
  ): Promise&lt;void&gt; {
    console.log(&apos;\n=== SIMPLIFIED CONTEXTUAL RESPONSE MODE (WITH RAG) ===&apos;);
    console.log(&apos;[SIMPLIFIED RAG MODE]&apos;, &apos;Generating response with simplified page-based citations&apos;);
    console.log(&apos;[SIMPLIFIED CONTEXT]&apos;, `Providing ${searchResults.length} context sources to LLM`);

    // Get session for system prompt
    // Get session for system prompt and userId
    const session = await this.indexedDBServices.sessionService.getSession(sessionId);
    if (!session) {
      throw new Error(&apos;Session not found&apos;);
    }
    const systemPrompt = this.getSimplifiedSystemPrompt(searchResults);
    console.log(&apos;[SIMPLIFIED SYSTEM PROMPT]&apos;, &apos;Using default simplified system prompt&apos;);

    const settings = await this.indexedDBServices.settingsService.getSettings(session.userId);
    console.log(&apos;[SIMPLIFIED RAG SETTINGS]&apos;, &apos;Settings loaded for simplified contextual response&apos;);

    const messages = await this.indexedDBServices.messageService.getMessagesBySession(sessionId, session.userId);
    console.log(&apos;[SIMPLIFIED CHAT HISTORY]&apos;, `Found ${messages.length} previous messages`);

    let fullResponse = &apos;&apos;;
    let citations: any[] = [];

    await chatService.generateStreamingResponse(
      [...messages, { id: &apos;temp&apos;, sessionId, content, role: MessageSender.USER, timestamp: new Date() }],
      searchResults.map(result =&gt; ({
        chunk: result.chunk,
        similarity: result.similarity,
        document: result.document
      })),
      settings || {
        userId: session.userId,
        geminiApiKey: &apos;&apos;,
        model: &apos;gemini-2.5-flash-lite&apos;,
        temperature: 0.7,
        maxTokens: 2048,
        similarityThreshold: 0.7,
        chunkSize: 1000,
        chunkOverlap: 200,
        theme: &apos;dark&apos;,
        fontSize: &apos;medium&apos;,
        showSources: true,
        autoSave: true,
        dataRetention: &apos;never&apos;,
        enableAnalytics: false,
        crashReporting: false,
        debugMode: false,
        logLevel: &apos;error&apos;
      },
      async (event) =&gt; {
        if (event.type === &apos;start&apos;) {
          console.log(&apos;[SIMPLIFIED RESPONSE START]&apos;, &apos;Beginning streaming response generation&apos;);
          if (onStreamEvent) onStreamEvent({ type: &apos;status&apos;, message: &apos;Starting response generation...&apos; });
        } else if (event.type === &apos;thinking&apos;) {
          if (onStreamEvent) onStreamEvent({ type: &apos;status&apos;, message: event.content || &apos;Thinking...&apos; });
        } else if (event.type === &apos;progress&apos;) {
          if (onStreamEvent) onStreamEvent({
            type: &apos;status&apos;,
            message: `${event.progress?.message || &apos;Processing...&apos;} ${event.progress?.percentage || 0}%`
          });
        } else if (event.type === &apos;chunk&apos;) {
          if (event.content) {
            fullResponse += event.content;
            // Don&apos;t send text chunks to UI - we want to hide the unformatted response
          }
        } else if (event.type === &apos;citation&apos;) {
          citations.push(event.citation);
          // Don&apos;t send citations to UI during streaming
        } else if (event.type === &apos;end&apos;) {
          console.log(&apos;[SIMPLIFIED RESPONSE COMPLETE]&apos;, `Generated ${fullResponse.length} characters with ${citations.length} citations`);

          // Format response to bullet points before processing citations
          // Use default settings if settings is undefined
          const settingsForFormatting = settings || {
            userId: session.userId,
            geminiApiKey: &apos;&apos;,
            model: &apos;gemini-2.5-flash-lite&apos;,
            temperature: 0.7,
            maxTokens: 2048,
            similarityThreshold: 0.7,
            chunkSize: 1000,
            chunkOverlap: 200,
            theme: &apos;dark&apos;,
            fontSize: &apos;medium&apos;,
            showSources: true,
            autoSave: true,
            dataRetention: &apos;never&apos;,
            enableAnalytics: false,
            crashReporting: false,
            debugMode: false,
            logLevel: &apos;error&apos;
          };

          console.log(&apos;[DEBUG FORMATTING]&apos;, &apos;About to call ResponseFormatter.formatToBulletPoints&apos;);
          console.log(&apos;[DEBUG FORMATTING]&apos;, `Settings available: ${!!settingsForFormatting}`);
          console.log(&apos;[DEBUG FORMATTING]&apos;, `Formatting API key: ${settingsForFormatting.geminiApiKey ? &apos;YES&apos; : &apos;NO&apos;}`);
          console.log(&apos;[DEBUG FORMATTING]&apos;, `Main API key: ${settingsForFormatting.geminiApiKey ? &apos;YES&apos; : &apos;NO&apos;}`);
          console.log(&apos;[DEBUG FORMATTING]&apos;, `Response length: ${fullResponse.length}`);
          
          // Update progress: Response Formatting (95%)
          if (onStreamEvent) {
            onStreamEvent({ type: &apos;status&apos;, message: &apos;Response Formatting&apos; });
          }
          
          const formattedResponse = await ResponseFormatter.formatToBulletPoints(fullResponse, settingsForFormatting);
          console.log(&apos;[BULLET FORMATTING]&apos;, `Converted to bullet points: ${formattedResponse.length} characters`);
          
          // DEBUG: Log formatted response before citation processing
          console.log(&apos;[PRE-CITATION DEBUG]&apos;, {
            formattedResponseLength: formattedResponse.length,
            hasNewlines: formattedResponse.includes(&apos;\n&apos;),
            newlineCount: (formattedResponse.match(/\n/g) || []).length,
            bulletCount: (formattedResponse.match(/^\* /gm) || []).length,
            firstFewLines: formattedResponse.split(&apos;\n&apos;).slice(0, 5),
            rawCharCodes: Array.from(formattedResponse.substring(0, 100)).map(c =&gt; `${c}(${c.charCodeAt(0)})`).join(&apos; &apos;)
          });

          // Process citations using simplified system
          const citationResult: SimplifiedCitationGroup = citationService.processSimplifiedCitations(formattedResponse, searchResults);
          
          // DEBUG: Log response after citation processing
          console.log(&apos;[POST-CITATION DEBUG]&apos;, {
            renumberedResponseLength: citationResult.renumberedResponse.length,
            hasNewlines: citationResult.renumberedResponse.includes(&apos;\n&apos;),
            newlineCount: (citationResult.renumberedResponse.match(/\n/g) || []).length,
            bulletCount: (citationResult.renumberedResponse.match(/^\* /gm) || []).length,
            firstFewLines: citationResult.renumberedResponse.split(&apos;\n&apos;).slice(0, 5),
            rawCharCodes: Array.from(citationResult.renumberedResponse.substring(0, 100)).map(c =&gt; `${c}(${c.charCodeAt(0)})`).join(&apos; &apos;)
          });

          // DEBUG: Log before storing in database
          console.log(&apos;[PRE-STORAGE DEBUG]&apos;, {
            contentToStore: citationResult.renumberedResponse,
            hasNewlines: citationResult.renumberedResponse.includes(&apos;\n&apos;),
            newlineCount: (citationResult.renumberedResponse.match(/\n/g) || []).length,
            bulletCount: (citationResult.renumberedResponse.match(/^\* /gm) || []).length,
            firstFewLines: citationResult.renumberedResponse.split(&apos;\n&apos;).slice(0, 5)
          });

          console.log(&apos;[SIMPLIFIED CITATION RESULT]&apos;, {
            originalCitations: citations.length,
            processedCitations: citationResult.citations.length,
            pageGroups: citationResult.citations.map(c =&gt; ({ document: c.document, page: c.page }))
          });

          // Convert simplified citations to message citation format for storage
          const citationMetadata = citationService.convertSimplifiedToMessageCitations(citationResult.citations);

          // Save assistant message with formatted response
          const assistantMessage: MessageCreate = {
            sessionId,
            content: citationResult.renumberedResponse,
            role: MessageSender.ASSISTANT,
            citations: citationMetadata,
          };

          console.log(&apos;[MESSAGE STORAGE DEBUG]&apos;, &apos;About to store message with content:&apos;, {
            content: citationResult.renumberedResponse,
            hasNewlines: citationResult.renumberedResponse.includes(&apos;\n&apos;),
            newlineCount: (citationResult.renumberedResponse.match(/\n/g) || []).length,
            bulletCount: (citationResult.renumberedResponse.match(/^\* /gm) || []).length,
            firstFewLines: citationResult.renumberedResponse.split(&apos;\n&apos;).slice(0, 5)
          });

          this.indexedDBServices.messageService.createMessage(assistantMessage);
          console.log(&apos;[SIMPLIFIED RESPONSE SAVED]&apos;, &apos;Simplified contextual response with citations stored in database&apos;);
          if (onStreamEvent) onStreamEvent({ type: &apos;done&apos; });
        } else if (event.type === &apos;error&apos;) {
          console.error(&apos;[SIMPLIFIED RAG MODE ERROR]&apos;, &apos;Streaming error:&apos;, event.error);
          if (onStreamEvent) onStreamEvent({
            type: &apos;error&apos;,
            message: event.error || &apos;Failed to generate response&apos;
          });
        }
      }
    );

    console.log(&apos;=== SIMPLIFIED CONTEXTUAL RESPONSE MODE END ===\n&apos;);
  }

  /**
   * Get simplified system prompt for page-based citation system
   */
  private getSimplifiedSystemPrompt(searchResults?: any[]): string {
    const availableSources = searchResults?.length || 0;

    return `You are a helpful AI assistant that answers questions based on the provided document context.

CRITICAL CONSTRAINT - READ CAREFULLY:
- You MUST ONLY use information from the provided context documents
- You are FORBIDDEN from using any general knowledge, external information, or knowledge from your training data
- If the context does not contain the answer, you MUST respond with &quot;I cannot answer this question based on the provided documents.&quot;
- Do NOT attempt to answer questions about topics not covered in the context (e.g., &quot;who is the president&quot;, current events, general knowledge)
- Every single statement you make must be supported by the provided context
- NEVER answer questions about politics, current events, celebrities, sports, or any topic not in the documents
- If someone asks &quot;who is the president&quot; or similar general knowledge questions, you must respond that you cannot answer based on the provided documents

CONTEXT USAGE:
- Use ONLY the provided context to inform your answers
- Base your responses ENTIRELY on the given documents
- Don&apos;t mention &quot;according to the context&quot; or similar phrases
- If context doesn&apos;t contain relevant information, say so clearly

MEDICAL ABBREVIATIONS:
When processing medical queries, understand and use these common medical abbreviations:
- &quot;rx&quot; or &quot;Rx&quot; means treatment of a certain condition
- &quot;Tx&quot; or &quot;tx&quot; also menas means treatment
- &quot;Dx&quot; or &quot;dx&quot; means diagnosis (you should search for history, clinical features, AND investigations of the condition)
- &quot;inv&quot; or &quot;Inv&quot; means investigations or diagnostic tests
- &quot;Give details about: mans Give all the information you can find about hte given query form the sources in a summarized way 
- &quot;Features&quot; means - give information on HISTORY and CLINICAL features (examination findings) of the particualr condition


SIMPLIFIED VANCOUVER CITATION REQUIREMENTS:
- ALWAYS cite your sources using Vancouver style: [1], [2], [3] format
- Each citation represents a PAGE from a document that contains the information you&apos;re citing
- All chunks from the same page are already combined into a single citation
- Use citations for ALL factual claims, statistics, quotes, and specific information
- Citations are MANDATORY - every factual statement must have a citation
- Don&apos;t cite general knowledge or common sense statements (but you shouldn&apos;t be using these anyway)
- Place citations immediately after the information they support
- Citations must be numbered sequentially in the order they appear in your response
- CRITICAL: Only use citation numbers that correspond to the provided context sources (1 through ${availableSources})
- NEVER invent citation numbers or use numbers outside of available range
- Each citation number represents a specific page with combined content from that page
- WARNING: Citing incorrect sources will mislead users and is unacceptable

RESPONSE GUIDELINES:
- Be accurate and helpful
- Provide comprehensive but concise answers
- Handle unit conversions for medical/technical data (e.g., temperatures, weights)
- Maintain a professional but conversational tone
- If multiple documents provide conflicting information, acknowledge the discrepancy

ANSWER STRUCTURE:
1. Direct answer to the question
2. Supporting details with VERIFIED page-based citations
3. Additional relevant context if available

Remember: Your goal is to provide accurate, well-cited responses based SOLELY on the provided document context. NEVER use external knowledge. If the context doesn&apos;t contain the answer, explicitly state that you cannot answer based on the provided documents. CITATION ACCURACY IS YOUR HIGHEST PRIORITY.`;
  }

  /**
   * Build context string from search results following Flutter app&apos;s approach
   * Enhanced with clearer source labeling and content previews
   * IMPROVED: Better page number detection and clearer source identification
   */
  private buildContext(searchResults: any[]): string {
    if (searchResults.length === 0) {
      return &apos;&apos;;
    }

    console.log(&apos;\n=== CONTEXT BUILDING DEBUG ===&apos;);
    console.log(&apos;[BUILDING CONTEXT]&apos;, `Processing ${searchResults.length} search results for context`);

    const contextParts: string[] = [];
    contextParts.push(&apos;Retrieved Context Sources:\n&apos;);

    for (let i = 0; i &lt; searchResults.length; i++) {
      const result = searchResults[i];
      const chunk = result.chunk;
      const document = result.document;

      // Enhanced page number detection - same logic as citation service
      let pageInfo = &apos;&apos;;
      if (chunk.metadata?.pageNumbers &amp;&amp; chunk.metadata.pageNumbers.length &gt; 0) {
        pageInfo = ` (Page ${chunk.metadata.pageNumbers[0]})`;
      } else if (chunk.page &amp;&amp; chunk.page &gt; 0) {
        pageInfo = ` (Page ${chunk.page})`;
      } else if (chunk.metadata?.pageNumber &amp;&amp; chunk.metadata.pageNumber &gt; 0) {
        pageInfo = ` (Page ${chunk.metadata.pageNumber})`;
      } else {
        // Try to extract from content
        const pagePatterns = [
          /page\s+(\d+)/i,
          /p\.?\s*(\d+)/i,
          /Á¨¨(\d+)È°µ/,
          /page\s+(\d+)\s+of/i,
        ];

        for (const pattern of pagePatterns) {
          const match = chunk.content.match(pattern);
          if (match &amp;&amp; match[1]) {
            const extractedPage = parseInt(match[1], 10);
            if (extractedPage &gt; 0) {
              pageInfo = ` (Page ${extractedPage})`;
              break;
            }
          }
        }
      }

      // Create content preview for better source identification
      const contentPreview = this.createContentPreview(chunk.content);
      const similarityScore = result.similarity ? ` (Similarity: ${(result.similarity * 100).toFixed(1)}%)` : &apos;&apos;;

      console.log(`[CONTEXT SOURCE ${i + 1}]`, {
        documentTitle: document.title,
        pageInfo: pageInfo.trim(),
        similarity: result.similarity,
        chunkId: chunk.id,
        contentPreview: contentPreview,
        isCombined: chunk.metadata?.isCombined,
        originalChunkCount: chunk.metadata?.originalChunkCount
      });

      contextParts.push(`[${i + 1}] ${document.title}${pageInfo}${similarityScore}`);
      contextParts.push(`Preview: ${contentPreview}`);
      contextParts.push(&apos;&apos;);
      contextParts.push(`Full Content:`);
      contextParts.push(chunk.content.trim());
      contextParts.push(&apos;&apos;);
      contextParts.push(&apos;---&apos;);
      contextParts.push(&apos;&apos;);
    }

    const finalContext = contextParts.join(&apos;\n&apos;).trim();
    console.log(&apos;[CONTEXT BUILT]&apos;, `Final context length: ${finalContext.length} characters`);
    console.log(&apos;=== CONTEXT BUILDING DEBUG END ===\n&apos;);

    return finalContext;
  }

  /**
   * Create a brief content preview to help identify relevant sources
   */
  private createContentPreview(content: string, maxLength: number = 150): string {
    // Remove extra whitespace but preserve newlines for list formatting
    const cleanedContent = content.trim().replace(/[ \t]+/g, &apos; &apos;);

    if (cleanedContent.length &lt;= maxLength) {
      return cleanedContent;
    }

    // Try to end at a sentence boundary
    const truncated = cleanedContent.substring(0, maxLength);
    const lastSentenceEnd = Math.max(
      truncated.lastIndexOf(&apos;.&apos;),
      truncated.lastIndexOf(&apos;!&apos;),
      truncated.lastIndexOf(&apos;?&apos;)
    );

    if (lastSentenceEnd &gt; maxLength * 0.7) {
      return truncated.substring(0, lastSentenceEnd + 1);
    }

    return truncated + &apos;...&apos;;
  }


  /**
   * Get enhanced system prompt based on Flutter app&apos;s approach
   */
  private getDefaultSystemPrompt(searchResults?: any[]): string {
    const availableSources = searchResults?.length || 0;

    return `You are a helpful AI assistant that answers questions based on the provided document context.

CRITICAL CONSTRAINT - READ CAREFULLY:
- You MUST ONLY use information from the provided context documents
- You are FORBIDDEN from using any general knowledge, external information, or knowledge from your training data
- If the context does not contain the answer, you MUST respond with &quot;I cannot answer this question based on the provided documents.&quot;
- Do NOT attempt to answer questions about topics not covered in the context (e.g., &quot;who is the president&quot;, current events, general knowledge)
- Every single statement you make must be supported by the provided context
- NEVER answer questions about politics, current events, celebrities, sports, or any topic not in the documents
- If someone asks &quot;who is the president&quot; or similar general knowledge questions, you must respond that you cannot answer based on the provided documents

CONTEXT USAGE:
- Use ONLY the provided context to inform your answers
- Base your responses ENTIRELY on the given documents
- Don&apos;t mention &quot;according to the context&quot; or similar phrases
- If context doesn&apos;t contain relevant information, say so clearly

MEDICAL ABBREVIATIONS:
When processing medical queries, understand and use these common medical abbreviations:
- &quot;rx&quot; or &quot;Rx&quot; means treatment or prescription
- &quot;Tx&quot; or &quot;tx&quot; means treatment
- &quot;Dx&quot; or &quot;dx&quot; means diagnosis (you should search for history, clinical features, and investigations of the condition)
- &quot;inv&quot; or &quot;Inv&quot; means investigations or diagnostic tests

CRITICAL CITATION ACCURACY REQUIREMENTS:
- BEFORE citing any source, VERIFY that the information you&apos;re presenting actually appears in that source
- Each citation [number] MUST reference a source that CONTAINS the specific information you&apos;re citing
- NEVER cite a source that discusses a different topic, even if it&apos;s related
- Example: If you&apos;re defining &quot;cataract&quot;, ONLY cite sources that actually contain the cataract definition
- DO NOT cite sources about ophthalmoscopy or ultrasound when defining cataract
- Read each source carefully and ensure the content matches what you&apos;re claiming
- If you&apos;re unsure whether a source contains the information, DO NOT cite it
- It is BETTER to have fewer citations than to cite irrelevant sources

VANCOUVER CITATION REQUIREMENTS:
- ALWAYS cite your sources using Vancouver style: [1], [2], [3] format
- Each citation must reference the specific document chunk that DIRECTLY supports your statement
- Use citations for ALL factual claims, statistics, quotes, and specific information
- Citations are MANDATORY - every factual statement must have a citation
- Don&apos;t cite general knowledge or common sense statements (but you shouldn&apos;t be using these anyway)
- Place citations immediately after the information they support
- Citations must be numbered sequentially in the order they appear in your response
- CRITICAL: Only use citation numbers that correspond to the provided context sources (1 through ${availableSources})
- NEVER invent citation numbers or use numbers outside the available range
- Each citation number must match exactly one source from the provided context
- WARNING: Citing incorrect sources will mislead users and is unacceptable

RESPONSE GUIDELINES:
- Be accurate and helpful
- Provide comprehensive but concise answers
- Handle unit conversions for medical/technical data (e.g., temperatures, weights)
- Maintain a professional but conversational tone
- If multiple documents provide conflicting information, acknowledge the discrepancy

CITATION VERIFICATION PROCESS:
1. Make a factual claim
2. IMMEDIATELY check if the source [number] actually contains this information
3. If YES, add the citation
4. If NO, either find the correct source or remove the claim
5. Double-check: Does source [number] really say what I&apos;m claiming?

ANSWER STRUCTURE:
1. Direct answer to the question
2. Supporting details with VERIFIED citations
3. Additional relevant context if available

Remember: Your goal is to provide accurate, well-cited responses based SOLELY on the provided document context. NEVER use external knowledge. If the context doesn&apos;t contain the answer, explicitly state that you cannot answer based on the provided documents. CITATION ACCURACY IS YOUR HIGHEST PRIORITY.`;
  }

  /**
   * Clear chat history for a session
   */
  async clearHistory(sessionId: string): Promise&lt;void&gt; {
    await this.indexedDBServices.messageService.deleteMessagesBySession(sessionId);
  }

  /**
   * Get message history for a session
   */
  async getHistory(sessionId: string): Promise&lt;Message[]&gt; {
    // Get session to verify ownership and get userId
    const session = await this.indexedDBServices.sessionService.getSession(sessionId);
    if (!session) {
      throw new Error(&apos;Session not found&apos;);
    }
    return await this.indexedDBServices.messageService.getMessagesBySession(sessionId, session.userId);
  }

  /**
   * Validate streaming chunk for quality control
   */
  private validateStreamingChunk(chunk: string, fullResponse: string): {
    isValid: boolean;
    warnings: string[];
  } {
    const warnings: string[] = [];
    let isValid = true;

    // Check for repeated content (possible loops)
    if (fullResponse.length &gt; 100 &amp;&amp; chunk.length &gt; 0) {
      const recentText = fullResponse.slice(-100);
      if (recentText.includes(chunk) &amp;&amp; chunk.length &gt; 10) {
        warnings.push(&apos;Possible content repetition detected&apos;);
        isValid = false;
      }
    }

    // Check for excessive citation density
    const citationMatches = (fullResponse + chunk).match(/\[\d+\]/g);
    if (citationMatches &amp;&amp; citationMatches.length &gt; 10) {
      warnings.push(&apos;High citation density detected&apos;);
    }

    // Check for response getting too long
    if (fullResponse.length &gt; 8000) {
      warnings.push(&apos;Response approaching maximum length&apos;);
    }

    return { isValid, warnings };
  }
}

// Singleton instance
export const chatPipeline = new ChatPipeline();</file><file path="src/app/settings/page.tsx">&apos;use client&apos;;

import React, { useState, useEffect } from &apos;react&apos;;

export const dynamic = &apos;force-dynamic&apos;;
import { useRouter } from &apos;next/navigation&apos;;
import { useSettingsStore } from &apos;../../store&apos;;
import { Button } from &apos;../../components/ui/Button&apos;;
import { Card } from &apos;../../components/ui/Card&apos;;
import { Input } from &apos;../../components/ui/Input&apos;;
import { Modal } from &apos;../../components/ui/Modal&apos;;
import { ConfirmDialog } from &apos;../../components/common/ConfirmDialog&apos;;
import { Header } from &apos;../../components/layout/Header&apos;;
import clsx from &apos;clsx&apos;;
import type { ApiKeyValidationResult } from &apos;../../types/settings&apos;;

export default function SettingsPage() {
  const router = useRouter();
  const {
    settings,
    updateSettings,
    loadSettings,
    isLoading,
    userId
  } = useSettingsStore();

  const [localSettings, setLocalSettings] = useState({
    geminiApiKey: &apos;&apos;,
  });

  const [showApiKeyDialog, setShowApiKeyDialog] = useState(false);
  const [showResetDialog, setShowResetDialog] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);
  const [isTestingConnection, setIsTestingConnection] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState&lt;&apos;idle&apos; | &apos;testing&apos; | &apos;success&apos; | &apos;error&apos;&gt;(&apos;idle&apos;);
  const [validationResult, setValidationResult] = useState&lt;ApiKeyValidationResult | null&gt;(null);
  const [showValidationError, setShowValidationError] = useState(false);
  const [isMounted, setIsMounted] = useState(false);
  const [showSaveBanner, setShowSaveBanner] = useState&lt;&apos;success&apos; | &apos;error&apos; | null&gt;(null);
  const [isApiKeySaved, setIsApiKeySaved] = useState(false);
  const [savedApiKey, setSavedApiKey] = useState(&apos;&apos;);

  useEffect(() =&gt; {
    setIsMounted(true);
  }, []);

  useEffect(() =&gt; {
    if (isMounted &amp;&amp; userId) {
      loadSettings(userId);
    }
  }, [loadSettings, isMounted, userId]);

  useEffect(() =&gt; {
    if (settings) {
      console.log(&apos;[SETTINGS PAGE] Settings from store loaded:&apos;, {
        geminiApiKey: settings.geminiApiKey ? `Set (${settings.geminiApiKey.length} chars)` : &apos;Not set&apos;,
      });
      setLocalSettings({
        geminiApiKey: settings.geminiApiKey || &apos;&apos;,
      });
      setSavedApiKey(settings.geminiApiKey || &apos;&apos;);
      setIsApiKeySaved(!!settings.geminiApiKey);
    }
  }, [settings]);

  const handleSettingChange = (field: string, value: any) =&gt; {
    setLocalSettings(prev =&gt; ({ ...prev, [field]: value }));
    setHasChanges(true);

    // Re-enable save button if API key is changed from saved value
    if (field === &apos;geminiApiKey&apos; &amp;&amp; value !== savedApiKey) {
      setIsApiKeySaved(false);
    }
  };

  const handleSave = async () =&gt; {
    try {
      console.log(&apos;[SETTINGS PAGE] Saving settings:&apos;, {
        geminiApiKey: localSettings.geminiApiKey ? `Set (${localSettings.geminiApiKey.length} chars)` : &apos;Not set&apos;,
      });
      await updateSettings(localSettings);
      setHasChanges(false);
      console.log(&apos;[SETTINGS PAGE] Settings saved successfully&apos;);
    } catch (error) {
      console.error(&apos;[SETTINGS PAGE] Failed to save settings:&apos;, error);
    }
  };

  const handleReset = async () =&gt; {
    try {
      const defaultSettings = {
        geminiApiKey: &apos;&apos;,
      };
      await updateSettings(defaultSettings);
      setLocalSettings(defaultSettings);
      setHasChanges(false);
      setShowResetDialog(false);
    } catch (error) {
      console.error(&apos;Failed to reset settings:&apos;, error);
    }
  };

  const handleApiKeyUpdate = async (apiKey: string) =&gt; {
    console.log(&apos;[SETTINGS PAGE] API Key update called with:&apos;, apiKey ? `Set (${apiKey.length} chars)` : &apos;Not set&apos;);
    setLocalSettings(prev =&gt; ({ ...prev, geminiApiKey: apiKey }));
    setHasChanges(true);
    setShowApiKeyDialog(false);
    console.log(&apos;[SETTINGS PAGE] Local settings updated, hasChanges:&apos;, true);

    // Auto-save when API key is set
    try {
      console.log(&apos;[SETTINGS PAGE] Auto-saving API key...&apos;);
      await updateSettings({ ...localSettings, geminiApiKey: apiKey });
      setHasChanges(false);
      console.log(&apos;[SETTINGS PAGE] API key auto-saved successfully&apos;);
    } catch (error) {
      console.error(&apos;[SETTINGS PAGE] Failed to auto-save API key:&apos;, error);
    }
  };


  const handleTestConnection = async () =&gt; {
    if (!localSettings.geminiApiKey) {
      setValidationResult({
        isValid: false,
        error: {
          type: &apos;INVALID_KEY&apos;,
          message: &apos;Please enter an API key first&apos;
        }
      });
      setShowValidationError(true);
      setConnectionStatus(&apos;error&apos;);
      setTimeout(() =&gt; setConnectionStatus(&apos;idle&apos;), 3000);
      return;
    }

    setIsTestingConnection(true);
    setConnectionStatus(&apos;testing&apos;);
    setShowValidationError(false);

    try {
      const { geminiService } = await import(&apos;../../services/gemini&apos;);
      const result = await geminiService.validateApiKey(localSettings.geminiApiKey);
      setValidationResult(result);

      if (result.isValid) {
        setConnectionStatus(&apos;success&apos;);
        setTimeout(() =&gt; setConnectionStatus(&apos;idle&apos;), 5000);
      } else {
        setConnectionStatus(&apos;error&apos;);
        setShowValidationError(true);
        setTimeout(() =&gt; setConnectionStatus(&apos;idle&apos;), 5000);
      }
    } catch (error) {
      setValidationResult({
        isValid: false,
        error: {
          type: &apos;UNKNOWN_ERROR&apos;,
          message: &apos;Failed to test API key connection&apos;,
          details: error instanceof Error ? error.message : String(error)
        }
      });
      setConnectionStatus(&apos;error&apos;);
      setShowValidationError(true);
      setTimeout(() =&gt; setConnectionStatus(&apos;idle&apos;), 5000);
    } finally {
      setIsTestingConnection(false);
    }
  };

  const getErrorMessage = (result: ApiKeyValidationResult) =&gt; {
    if (!result.error) return &apos;Unknown error occurred&apos;;

    switch (result.error.type) {
      case &apos;INVALID_KEY&apos;:
        return &apos;Invalid API Key: &apos; + result.error.message;
      case &apos;NETWORK_ERROR&apos;:
        return &apos;Network Error: &apos; + result.error.message;
      case &apos;QUOTA_EXCEEDED&apos;:
        return &apos;Quota Exceeded: &apos; + result.error.message;
      case &apos;PERMISSION_DENIED&apos;:
        return &apos;Permission Denied: &apos; + result.error.message;
      case &apos;UNKNOWN_ERROR&apos;:
      default:
        return &apos;Error: &apos; + result.error.message;
    }
  };

  const getErrorIcon = (type: string) =&gt; {
    switch (type) {
      case &apos;INVALID_KEY&apos;:
        return &apos;üîë&apos;;
      case &apos;NETWORK_ERROR&apos;:
        return &apos;üåê&apos;;
      case &apos;QUOTA_EXCEEDED&apos;:
        return &apos;üìä&apos;;
      case &apos;PERMISSION_DENIED&apos;:
        return &apos;üö´&apos;;
      case &apos;UNKNOWN_ERROR&apos;:
      default:
        return &apos;‚ö†Ô∏è&apos;;
    }
  };

  if (isLoading) {
    return (
      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col&quot;&gt;
        &lt;Header /&gt;
        &lt;main className=&quot;flex-1 container mx-auto px-4 py-8 overflow-y-auto&quot;&gt;
          &lt;div className=&quot;flex items-center justify-center h-64&quot;&gt;
            &lt;div className=&quot;animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/main&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col&quot;&gt;
      &lt;Header /&gt;

      &lt;main className=&quot;flex-1 container mx-auto px-4 py-8 max-w-4xl overflow-y-auto&quot;&gt;
        &lt;div className=&quot;mb-8&quot;&gt;
          &lt;h1 className=&quot;text-3xl font-bold text-gray-900 dark:text-white mb-2&quot;&gt;
            Settings
          &lt;/h1&gt;
          &lt;p className=&quot;text-gray-600 dark:text-gray-300&quot;&gt;
            Configure your RAG chat application preferences
          &lt;/p&gt;
        &lt;/div&gt;

        &lt;div className=&quot;space-y-6&quot;&gt;
          {/* Success/Error Banner */}
          {showSaveBanner &amp;&amp; (
            &lt;div className={clsx(
              &quot;fixed top-20 right-4 z-50 px-6 py-3 rounded-lg shadow-lg transform transition-all duration-300&quot;,
              showSaveBanner === &apos;success&apos;
                ? &quot;bg-green-500 text-white&quot;
                : &quot;bg-red-500 text-white&quot;
            )}&gt;
              &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
                &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                  &lt;span className=&quot;text-lg&quot;&gt;
                    {showSaveBanner === &apos;success&apos; ? &apos;üéâ&apos; : &apos;üî¥&apos;}
                  &lt;/span&gt;
                  &lt;span className=&quot;font-medium&quot;&gt;
                    {showSaveBanner === &apos;success&apos;
                      ? &apos;üéâ API saved successfully üéâ&apos;
                      : &apos;Enter a correct API key error&apos;}
                  &lt;/span&gt;
                &lt;/div&gt;
                {showSaveBanner === &apos;success&apos; &amp;&amp; (
                  &lt;div className=&quot;text-sm ml-8&quot;&gt;
                    You can now go back and chat with your books! üòÅ
                  &lt;/div&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;
          )}
          {/* API Configuration */}
          &lt;Card&gt;
            &lt;div className=&quot;p-6&quot;&gt;
              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;
                API Configuration
              &lt;/h2&gt;

              &lt;div className=&quot;space-y-4&quot;&gt;
                &lt;div&gt;
                  &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;
                    Gemini API Key
                  &lt;/label&gt;
                  &lt;Input
                    type=&quot;text&quot;
                    value={localSettings.geminiApiKey}
                    onChange={(e) =&gt; handleSettingChange(&apos;geminiApiKey&apos;, e.target.value)}
                    placeholder=&quot;Enter your Gemini API key&quot;
                    className=&quot;w-full mb-4&quot;
                  /&gt;

                  &lt;div className=&quot;flex justify-center mt-6&quot;&gt;
                    &lt;Button
                      variant=&quot;primary&quot;
                      size=&quot;md&quot;
                      className=&quot;w-full max-w-sm py-2 shadow-md hover:shadow-lg transition-all duration-200&quot;
                      onClick={async () =&gt; {
                        if (localSettings.geminiApiKey) {
                          try {
                            console.log(&apos;[SETTINGS PAGE] Testing and saving API key...&apos;);

                            // Test connection first
                            const { geminiService } = await import(&apos;../../services/gemini&apos;);
                            const result = await geminiService.validateApiKey(localSettings.geminiApiKey);

                            if (result.isValid) {
                              // Save API key if test is successful
                              await updateSettings({ geminiApiKey: localSettings.geminiApiKey });
                              setHasChanges(false);
                              setSavedApiKey(localSettings.geminiApiKey);
                              setIsApiKeySaved(true);
                              console.log(&apos;[SETTINGS PAGE] API key saved and tested successfully&apos;);

                              // Show success banner
                              setShowSaveBanner(&apos;success&apos;);
                              setTimeout(() =&gt; setShowSaveBanner(null), 3000);
                            } else {
                              // Show error banner if test fails
                              setShowSaveBanner(&apos;error&apos;);
                              setTimeout(() =&gt; setShowSaveBanner(null), 3000);
                            }
                          } catch (error) {
                            console.error(&apos;[SETTINGS PAGE] Failed to test or save API key:&apos;, error);
                            setShowSaveBanner(&apos;error&apos;);
                            setTimeout(() =&gt; setShowSaveBanner(null), 3000);
                          }
                        }
                      }}
                      disabled={!localSettings.geminiApiKey || isApiKeySaved}
                    &gt;
                      {isApiKeySaved ? &apos;‚úì API Key Saved&apos; : &apos;Save API Key&apos;}
                    &lt;/Button&gt;
                  &lt;/div&gt;

                  {/* Validation Result Display */}
                  {showValidationError &amp;&amp; validationResult &amp;&amp; !validationResult.isValid &amp;&amp; (
                    &lt;div className=&quot;mt-2 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md&quot;&gt;
                      &lt;div className=&quot;flex items-start gap-2&quot;&gt;
                        &lt;span className=&quot;text-lg&quot;&gt;{getErrorIcon(validationResult.error?.type || &apos;UNKNOWN_ERROR&apos;)}&lt;/span&gt;
                        &lt;div className=&quot;flex-1&quot;&gt;
                          &lt;p className=&quot;text-sm font-medium text-red-800 dark:text-red-200&quot;&gt;
                            {getErrorMessage(validationResult)}
                          &lt;/p&gt;
                          {validationResult.responseTime &amp;&amp; (
                            &lt;p className=&quot;text-xs text-red-600 dark:text-red-400 mt-1&quot;&gt;
                              Response time: {validationResult.responseTime}ms
                            &lt;/p&gt;
                          )}
                        &lt;/div&gt;
                        &lt;button
                          onClick={() =&gt; setShowValidationError(false)}
                          className=&quot;text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-200&quot;
                        &gt;
                          ‚úï
                        &lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  )}

                  {validationResult &amp;&amp; validationResult.isValid &amp;&amp; connectionStatus === &apos;success&apos; &amp;&amp; (
                    &lt;div className=&quot;mt-2 p-3 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-md&quot;&gt;
                      &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                        &lt;span className=&quot;text-lg&quot;&gt;‚úÖ&lt;/span&gt;
                        &lt;div className=&quot;flex-1&quot;&gt;
                          &lt;p className=&quot;text-sm font-medium text-green-800 dark:text-green-200&quot;&gt;
                            API key is valid and working correctly!
                          &lt;/p&gt;
                          {validationResult.responseTime &amp;&amp; (
                            &lt;p className=&quot;text-xs text-green-600 dark:text-green-400 mt-1&quot;&gt;
                              Response time: {validationResult.responseTime}ms
                            &lt;/p&gt;
                          )}
                        &lt;/div&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  )}

                  &lt;div className=&quot;mt-4 mb-4&quot;&gt;
                    &lt;p className=&quot;font-semibold text-gray-900 dark:text-white&quot;&gt;üìö What is API key?&lt;/p&gt;
                    &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;It is a simple password needed to chat with your documents ü•≥ - you can get it from the yellow link ‚ú®&lt;/p&gt;
                  &lt;/div&gt;

                  &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400 mt-4&quot;&gt;
                    ‚úÖ Get your API key from{&apos; &apos;}
                    &lt;a
                      href=&quot;https://makersuite.google.com/app/apikey&quot;
                      target=&quot;_blank&quot;
                      rel=&quot;noopener noreferrer&quot;
                      className=&quot;text-yellow-600 dark:text-yellow-400 hover:underline font-bold&quot;
                    &gt;
                      [Google AI Studio - Click here ‚ú®]
                    &lt;/a&gt;
                  &lt;/p&gt;
                  &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400 mt-4 mb-2&quot;&gt;
                    üéâ Just follow &lt;span className=&quot;text-yellow-600 dark:text-yellow-400&quot;&gt;EASY 7 STEPS&lt;/span&gt; shown below to get API KEY
                  &lt;/p&gt;
                  &lt;div className=&quot;mt-2 rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700&quot;&gt;
                    &lt;div className=&quot;relative w-full&quot; style={{ paddingBottom: &apos;177.78%&apos; }}&gt;
                      &lt;iframe
                        src=&quot;https://www.youtube.com/embed/enYGfYGLu6k?rel=0&amp;modestbranding=1&amp;playsinline=1&amp;controls=1&quot;
                        title=&quot;How to get Gemini API Key&quot;
                        className=&quot;absolute top-0 left-0 w-full h-full rounded-lg&quot;
                        frameBorder=&quot;0&quot;
                        allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot;
                        allowFullScreen
                        loading=&quot;lazy&quot;
                      /&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;

              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/Card&gt;


        &lt;/div&gt;
      &lt;/main&gt;

      {/* API Key Dialog */}
      &lt;Modal
        isOpen={showApiKeyDialog}
        onClose={() =&gt; setShowApiKeyDialog(false)}
        title=&quot;Set Gemini API Key&quot;
      &gt;
        &lt;div className=&quot;space-y-4&quot;&gt;
          &lt;p className=&quot;text-gray-600 dark:text-gray-300&quot;&gt;
            Enter your Gemini API key to enable AI chat functionality.
          &lt;/p&gt;

          &lt;Input
            type=&quot;password&quot;
            placeholder=&quot;AIza...&quot;
            onChange={(e) =&gt; setLocalSettings(prev =&gt; ({ ...prev, geminiApiKey: e.target.value }))}
            className=&quot;w-full&quot;
          /&gt;

          &lt;div className=&quot;flex justify-end gap-2&quot;&gt;
            &lt;Button
              variant=&quot;outline&quot;
              onClick={() =&gt; setShowApiKeyDialog(false)}
            &gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button
              onClick={() =&gt; handleApiKeyUpdate(localSettings.geminiApiKey)}
              disabled={!localSettings.geminiApiKey}
            &gt;
              Set Key
            &lt;/Button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/Modal&gt;


      {/* Reset Confirmation Dialog */}
      &lt;ConfirmDialog
        isOpen={showResetDialog}
        onClose={() =&gt; setShowResetDialog(false)}
        onConfirm={handleReset}
        title=&quot;Reset Settings&quot;
        message=&quot;Are you sure you want to reset all settings to their default values? This action cannot be undone.&quot;
        confirmText=&quot;Reset&quot;
        cancelText=&quot;Cancel&quot;
        variant=&quot;danger&quot;
      /&gt;
    &lt;/div&gt;
  );
}</file><file path="next.config.js">/** @type {import(&apos;next&apos;).NextConfig} */
const webpack = require(&apos;webpack&apos;);

const nextConfig = {
  typescript: {
    ignoreBuildErrors: false,
  },
  eslint: {
    ignoreDuringBuilds: false,
  },

  webpack: (config, { dev, isServer }) =&gt; {
    // Enable WebAssembly support
    config.experiments = {
      ...config.experiments,
      asyncWebAssembly: true,
      layers: true,
    };

    // Add support for WebAssembly files
    config.module.rules.push({
      test: /\.wasm$/,
      type: &apos;webassembly/async&apos;,
    });

    // FIX: Enhanced polyfills for Supabase compatibility in Edge Runtime
    config.plugins.push(
      new webpack.DefinePlugin({
        &apos;process.version&apos;: JSON.stringify(&apos;v20.0.0&apos;),
        &apos;process.versions&apos;: JSON.stringify({
          node: &apos;20.0.0&apos;,
          v8: &apos;10.0.0&apos;
        }),
      })
    );

    return config;
  },
  // Headers for security
  async headers() {
    return [
      {
        source: &apos;/(.*)&apos;,
        headers: [
          {
            key: &apos;X-Content-Type-Options&apos;,
            value: &apos;nosniff&apos;,
          },
          {
            key: &apos;X-Frame-Options&apos;,
            value: &apos;DENY&apos;,
          },
          {
            key: &apos;X-XSS-Protection&apos;,
            value: &apos;1; mode=block&apos;,
          },
        ],
      },
    ];
  },
};

module.exports = nextConfig;</file><file path="src/components/document/DocumentLibrary.tsx">&apos;use client&apos;;

import React, { useState, useEffect, useMemo } from &apos;react&apos;;
import { libraryService } from &apos;@/services/libraryService&apos;;
import type { LibraryItem } from &apos;@/types/library&apos;;
import { documentProcessor } from &apos;@/services/rag&apos;;
import { useDocumentStore } from &apos;@/store&apos;;
import { Button, Card, Loading } from &apos;@/components/ui&apos;;
import { getIndexedDBServices } from &apos;@/services/indexedDB&apos;;

interface DocumentLibraryProps {
  sessionId: string;
  onClose: () =&gt; void;
}

interface ProcessingStatus {
  [bookId: string]: {
    status: &apos;pending&apos; | &apos;processing&apos; | &apos;completed&apos; | &apos;error&apos;;
    progress?: number;
    error?: string;
  };
}

export const DocumentLibrary: React.FC&lt;DocumentLibraryProps&gt; = ({ sessionId, onClose }) =&gt; {
  const [books, setBooks] = useState&lt;LibraryItem[]&gt;([]);
  const [isLoadingList, setIsLoadingList] = useState(true);
  const [selectedCategory, setSelectedCategory] = useState&lt;string&gt;(&apos;All Sources&apos;);
  const [selectedBooks, setSelectedBooks] = useState&lt;Set&lt;string&gt;&gt;(new Set());
  const [selectAll, setSelectAll] = useState(false);
  const [isBatchProcessing, setIsBatchProcessing] = useState(false);
  const [processingStatus, setProcessingStatus] = useState&lt;ProcessingStatus&gt;({});
  const [error, setError] = useState&lt;string | null&gt;(null);

  const { userId, loadDocuments } = useDocumentStore();

  // Fetch books on mount
  useEffect(() =&gt; {
    const fetchBooks = async () =&gt; {
      try {
        const list = await libraryService.getAvailableBooks();
        setBooks(list);
      } catch (err) {
        setError(&quot;Failed to load the library. Please check your internet connection.&quot;);
      } finally {
        setIsLoadingList(false);
      }
    };
    fetchBooks();
  }, []);

  // Extract unique categories
  const categories = useMemo(() =&gt; {
    const uniqueCategories = Array.from(new Set(books.map(book =&gt; book.category)));
    return [&apos;All Sources&apos;, ...uniqueCategories];
  }, [books]);

  // Filter books based on selected category
  const filteredBooks = useMemo(() =&gt; {
    if (selectedCategory === &apos;All Sources&apos;) {
      return books;
    }
    return books.filter(book =&gt; book.category === selectedCategory);
  }, [books, selectedCategory]);

  // Calculate total progress for batch processing
  const totalProgress = useMemo(() =&gt; {
    if (selectedBooks.size === 0) return 0;
    let total = 0;
    selectedBooks.forEach(bookId =&gt; {
      const status = processingStatus[bookId];
      if (status?.status === &apos;completed&apos;) {
        total += 100;
      } else if (status?.progress) {
        total += status.progress;
      }
    });
    return Math.round(total / selectedBooks.size);
  }, [selectedBooks, processingStatus]);

  // Handle individual book selection
  const handleBookSelection = (bookId: string) =&gt; {
    const newSelectedBooks = new Set(selectedBooks);
    if (newSelectedBooks.has(bookId)) {
      newSelectedBooks.delete(bookId);
    } else {
      newSelectedBooks.add(bookId);
    }
    setSelectedBooks(newSelectedBooks);

    // Update select all checkbox state
    setSelectAll(newSelectedBooks.size === filteredBooks.length &amp;&amp; filteredBooks.length &gt; 0);
  };

  // Handle select all checkbox
  const handleSelectAll = () =&gt; {
    if (selectAll) {
      setSelectedBooks(new Set());
    } else {
      setSelectedBooks(new Set(filteredBooks.map(book =&gt; book.id)));
    }
    setSelectAll(!selectAll);
  };

  // Check for duplicate books directly in IndexedDB
  const checkForDuplicate = async (book: LibraryItem): Promise&lt;boolean&gt; =&gt; {
    console.log(`üîç DUPLICATE CHECK: Starting duplicate check for book: &quot;${book.name}&quot;`);
    console.log(`üîç DUPLICATE CHECK: Timestamp: ${new Date().toISOString()}`);
    console.log(`üîç DUPLICATE CHECK: Book details:`, {
      id: book.id,
      name: book.name,
      filename: book.filename,
      description: book.description,
      category: book.category
    });
    
    try {
      // Check if userId is available before proceeding
      if (!userId) {
        console.log(&apos;üîç DUPLICATE CHECK: No userId available, cannot check for duplicates&apos;);
        return false;
      }
      
      // Get documents directly from IndexedDB to avoid timing issues with document store
      const { documentService } = await getIndexedDBServices();
      const documents = await documentService.getDocumentsBySession(sessionId, userId);
      
      console.log(`üîç DUPLICATE CHECK: Comparing against ${documents.length} existing documents from IndexedDB`);
      console.log(`üîç DUPLICATE CHECK: IndexedDB query performed at: ${new Date().toISOString()}`);
      
      // Log all existing documents for detailed comparison
      console.log(`üîç DUPLICATE CHECK: Existing documents in IndexedDB:`, documents.map(doc =&gt; ({
        id: doc.id,
        filename: doc.filename,
        title: doc.title,
        sessionId: doc.sessionId,
        status: doc.status,
        enabled: doc.enabled,
        createdAt: doc.createdAt
      })));
      
      // PRIMARY CHECK: Compare book.filename with document.filename (this is the most reliable match)
      console.log(`üîç DUPLICATE CHECK: Checking book.filename vs doc.filename (PRIMARY CHECK)`);
      const bookFilenameMatch = documents.some(doc =&gt; {
        const matches = doc.filename === book.filename;
        console.log(`üîç DUPLICATE CHECK: Comparing book.filename &quot;${book.filename}&quot; with doc.filename &quot;${doc.filename}&quot; = ${matches}`);
        return matches;
      });
      if (bookFilenameMatch) {
        console.log(`üîç DUPLICATE FOUND: Book filename match for &quot;${book.filename}&quot;`);
        alert(`&quot;${book.name}&quot; is already in your library. Skipping duplicate.`);
        return true;
      }
      
      // SECONDARY CHECK: Compare book.filename with document.title (in case title was set to filename)
      console.log(`üîç DUPLICATE CHECK: Checking book.filename vs doc.title (SECONDARY CHECK)`);
      const bookFilenameTitleMatch = documents.some(doc =&gt; {
        const matches = doc.title === book.filename;
        console.log(`üîç DUPLICATE CHECK: Comparing book.filename &quot;${book.filename}&quot; with doc.title &quot;${doc.title}&quot; = ${matches}`);
        return matches;
      });
      if (bookFilenameTitleMatch) {
        console.log(`üîç DUPLICATE FOUND: Book filename vs title match for &quot;${book.filename}&quot;`);
        alert(`&quot;${book.name}&quot; is already in your library. Skipping duplicate.`);
        return true;
      }
      
      // TERTIARY CHECK: Compare book.name with document.filename (for backwards compatibility)
      console.log(`üîç DUPLICATE CHECK: Checking book.name vs doc.filename (TERTIARY CHECK)`);
      const nameToFilenameMatch = documents.some(doc =&gt; {
        const matches = doc.filename === book.name;
        console.log(`üîç DUPLICATE CHECK: Comparing book.name &quot;${book.name}&quot; with doc.filename &quot;${doc.filename}&quot; = ${matches}`);
        return matches;
      });
      if (nameToFilenameMatch) {
        console.log(`üîç DUPLICATE FOUND: Book name to filename match for &quot;${book.name}&quot;`);
        alert(`&quot;${book.name}&quot; is already in your library. Skipping duplicate.`);
        return true;
      }
      
      // QUATERNARY CHECK: Compare book.name with document.title (for backwards compatibility)
      console.log(`üîç DUPLICATE CHECK: Checking book.name vs doc.title (QUATERNARY CHECK)`);
      const nameToTitleMatch = documents.some(doc =&gt; {
        const matches = doc.title === book.name;
        console.log(`üîç DUPLICATE CHECK: Comparing book.name &quot;${book.name}&quot; with doc.title &quot;${doc.title}&quot; = ${matches}`);
        return matches;
      });
      if (nameToTitleMatch) {
        console.log(`üîç DUPLICATE FOUND: Book name to title match for &quot;${book.name}&quot;`);
        alert(`&quot;${book.name}&quot; is already in your library. Skipping duplicate.`);
        return true;
      }
      
      // CASE-INSENSITIVE CHECKS: As fallbacks
      console.log(`üîç DUPLICATE CHECK: Checking case-insensitive book.filename vs doc.filename`);
      const caseInsensitiveFilenameMatch = documents.some(doc =&gt; {
        const matches = doc.filename.toLowerCase() === book.filename.toLowerCase();
        console.log(`üîç DUPLICATE CHECK: Comparing &quot;${book.filename.toLowerCase()}&quot; with &quot;${doc.filename.toLowerCase()}&quot; = ${matches}`);
        return matches;
      });
      if (caseInsensitiveFilenameMatch) {
        console.log(`üîç DUPLICATE FOUND: Case-insensitive filename match for &quot;${book.filename}&quot;`);
        alert(`&quot;${book.name}&quot; is already in your library (case-insensitive match). Skipping duplicate.`);
        return true;
      }
      
      console.log(`üîç DUPLICATE CHECK: Checking case-insensitive book.name vs doc.filename`);
      const caseInsensitiveNameMatch = documents.some(doc =&gt; {
        const matches = doc.filename.toLowerCase() === book.name.toLowerCase();
        console.log(`üîç DUPLICATE CHECK: Comparing &quot;${book.name.toLowerCase()}&quot; with &quot;${doc.filename.toLowerCase()}&quot; = ${matches}`);
        return matches;
      });
      if (caseInsensitiveNameMatch) {
        console.log(`üîç DUPLICATE FOUND: Case-insensitive name match for &quot;${book.name}&quot;`);
        alert(`&quot;${book.name}&quot; is already in your library (case-insensitive match). Skipping duplicate.`);
        return true;
      }
      
      console.log(`üîç NO DUPLICATE: No duplicate found for &quot;${book.name}&quot; (filename: ${book.filename})`);
      return false; // No duplicate found
    } catch (error) {
      console.error(&apos;üîç DUPLICATE CHECK ERROR: Error checking for duplicates in IndexedDB:&apos;, error);
      // If we can&apos;t check IndexedDB, fall back to document store as a last resort
      console.log(&apos;üîç DUPLICATE CHECK: Falling back to document store due to IndexedDB error&apos;);
      const { documents } = useDocumentStore.getState();
      console.log(`üîç DUPLICATE CHECK: Comparing against ${documents.length} existing documents from document store (fallback)`);
      
      const bookFilenameMatch = documents.some(doc =&gt; doc.filename === book.filename);
      if (bookFilenameMatch) {
        console.log(`üîç DUPLICATE FOUND: Book filename match for &quot;${book.filename}&quot; (fallback check)`);
        alert(`&quot;${book.name}&quot; is already in your library. Skipping duplicate.`);
        return true;
      }
      
      console.log(`üîç NO DUPLICATE: No duplicate found for &quot;${book.name}&quot; (fallback check)`);
      return false;
    }
  };

  // Process a single book
  const processSingleBook = async (book: LibraryItem): Promise&lt;void&gt; =&gt; {
    console.log(`üîç PROCESSING: Starting to process book &quot;${book.name}&quot;`);
    console.log(`üîç DUPLICATE CHECK: Performing duplicate check for &quot;${book.name}&quot;`);
    
    // Check for duplicates before processing (now async)
    const isDuplicate = await checkForDuplicate(book);
    if (isDuplicate) {
      console.log(`üîç PROCESSING: Book &quot;${book.name}&quot; skipped due to being a duplicate`);
      // Mark as skipped to show in UI
      setProcessingStatus(prev =&gt; ({
        ...prev,
        [book.id]: {
          status: &apos;error&apos;,
          error: &apos;Duplicate document - already in library&apos;
        }
      }));
      return;
    }
    
    console.log(`üîç PROCESSING: Continuing with normal processing for &quot;${book.name}&quot; (no duplicate found)`);
    if (!userId) throw new Error(&quot;User ID is required&quot;);

    console.log(&apos;üîç PROCESS SINGLE BOOK DEBUG: Starting processing for book:&apos;, {
      bookId: book.id,
      bookName: book.name,
      sessionId,
      userId: userId.substring(0, 8) + &apos;...&apos;,
      timestamp: new Date().toISOString()
    });

    setProcessingStatus(prev =&gt; ({
      ...prev,
      [book.id]: { status: &apos;processing&apos;, progress: 0 }
    }));

    try {
      console.log(&apos;üîç DOWNLOAD DEBUG: Starting download for book:&apos;, book.name);
      // Download &amp; Decompress
      const jsonData = await libraryService.downloadAndParseBook(book.url);
      console.log(&apos;üîç DOWNLOAD DEBUG: Successfully downloaded and parsed book:&apos;, {
        bookName: book.name,
        chunksCount: jsonData.chunks?.length || 0,
        documentId: jsonData.document_metadata?.id
      });

      // Process into Database with progress tracking
      console.log(`[Library] Processing package into session ${sessionId}...`);
      console.log(&apos;üîç PROCESSING DEBUG: Starting document processing for:&apos;, {
        bookName: book.name,
        sessionId,
        chunksCount: jsonData.chunks?.length || 0
      });

      const operationId = await documentProcessor.processPreprocessedPackage(
        sessionId,
        jsonData,
        userId,
        (progress) =&gt; {
          console.log(&apos;üîç PROGRESS DEBUG: Progress update for book:&apos;, {
            bookName: book.name,
            processedChunks: progress.processedChunks,
            totalChunks: progress.totalChunks,
            currentChunk: progress.currentChunk,
            isComplete: progress.isComplete,
            progressPercent: Math.round((progress.processedChunks / progress.totalChunks) * 100)
          });

          setProcessingStatus(prev =&gt; ({
            ...prev,
            [book.id]: {
              status: &apos;processing&apos;,
              progress: Math.round((progress.processedChunks / progress.totalChunks) * 100)
            }
          }));
        }
      );

      console.log(&apos;üîç PROCESSING DEBUG: Document processing completed for book:&apos;, {
        bookName: book.name,
        operationId,
        finalStatus: &apos;completed&apos;
      });

      setProcessingStatus(prev =&gt; ({
        ...prev,
        [book.id]: { status: &apos;completed&apos;, progress: 100 }
      }));
    } catch (err) {
      console.error(&apos;üîç PROCESSING ERROR DEBUG: Error processing book:&apos;, {
        bookName: book.name,
        error: err instanceof Error ? err.message : &apos;Unknown error&apos;,
        stack: err instanceof Error ? err.stack : &apos;No stack trace&apos;,
        timestamp: new Date().toISOString()
      });

      // Check if this is a duplicate error and handle it specially
      if (err instanceof Error &amp;&amp; (err as any).isDuplicate) {
        console.log(&apos;üîç DUPLICATE PREVENTION: Handling duplicate error for book:&apos;, book.name);
        setProcessingStatus(prev =&gt; ({
          ...prev,
          [book.id]: {
            status: &apos;error&apos;,
            error: &apos;Duplicate document - already in library&apos;
          }
        }));
        return; // Don&apos;t continue with regular error handling
      }

      setProcessingStatus(prev =&gt; ({
        ...prev,
        [book.id]: {
          status: &apos;error&apos;,
          error: err instanceof Error ? err.message : &apos;Failed to download book&apos;
        }
      }));
    }
  };

  // Handle batch processing
  const handleBatchDownload = async () =&gt; {
    if (!userId) return alert(&quot;Please log in first&quot;);
    if (selectedBooks.size === 0) return alert(&quot;Please select at least one book&quot;);

    setIsBatchProcessing(true);
    const selectedBooksList = filteredBooks.filter(book =&gt; selectedBooks.has(book.id));

    try {
      // Process all selected books sequentially to avoid race conditions in duplicate checking
      for (const book of selectedBooksList) {
        await processSingleBook(book);
      }

      // Wait a moment for the final status updates
      await new Promise(resolve =&gt; setTimeout(resolve, 1000));

      // Refresh UI to get the actual document status from database
      await loadDocuments(sessionId);

      // CRITICAL FIX: Get accurate success/failure counts by checking actual document status
      // rather than relying on processingStatus which might have race conditions
      const { documents } = useDocumentStore.getState();

      console.log(&apos;üîç SUCCESS COUNT DEBUG: Documents in store after processing:&apos;, documents.length);
      console.log(&apos;üîç SUCCESS COUNT DEBUG: Processing status:&apos;, processingStatus);

      // Enhanced logging for debugging document matching
      console.log(&apos;üîç DOCUMENT STORE DEBUG: All documents in store:&apos;, documents.map(doc =&gt; ({
        id: doc.id,
        filename: doc.filename,
        title: doc.title,
        status: doc.status,
        sessionId: doc.sessionId,
        enabled: doc.enabled
      })));

      console.log(&apos;üîç SELECTED BOOKS DEBUG: All selected books:&apos;, selectedBooksList.map(book =&gt; ({
        id: book.id,
        name: book.name,
        url: book.url
      })));

      // Count successful and failed downloads by checking actual document status
      let successful = 0;
      let failed = 0;

      for (const book of selectedBooksList) {
        console.log(&apos;üîç MATCHING DEBUG: Attempting to match book:&apos;, {
          bookId: book.id,
          bookName: book.name,
          bookUrl: book.url
        });

        // Enhanced matching logic with multiple fallback strategies
        let document = documents.find(doc =&gt;
          doc.filename === book.name ||
          doc.title === book.name ||
          doc.id.includes(book.id)
        );

        // If not found with exact matches, try fuzzy matching
        if (!document) {
          console.log(&apos;üîç MATCHING DEBUG: Exact match failed, trying fuzzy matching&apos;);

          // Try matching by extracting filename from URL
          const urlFilename = book.url.split(&apos;/&apos;).pop()?.split(&apos;.&apos;)[0];
          if (urlFilename) {
            document = documents.find(doc =&gt;
              doc.filename.includes(urlFilename) ||
              doc.title?.includes(urlFilename) ||
              doc.id.includes(urlFilename)
            );
            console.log(&apos;üîç MATCHING DEBUG: URL filename matching:&apos;, {
              urlFilename,
              found: !!document
            });
          }

          // Try matching by book ID parts (in case of UUID regeneration)
          if (!document &amp;&amp; book.id.includes(&apos;_&apos;)) {
            const bookIdParts = book.id.split(&apos;_&apos;);
            for (const part of bookIdParts) {
              if (part.length &gt; 3) { // Only use meaningful parts
                document = documents.find(doc =&gt;
                  doc.id.includes(part) ||
                  doc.filename.includes(part) ||
                  doc.title?.includes(part)
                );
                if (document) {
                  console.log(&apos;üîç MATCHING DEBUG: Found by ID part:&apos;, part);
                  break;
                }
              }
            }
          }

          // Try matching by normalized name (lowercase, no special chars)
          if (!document) {
            const normalizedName = book.name.toLowerCase().replace(/[^a-z0-9]/g, &apos;&apos;);
            document = documents.find(doc =&gt; {
              const normalizedFilename = doc.filename.toLowerCase().replace(/[^a-z0-9]/g, &apos;&apos;);
              const normalizedTitle = doc.title?.toLowerCase().replace(/[^a-z0-9]/g, &apos;&apos;) || &apos;&apos;;
              const normalizedId = doc.id.toLowerCase().replace(/[^a-z0-9]/g, &apos;&apos;);
              return normalizedFilename.includes(normalizedName) ||
                normalizedTitle.includes(normalizedName) ||
                normalizedId.includes(normalizedName);
            });
            console.log(&apos;üîç MATCHING DEBUG: Normalized name matching:&apos;, {
              normalizedName,
              found: !!document
            });
          }
        }

        console.log(&apos;üîç DOCUMENT STATUS DEBUG:&apos;, {
          bookId: book.id,
          bookName: book.name,
          documentFound: !!document,
          documentId: document?.id,
          documentFilename: document?.filename,
          documentTitle: document?.title,
          documentStatus: document?.status,
          processingStatus: processingStatus[book.id]?.status
        });

        // Use actual document status if available, fallback to processing status
        const actualStatus = document?.status || processingStatus[book.id]?.status;

        if (actualStatus === &apos;completed&apos;) {
          successful++;
          console.log(&apos;üîç COUNT DEBUG: Counted as successful - Book:&apos;, book.name, &apos;Document:&apos;, document?.filename);
        } else if (actualStatus === &apos;failed&apos; || actualStatus === &apos;error&apos;) {
          failed++;
          console.log(&apos;üîç COUNT DEBUG: Counted as failed - Book:&apos;, book.name, &apos;Status:&apos;, actualStatus);
        } else {
          // If status is unclear, check processing status as fallback
          if (processingStatus[book.id]?.status === &apos;completed&apos;) {
            successful++;
            console.log(&apos;üîç COUNT DEBUG: Counted as successful (processing status) - Book:&apos;, book.name);
          } else if (processingStatus[book.id]?.status === &apos;error&apos;) {
            failed++;
            console.log(&apos;üîç COUNT DEBUG: Counted as failed (processing status) - Book:&apos;, book.name);
          } else {
            // Unknown status - count as failed for safety
            failed++;
            console.log(&apos;üîç COUNT DEBUG: Counted as failed (unknown status) - Book:&apos;, book.name, &apos;Actual status:&apos;, actualStatus);
          }
        }
      }

      console.log(&apos;üîç FINAL COUNT DEBUG:&apos;, { successful, failed, total: selectedBooksList.length });

      if (failed === 0) {
        alert(`Successfully added ${successful} document(s) to your library!`);
      } else {
        alert(`Added ${successful} document(s). ${failed} document(s) failed to process.`);
      }

      // Clear selections and close modal
      setSelectedBooks(new Set());
      setSelectAll(false);
      setProcessingStatus({});
      onClose();

    } catch (err) {
      console.error(err);
      alert(`Error during batch processing: ${err instanceof Error ? err.message : &apos;Unknown error&apos;}`);
    } finally {
      setIsBatchProcessing(false);
    }
  };

  // Handle single book download (legacy support)
  const handleDownload = async (book: LibraryItem) =&gt; {
    if (!userId) return alert(&quot;Please log in first&quot;);

    setSelectedBooks(new Set([book.id]));
    await handleBatchDownload();
  };

  return (
    &lt;div className=&quot;fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 backdrop-blur-sm&quot;&gt;
      &lt;Card className=&quot;w-full max-w-5xl h-[85vh] flex flex-col bg-gray-50 dark:bg-slate-900 shadow-2xl relative&quot;&gt;

        {/* Header */}
        &lt;div className=&quot;p-6 border-b border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-900 rounded-t-lg&quot;&gt;
          &lt;div className=&quot;flex justify-between items-center mb-4&quot;&gt;
            &lt;div&gt;
              &lt;h2 className=&quot;text-2xl font-bold text-gray-900 dark:text-white&quot;&gt;Medical Library&lt;/h2&gt;
              &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;
                Verified medical resources, ready for instant use.
              &lt;/p&gt;
            &lt;/div&gt;
            &lt;Button variant=&quot;primary&quot; onClick={onClose} disabled={isBatchProcessing}&gt;
              &lt;svg className=&quot;w-6 h-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={2} d=&quot;M6 18L18 6M6 6l12 12&quot; /&gt;
              &lt;/svg&gt;
            &lt;/Button&gt;
          &lt;/div&gt;

        &lt;/div&gt;

        {/* Content Area */}
        &lt;div className=&quot;flex-1 overflow-y-auto p-6 pb-24 relative z-10&quot;&gt;
          {/* Controls Row - Moved inside scrollable area */}
          &lt;div className=&quot;flex flex-col sm:flex-row gap-4 items-start sm:items-center justify-between mb-6&quot;&gt;
            {/* Category Filter Pills */}
            &lt;div className=&quot;flex-1 min-w-0 w-full sm:w-auto sm:overflow-x-auto sm:no-scrollbar sm:mask-linear-fade&quot;&gt;
              &lt;div className=&quot;flex flex-wrap sm:flex-nowrap items-center gap-2 pb-1&quot;&gt;
                {categories.map(category =&gt; {
                  const isSelected = selectedCategory === category;
                  return (
                    &lt;button
                      key={category}
                      onClick={() =&gt; setSelectedCategory(category)}
                      className={`
                        px-4 py-1.5 rounded-full text-sm font-medium whitespace-nowrap transition-all duration-200 border
                        ${isSelected
                          ? &apos;bg-gray-900 dark:bg-white text-white dark:text-black border-gray-900 dark:border-white&apos;
                          : &apos;bg-transparent text-gray-700 dark:text-white border-gray-300 dark:border-white hover:border-gray-400 dark:hover:border-gray-200&apos;}
                      `}
                    &gt;
                      {category}
                    &lt;/button&gt;
                  );
                })}
              &lt;/div&gt;
            &lt;/div&gt;

            {/* Selection Controls */}
            &lt;div className=&quot;flex items-center gap-4&quot;&gt;
              &lt;label className=&quot;flex items-center gap-2 cursor-pointer&quot;&gt;
                &lt;input
                  type=&quot;checkbox&quot;
                  checked={selectAll}
                  onChange={handleSelectAll}
                  disabled={isBatchProcessing}
                  className=&quot;w-5 h-5 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2&quot;
                /&gt;
                &lt;span className=&quot;text-sm font-medium text-gray-700 dark:text-gray-300&quot;&gt;
                  Select All ({filteredBooks.length})
                &lt;/span&gt;
              &lt;/label&gt;

            &lt;/div&gt;
          &lt;/div&gt;
          {isLoadingList ? (
            &lt;div className=&quot;flex flex-col items-center justify-center h-64 space-y-4&quot;&gt;
              &lt;Loading size=&quot;lg&quot; /&gt;
              &lt;p className=&quot;text-gray-500&quot;&gt;Fetching catalog from server...&lt;/p&gt;
            &lt;/div&gt;
          ) : error ? (
            &lt;div className=&quot;text-center text-red-500 p-10&quot;&gt;
              &lt;p className=&quot;text-lg font-semibold&quot;&gt;Unable to connect&lt;/p&gt;
              &lt;p className=&quot;text-sm&quot;&gt;{error}&lt;/p&gt;
              &lt;Button className=&quot;mt-4&quot; onClick={() =&gt; window.location.reload()} variant=&quot;outline&quot;&gt;Retry&lt;/Button&gt;
            &lt;/div&gt;
          ) : filteredBooks.length === 0 ? (
            &lt;div className=&quot;text-center text-gray-500 p-10&quot;&gt;
              &lt;p className=&quot;text-lg font-semibold&quot;&gt;No books found&lt;/p&gt;
              &lt;p className=&quot;text-sm&quot;&gt;Try selecting a different category&lt;/p&gt;
            &lt;/div&gt;
          ) : (
            &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6&quot;&gt;
              {filteredBooks.map((book) =&gt; {
                const isSelected = selectedBooks.has(book.id);
                const status = processingStatus[book.id];
                const isProcessing = status?.status === &apos;processing&apos;;
                const isCompleted = status?.status === &apos;completed&apos;;
                const hasError = status?.status === &apos;error&apos;;

                return (
                  &lt;div
                    key={book.id}
                    className={`
                      relative bg-white dark:bg-slate-800 p-5 rounded-xl border
                      ${isProcessing ? &apos;border-blue-500 ring-1 ring-blue-500&apos; :
                        isCompleted ? &apos;border-green-500 ring-1 ring-green-500&apos; :
                          hasError ? &apos;border-red-500 ring-1 ring-red-500&apos; :
                            &apos;border-gray-200 dark:border-slate-700&apos;}
                      ${isSelected ? &apos;ring-2 ring-blue-500&apos; : &apos;&apos;}
                      shadow-sm hover:shadow-md transition-all duration-200 flex flex-col
                    `}
                  &gt;
                    {/* Selection Checkbox */}
                    &lt;div className=&quot;absolute top-5 left-5&quot;&gt;
                      &lt;input
                        type=&quot;checkbox&quot;
                        checked={isSelected}
                        onChange={() =&gt; handleBookSelection(book.id)}
                        disabled={isBatchProcessing}
                        className=&quot;w-5 h-5 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2 cursor-pointer&quot;
                      /&gt;
                    &lt;/div&gt;

                    {/* Category Badge */}
                    &lt;div className=&quot;absolute top-5 right-5&quot;&gt;
                      &lt;span className=&quot;px-2 py-1 text-[10px] uppercase tracking-wider font-bold bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-gray-300 rounded-md&quot;&gt;
                        {book.category}
                      &lt;/span&gt;
                    &lt;/div&gt;

                    {/* Icon &amp; Info */}
                    &lt;div className=&quot;mb-4 ml-8&quot;&gt;
                      &lt;div className=&quot;w-12 h-12 bg-blue-100 dark:bg-blue-900/30 rounded-lg flex items-center justify-center mb-4 text-2xl&quot;&gt;
                        üìö
                      &lt;/div&gt;
                      &lt;h3 className=&quot;font-bold text-lg text-gray-900 dark:text-white leading-tight mb-2&quot;&gt;
                        {book.name}
                      &lt;/h3&gt;
                      &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400 line-clamp-2 min-h-[2.5rem]&quot;&gt;
                        {book.description}
                      &lt;/p&gt;
                    &lt;/div&gt;

                    {/* Progress Status */}
                    {status &amp;&amp; (
                      &lt;div className=&quot;mb-4 ml-8&quot;&gt;
                        {isProcessing &amp;&amp; (
                          &lt;div className=&quot;space-y-2&quot;&gt;
                            &lt;div className=&quot;flex justify-between text-xs&quot;&gt;
                              &lt;span className=&quot;text-white dark:text-white&quot;&gt;Processing...&lt;/span&gt;
                              &lt;span className=&quot;text-white dark:text-white&quot;&gt;{status.progress}%&lt;/span&gt;
                            &lt;/div&gt;
                            &lt;div className=&quot;w-full bg-gray-200 rounded-full h-1.5&quot;&gt;
                              &lt;div
                                className=&quot;bg-blue-600 h-1.5 rounded-full transition-all duration-300&quot;
                                style={{ width: `${status.progress}%` }}
                              &gt;&lt;/div&gt;
                            &lt;/div&gt;
                          &lt;/div&gt;
                        )}
                        {isCompleted &amp;&amp; (
                          &lt;div className=&quot;flex items-center gap-2 text-green-600 text-sm&quot;&gt;
                            &lt;svg className=&quot;w-4 h-4&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;
                              &lt;path fillRule=&quot;evenodd&quot; d=&quot;M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z&quot; clipRule=&quot;evenodd&quot; /&gt;
                            &lt;/svg&gt;
                            &lt;span&gt;Completed&lt;/span&gt;
                          &lt;/div&gt;
                        )}
                        {hasError &amp;&amp; (
                          &lt;div className=&quot;flex items-center gap-2 text-red-600 text-sm&quot;&gt;
                            &lt;svg className=&quot;w-4 h-4&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 20 20&quot;&gt;
                              &lt;path fillRule=&quot;evenodd&quot; d=&quot;M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z&quot; clipRule=&quot;evenodd&quot; /&gt;
                            &lt;/svg&gt;
                            &lt;span&gt;Error: {status.error}&lt;/span&gt;
                          &lt;/div&gt;
                        )}
                      &lt;/div&gt;
                    )}

                    {/* Meta Info */}
                    &lt;div className=&quot;mt-auto pt-4 border-t border-gray-100 dark:border-slate-700/50&quot;&gt;
                      &lt;span className=&quot;text-xs font-mono text-gray-400&quot;&gt;
                        {book.size} ‚Ä¢ v{book.version}
                      &lt;/span&gt;
                    &lt;/div&gt;
                  &lt;/div&gt;
                );
              })}
            &lt;/div&gt;
          )}
        &lt;/div&gt;

        {/* Fixed Footer with Add Selected Button */}
        {selectedBooks.size &gt; 0 &amp;&amp; (
          &lt;div className=&quot;absolute bottom-0 left-0 right-0 p-6 bg-gray-50 dark:bg-slate-900 border-t border-gray-200 dark:border-slate-700 rounded-t-xl z-20&quot;&gt;
            &lt;div className=&quot;flex flex-col items-center gap-3 mx-auto max-w-sm&quot;&gt;
              &lt;Button
                onClick={handleBatchDownload}
                disabled={isBatchProcessing}
                variant=&quot;primary&quot;
                size=&quot;sm&quot;
                className=&quot;flex items-center gap-2 px-4 py-2 shadow-lg rounded-lg&quot;
              &gt;
                {isBatchProcessing ? (
                  &lt;&gt;
                    &lt;Loading size=&quot;sm&quot; /&gt;
                    Processing ({selectedBooks.size})
                  &lt;/&gt;
                ) : (
                  &lt;&gt;
                    Add Selected ({selectedBooks.size})
                  &lt;/&gt;
                )}
              &lt;/Button&gt;

              {isBatchProcessing &amp;&amp; (
                &lt;div className=&quot;w-full&quot;&gt;
                  &lt;div className=&quot;flex justify-between text-xs mb-1 text-gray-600 dark:text-gray-400&quot;&gt;
                    &lt;span&gt;Overall Progress&lt;/span&gt;
                    &lt;span&gt;{totalProgress}%&lt;/span&gt;
                  &lt;/div&gt;
                  &lt;div className=&quot;w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2&quot;&gt;
                    &lt;div
                      className=&quot;bg-blue-600 h-2 rounded-full transition-all duration-300 ease-out&quot;
                      style={{ width: `${totalProgress}%` }}
                    &gt;&lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              )}

              &lt;p className=&quot;text-gray-500 dark:text-gray-400 text-xs text-center&quot;&gt;
                {isBatchProcessing &amp;&amp; &quot;Please wait, it can take up to 1 minute ‚ù§Ô∏è&quot;}
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/Card&gt;
    &lt;/div&gt;
  );
};</file><file path="src/middleware.ts">import { createServerClient, type CookieOptions } from &apos;@supabase/ssr&apos;
import { NextResponse, type NextRequest } from &apos;next/server&apos;

export const runtime = &apos;experimental-edge&apos;

export async function middleware(request: NextRequest) {
    console.log(&apos;üîç [MIDDLEWARE] Processing request for:&apos;, request.nextUrl.pathname)

    try {
        // Check for required environment variables
        if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
            console.error(&apos;‚ùå [MIDDLEWARE] Missing Supabase environment variables&apos;)
            return NextResponse.next()
        }

        // Skip middleware for static assets and API routes
        if (request.nextUrl.pathname.startsWith(&apos;/_next/&apos;) ||
            request.nextUrl.pathname.startsWith(&apos;/api/&apos;) ||
            request.nextUrl.pathname.includes(&apos;.&apos;)) {
            return NextResponse.next()
        }

        let response = NextResponse.next({
            request: {
                headers: request.headers,
            },
        })

        const supabase = createServerClient(
            process.env.NEXT_PUBLIC_SUPABASE_URL!,
            process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
            {
                cookies: {
                    get(name: string) {
                        return request.cookies.get(name)?.value
                    },
                    set(name: string, value: string, options: CookieOptions) {
                        request.cookies.set({
                            name,
                            value,
                            ...options,
                        })
                        response = NextResponse.next({
                            request: {
                                headers: request.headers,
                            },
                        })
                        response.cookies.set({
                            name,
                            value,
                            ...options,
                        })
                    },
                    remove(name: string, options: CookieOptions) {
                        request.cookies.set({
                            name,
                            value: &apos;&apos;,
                            ...options,
                        })
                        response = NextResponse.next({
                            request: {
                                headers: request.headers,
                            },
                        })
                        response.cookies.set({
                            name,
                            value: &apos;&apos;,
                            ...options,
                        })
                    },
                },
            }
        )

        const {
            data: { user },
        } = await supabase.auth.getUser()

        // If no user and not on login page, redirect to login
        if (!user &amp;&amp; !request.nextUrl.pathname.startsWith(&apos;/login&apos;)) {
            console.log(&apos;üîç [MIDDLEWARE] No user detected, redirecting to login from:&apos;, request.nextUrl.pathname)
            const redirectUrl = new URL(&apos;/login&apos;, request.url)
            redirectUrl.searchParams.set(&apos;redirectedFrom&apos;, request.nextUrl.pathname)
            return NextResponse.redirect(redirectUrl)
        }

        // If user is logged in and on login page, redirect to home
        if (user &amp;&amp; request.nextUrl.pathname.startsWith(&apos;/login&apos;)) {
            return NextResponse.redirect(new URL(&apos;/&apos;, request.url))
        }

        // Access Control Logic
        if (user) {
            // Check profile for subscription status
            const { data: profile } = await supabase
                .from(&apos;profiles&apos;)
                .select(&apos;*&apos;)
                .eq(&apos;id&apos;, user.id)
                .single()

            if (profile) {
                const now = new Date()
                const trialStart = new Date(profile.trial_start_date)
                const trialEnd = new Date(trialStart.getTime() + 30 * 24 * 60 * 60 * 1000) // 30 days
                const isSubscribed = profile.is_subscribed
                const isTrialActive = now &lt; trialEnd

                // If trial expired and not subscribed, we might want to block access or show a modal.
                // For middleware, we can redirect to a &quot;payment required&quot; page or let the app handle the modal.
                // The user requested a modal, so we&apos;ll let the app handle it, but we pass a header or cookie to indicate status?
                // Or we can just let the client-side check handle the modal display.

                // However, to be secure, we should probably block API routes if expired.
                // For now, let&apos;s just ensure they are logged in. The modal will be handled in the layout.
            }
        }

        return response
    } catch (error) {
        console.error(&apos;‚ùå [MIDDLEWARE ERROR]:&apos;, error)
        // In case of error, allow the request to proceed instead of crashing with 404
        return NextResponse.next()
    }
}

export const config = {
    matcher: [
        /*
         * Match all request paths except for the ones starting with:
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         * - auth/callback (auth callback)
         * - api routes (if any)
         * - static assets
         * Feel free to modify this pattern to include more paths.
         */
        &apos;/((?!_next/static|_next/image|favicon.ico|auth/callback|api/|.*\\.(?:svg|png|jpg|jpeg|gif|webp|js|css|json)$).*)&apos;,
    ],
}</file></files></repomix>